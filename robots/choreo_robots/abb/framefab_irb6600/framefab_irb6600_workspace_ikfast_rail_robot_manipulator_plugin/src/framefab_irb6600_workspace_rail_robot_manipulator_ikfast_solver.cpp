/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2018-09-12 01:53:46.824950
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53;
x0=IKcos(j[1]);
x1=IKcos(j[2]);
x2=IKsin(j[3]);
x3=IKcos(j[3]);
x4=IKsin(j[2]);
x5=IKsin(j[4]);
x6=IKcos(j[4]);
x7=IKsin(j[1]);
x8=IKsin(j[6]);
x9=IKcos(j[5]);
x10=IKsin(j[5]);
x11=IKcos(j[6]);
x12=((1.0)*x10);
x13=((0.2)*x1);
x14=((1.0)*x3);
x15=((1.392)*x2);
x16=((0.2)*x6);
x17=((0.2)*x3);
x18=((1.0)*x1);
x19=((0.2)*x2);
x20=((1.392)*x1);
x21=(x0*x4);
x22=(x4*x7);
x23=(x3*x7);
x24=(x2*x4);
x25=(x0*x2);
x26=(x0*x3);
x27=(x10*x6);
x28=(x0*x5);
x29=(x5*x7);
x30=(x1*x14);
x31=(x19*x4);
x32=(x13*x3);
x33=((1.0)*x2*x7);
x34=(x0*x30);
x35=((1.0)*x2*x22);
x36=((((-1.0)*x30))+x24);
x37=(((x18*x2))+((x14*x4)));
x38=(x36*x5);
x39=(((x1*x25))+((x21*x3)));
x40=(x36*x6*x9);
x41=(x10*x37);
x42=((((-1.0)*x2*x21))+x34);
x43=(x35+(((-1.0)*x30*x7)));
x44=(((x14*x22))+((x18*x2*x7)));
x45=((-1.0)*x44);
x46=(x10*x43);
x47=(x45*x6);
x48=(x29+((x39*x6)));
x49=(((x5*(((((-1.0)*x18*x25))+(((-1.0)*x14*x21))))))+((x6*x7)));
x50=(x47+x28);
x51=(((x0*x6))+((x44*x5)));
x52=(x48*x9);
x53=(x50*x9);
eerot[0]=(((x11*((((x10*x42))+x52))))+((x49*x8)));
eerot[1]=(((x11*x49))+((x8*(((((-1.0)*x12*x42))+(((-1.0)*x52)))))));
eerot[2]=(((x10*x48))+((x9*(((((-1.0)*x34))+((x2*x21)))))));
IkReal x54=((1.0)*x26);
eetrans[0]=((0.545)+(((-1.0)*x13*x25))+((x10*((((x16*x39))+(((0.2)*x29))))))+(((-0.32)*x0))+(((-1.0)*x17*x21))+(((-1.0)*x20*x54))+((x9*(((((-1.0)*x13*x54))+((x19*x21))))))+((x15*x21))+(((-1.075)*x21)));
eerot[3]=(((x11*((x46+x53))))+((x51*x8)));
eerot[4]=(((x11*x51))+((x8*(((((-1.0)*x12*x43))+(((-1.0)*x53)))))));
eerot[5]=(((x9*(((((-1.0)*x35))+((x1*x23))))))+((x10*x50)));
IkReal x55=((1.0)*x22);
eetrans[1]=((-0.0075)+((x13*x2*x7))+((x9*(((((-1.0)*x19*x55))+((x13*x23))))))+(((1.075)*x22))+(((-1.0)*x15*x55))+(((0.32)*x7))+((x17*x22))+((x10*((((x16*x45))+(((0.2)*x28))))))+((x20*x23))+j[0]);
eerot[6]=(((x11*(((((-1.0)*x40))+(((-1.0)*x41))))))+((x38*x8)));
eerot[7]=(((x8*((x40+x41))))+((x11*x38)));
eerot[8]=(((x27*(((((-1.0)*x24))+x30))))+((x37*x9)));
eetrans[2]=((-3.306)+(((-1.0)*x32))+((x1*x15))+(((1.392)*x3*x4))+x31+((x27*(((((-1.0)*x31))+x32))))+((x9*((((x17*x4))+((x13*x2))))))+(((-1.075)*x1)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j2,cj2,sj2,htj2,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij2[2], _nj2;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij2[0] = -1; _ij2[1] = -1; _nj2 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]), htj2=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=((-0.545)+(((-0.2)*r02))+px);
new_r10=((-1.0)*r20);
new_r11=((-1.0)*r21);
new_r12=((-1.0)*r22);
new_py=((-3.306)+(((-1.0)*pz))+(((0.2)*r22)));
new_r20=r10;
new_r21=r11;
new_r22=r12;
new_pz=((0.0075)+(((-0.2)*r12))+py);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x56=((1.0)*px);
IkReal x57=((1.0)*pz);
IkReal x58=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x58))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x57)));
rxp0_2=((((-1.0)*r10*x56))+((py*r00)));
rxp1_0=((((-1.0)*r21*x58))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x57)));
rxp1_2=((((-1.0)*r11*x56))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x58)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x57)));
rxp2_2=((((-1.0)*r12*x56))+((py*r02)));
{
IkReal j3eval[1];
j3eval[0]=((sj2*sj2)+(cj2*cj2));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1, j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x59=((((0.2)*cj2))+(((-1.392)*sj2)));
IkReal x60=((((-1.392)*cj2))+(((-0.2)*sj2)));
CheckValue<IkReal> x63 = IKatan2WithCheck(IkReal(x59),IkReal(x60),IKFAST_ATAN2_MAGTHRESH);
if(!x63.valid){
continue;
}
IkReal x61=((1.0)*(x63.value));
if((((x59*x59)+(x60*x60))) < -0.00001)
continue;
CheckValue<IkReal> x64=IKPowWithIntegerCheck(IKabs(IKsqrt(((x59*x59)+(x60*x60)))),-1);
if(!x64.valid){
continue;
}
if( (((x64.value)*(((((-1.0)*py))+(((1.075)*cj2)))))) < -1-IKFAST_SINCOS_THRESH || (((x64.value)*(((((-1.0)*py))+(((1.075)*cj2)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x62=IKasin(((x64.value)*(((((-1.0)*py))+(((1.075)*cj2))))));
j3array[0]=((((-1.0)*x61))+(((-1.0)*x62)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+x62+(((-1.0)*x61)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
if((((3.235689)+(((0.128)*cj2*sj3))+(((0.43)*cj3))+(((0.128)*cj3*sj2))+(((-0.89088)*sj2*sj3))+(((0.89088)*cj2*cj3))+(((-1.0)*pp))+(((-2.9928)*sj3))+(pz*pz)+(((0.688)*sj2)))) < -0.00001)
continue;
IkReal x65=IKsqrt(((3.235689)+(((0.128)*cj2*sj3))+(((0.43)*cj3))+(((0.128)*cj3*sj2))+(((-0.89088)*sj2*sj3))+(((0.89088)*cj2*cj3))+(((-1.0)*pp))+(((-2.9928)*sj3))+(pz*pz)+(((0.688)*sj2))));
j0array[0]=(pz+x65);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=(pz+(((-1.0)*x65)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0valid[0] = true;
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j1eval[3];
IkReal x66=(sj2*sj3);
IkReal x67=(cj3*sj2);
IkReal x68=(cj2*sj3);
IkReal x69=(cj2*cj3);
j1eval[0]=((1.6)+(((5.375)*sj2))+(((6.96)*x69))+(((-6.96)*x66))+x67+x68);
j1eval[1]=IKsign(((0.32)+(((1.392)*x69))+(((1.075)*sj2))+(((-1.392)*x66))+(((0.2)*x68))+(((0.2)*x67))));
j1eval[2]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x70=((1.0)*cj2);
IkReal x71=((((2.0)*cj2*j0*pz))+(((-1.0)*x70*(j0*j0)))+((cj2*(py*py)))+(((-1.0)*pp*x70)));
j1eval[0]=x71;
j1eval[1]=IKsign(x71);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x72=((((-1.0)*sj2*(py*py)))+((sj2*(j0*j0)))+((pp*sj2))+(((-2.0)*j0*pz*sj2)));
j1eval[0]=x72;
j1eval[1]=IKsign(x72);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=0;
cj2=1.0;
j2=0;
j1eval[0]=((-1.02902298850575)+(((1.42073563218391)*sj3))+py);
j1eval[1]=IKsign(((-7.162)+(((6.96)*py))+(((9.88832)*sj3))));
j1eval[2]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=0;
cj2=1.0;
j2=0;
IkReal x73=((0.2)*sj3);
IkReal x74=((1.392)*cj3);
IkReal x75=((((-1.0)*(j0*j0)))+(py*py)+(((-1.0)*pp))+(((2.0)*j0*pz)));
j1eval[0]=x75;
j1eval[1]=IKsign(x75);
j1eval[2]=((IKabs(((((0.32)*j0))+(((-0.32)*pz))+((j0*x74))+((j0*x73))+(((-1.0)*pz*x74))+(((-1.0)*pz*x73)))))+(((0.008)*(IKabs(((((40.0)*px))+(((25.0)*px*sj3))+(((174.0)*cj3*px))))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=0;
cj2=1.0;
j2=0;
j1eval[0]=((1.6)+sj3+(((6.96)*cj3)));
j1eval[1]=((-1.02902298850575)+(((1.42073563218391)*sj3))+py);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.65765402706638)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-568181818.181818)*pz))+(((568181818.181818)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((568181818.181818)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-568181818.181818)*pz))+(((568181818.181818)*j0))))+IKsqr(((568181818.181818)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-568181818.181818)*pz))+(((568181818.181818)*j0))), ((568181818.181818)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x76=IKcos(j1);
IkReal x77=IKsin(j1);
IkReal x78=((1.0)*pz);
IkReal x79=(px*x76);
IkReal x80=((1.0)*x77);
IkReal x81=((0.64)*x77);
evalcond[0]=((((-1.76e-9)*x76))+px);
evalcond[1]=((((-1.0)*x78))+(((-1.76e-9)*x77))+j0);
evalcond[2]=(((j0*x76))+(((-1.0)*x76*x78))+(((-1.0)*px*x80)));
evalcond[3]=((-1.76e-9)+((j0*x77))+x79+(((-1.0)*x77*x78)));
evalcond[4]=((1.1264e-9)+((pz*x81))+(((-0.64)*x79))+(((-1.0)*j0*x81)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.94305714638614)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-2570578695.50879)*pz))+(((2570578695.50879)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2570578695.50879)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-2570578695.50879)*pz))+(((2570578695.50879)*j0))))+IKsqr(((2570578695.50879)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-2570578695.50879)*pz))+(((2570578695.50879)*j0))), ((2570578695.50879)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x653=IKcos(j1);
IkReal x654=IKsin(j1);
IkReal x655=((1.0)*pz);
IkReal x656=(px*x653);
IkReal x657=((1.0)*x654);
IkReal x658=((0.64)*x654);
evalcond[0]=((((-3.89017462000739e-10)*x653))+px);
evalcond[1]=((((-3.89017462000739e-10)*x654))+(((-1.0)*x655))+j0);
evalcond[2]=((((-1.0)*px*x657))+((j0*x653))+(((-1.0)*x653*x655)));
evalcond[3]=((-3.89017462000739e-10)+((j0*x654))+x656+(((-1.0)*x654*x655)));
evalcond[4]=((2.48971175680473e-10)+(((-0.64)*x656))+((pz*x658))+(((-1.0)*j0*x658)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst0=((0.724288857965762)+(((-0.703860716481667)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.724288857965762)+sj3+(((0.703860716481667)*py)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
IkReal x659=((0.724288857347558)+(((-0.70386072)*py)));
sj2=0;
cj2=1.0;
j2=0;
sj3=x659;
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
cj3=IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))));
if( (x659) < -1-IKFAST_SINCOS_THRESH || (x659) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x659);
IkReal gconst0=((0.724288857965762)+(((-0.703860716481667)*py)));
j1eval[0]=((-1.0)+(((-5.69121734545592)*py)));
j1eval[1]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
j1eval[2]=IKsign(((-6.11299795601339e-9)+(((-3.47904e-8)*py))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x660=((0.724288857347558)+(((-0.70386072)*py)));
sj2=0;
cj2=1.0;
j2=0;
sj3=x660;
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
cj3=IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))));
if( (x660) < -1-IKFAST_SINCOS_THRESH || (x660) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x660);
IkReal gconst0=((0.724288857965762)+(((-0.703860716481667)*py)));
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
j1eval[0]=((3.30219998261525)+(((-1.0)*py))+(((9.88831995057204)*(IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))))))));
j1eval[1]=((-1.0)+(((-5.69121734545592)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x661=((0.724288857347558)+(((-0.70386072)*py)));
sj2=0;
cj2=1.0;
j2=0;
sj3=x661;
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
cj3=IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))));
if( (x661) < -1-IKFAST_SINCOS_THRESH || (x661) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x661);
IkReal gconst0=((0.724288857965762)+(((-0.703860716481667)*py)));
IkReal x662=((5.69121734545592)*py);
j1eval[0]=((((-1.0)*j0*x662))+pz+((pz*x662))+(((-1.0)*j0)));
j1eval[1]=((-1.0)+(((-1.0)*x662)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j0))+(IKabs(pz)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x663=((0.724288857347558)+(((-0.70386072)*py)));
IkReal x664=py*py;
IkReal x665=((-1.0)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=x663;
if((((0.475405650226653)+(((-0.495419908206086)*x664))+(((1.01959694901494)*py)))) < -0.00001)
continue;
cj3=IKsqrt(((0.475405650226653)+(((-0.495419908206086)*x664))+(((1.01959694901494)*py))));
if( (x663) < -1-IKFAST_SINCOS_THRESH || (x663) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x663);
pz=0;
j0=0;
pp=((px*px)+x664);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x665);
rxp0_1=(px*r20);
rxp1_0=(r21*x665);
rxp1_1=(px*r21);
rxp2_0=(r22*x665);
rxp2_1=(px*r22);
IkReal gconst0=((0.724288857965762)+(((-0.703860716481667)*py)));
j1eval[0]=((-1.0)+(((-5.69121734545592)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x666=((0.724288857347558)+(((-0.70386072)*py)));
IkReal x667=py*py;
IkReal x668=((-1.0)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=x666;
if((((0.475405650226653)+(((-0.495419908206086)*x667))+(((1.01959694901494)*py)))) < -0.00001)
continue;
cj3=IKsqrt(((0.475405650226653)+(((-0.495419908206086)*x667))+(((1.01959694901494)*py))));
if( (x666) < -1-IKFAST_SINCOS_THRESH || (x666) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x666);
pz=0;
j0=0;
pp=((px*px)+x667);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x668);
rxp0_1=(px*r20);
rxp1_0=(r21*x668);
rxp1_1=(px*r21);
rxp2_0=(r22*x668);
rxp2_1=(px*r22);
IkReal gconst0=((0.724288857965762)+(((-0.703860716481667)*py)));
j1eval[0]=px;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x670=IKPowWithIntegerCheck(px,-1);
if(!x670.valid){
continue;
}
IkReal x669=x670.value;
cj1array[0]=((((-1.5625)*px))+(((3.359375)*py*x669))+(((1.1244359375)*x669))+(((-1.5625)*x669*(py*py))));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x671=IKcos(j1);
IkReal x672=IKsin(j1);
IkReal x673=((0.140772144)*py);
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x674=IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x675=((1.392)*x674);
evalcond[0]=((-1.0)*px*x672);
evalcond[1]=((((-6.11299795601339e-9)*x671))+(((-3.47904e-8)*py*x671))+px);
evalcond[2]=((0.464857771469512)+x675+(((-1.0)*x673))+((px*x671)));
evalcond[3]=(((x672*x675))+(((0.464857771469512)*x672))+(((-1.0)*x672*x673)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x676=IKPowWithIntegerCheck(((-6.11299795601339e-9)+(((-3.47904e-8)*py))),-1);
if(!x676.valid){
continue;
}
cj1array[0]=((-1.0)*px*(x676.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x677=py*py;
IkReal x678=IKcos(j1);
IkReal x679=IKsin(j1);
IkReal x680=((0.140772144)*py);
IkReal x681=(px*x678);
if((((0.475405650226653)+(((-0.495419908206086)*x677))+(((1.01959694901494)*py)))) < -0.00001)
continue;
IkReal x682=IKsqrt(((0.475405650226653)+(((-0.495419908206086)*x677))+(((1.01959694901494)*py))));
IkReal x683=((1.392)*x682);
evalcond[0]=((-1.0)*px*x679);
evalcond[1]=((0.719639)+(((2.15)*py))+(((-1.0)*(px*px)))+(((-1.0)*x677))+(((-0.64)*x681)));
evalcond[2]=((0.464857771469512)+(((-1.0)*x680))+x683+x681);
evalcond[3]=((((0.464857771469512)*x679))+(((-1.0)*x679*x680))+((x679*x683)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x684=py*py;
IkReal x685=((3.47904e-8)*py);
if((((0.475405650226653)+(((-0.495419908206086)*x684))+(((1.01959694901494)*py)))) < -0.00001)
continue;
IkReal x686=IKsqrt(((0.475405650226653)+(((-0.495419908206086)*x684))+(((1.01959694901494)*py))));
CheckValue<IkReal> x687=IKPowWithIntegerCheck(((((-6.11299795601339e-9)*j0))+(((6.11299795601339e-9)*pz))+(((-1.0)*j0*x685))+((pz*x685))),-1);
if(!x687.valid){
continue;
}
CheckValue<IkReal> x688=IKPowWithIntegerCheck(((-6.11299795601339e-9)+(((-1.0)*x685))),-1);
if(!x688.valid){
continue;
}
if( IKabs(((x687.value)*(((2.84167460683006e-9)+(((4.84282368e-8)*py*x686))+(px*px)+(((1.53120479839973e-8)*py))+(((-4.8975191986176e-9)*x684))+(((8.50929315477064e-9)*x686)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x688.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x687.value)*(((2.84167460683006e-9)+(((4.84282368e-8)*py*x686))+(px*px)+(((1.53120479839973e-8)*py))+(((-4.8975191986176e-9)*x684))+(((8.50929315477064e-9)*x686))))))+IKsqr(((-1.0)*px*(x688.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x687.value)*(((2.84167460683006e-9)+(((4.84282368e-8)*py*x686))+(px*px)+(((1.53120479839973e-8)*py))+(((-4.8975191986176e-9)*x684))+(((8.50929315477064e-9)*x686))))), ((-1.0)*px*(x688.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x689=IKcos(j1);
IkReal x690=IKsin(j1);
IkReal x691=((1.0)*pz);
IkReal x692=((0.140772144)*py);
IkReal x693=((0.64)*x690);
IkReal x694=(px*x689);
IkReal x695=x686;
IkReal x696=((1.392)*x695);
evalcond[0]=((((-3.47904e-8)*py*x689))+px+(((-6.11299795601339e-9)*x689)));
evalcond[1]=(((j0*x689))+(((-1.0)*px*x690))+(((-1.0)*x689*x691)));
evalcond[2]=(((x690*x696))+(((-1.0)*x691))+(((-1.0)*x690*x692))+(((0.464857771469512)*x690))+j0);
evalcond[3]=((0.464857771469512)+((j0*x690))+x694+x696+(((-1.0)*x692))+(((-1.0)*x690*x691)));
evalcond[4]=((0.719639)+(((2.15)*py))+(((-0.64)*x694))+((pz*x693))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-1.0)*j0*x693)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x697=IKPowWithIntegerCheck(((0.464857771469512)+(((-0.140772144)*py))+(((1.392)*(IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))))))),-1);
if(!x697.valid){
continue;
}
CheckValue<IkReal> x698=IKPowWithIntegerCheck(((-6.11299795601339e-9)+(((-3.47904e-8)*py))),-1);
if(!x698.valid){
continue;
}
if( IKabs(((x697.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x698.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x697.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x698.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x697.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x698.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x699=IKcos(j1);
IkReal x700=IKsin(j1);
IkReal x701=((1.0)*pz);
IkReal x702=((0.140772144)*py);
IkReal x703=((0.64)*x700);
IkReal x704=(px*x699);
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x705=IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x706=((1.392)*x705);
evalcond[0]=((((-6.11299795601339e-9)*x699))+px+(((-3.47904e-8)*py*x699)));
evalcond[1]=((((-1.0)*px*x700))+((j0*x699))+(((-1.0)*x699*x701)));
evalcond[2]=(((x700*x706))+(((0.464857771469512)*x700))+(((-1.0)*x701))+j0+(((-1.0)*x700*x702)));
evalcond[3]=((0.464857771469512)+((j0*x700))+(((-1.0)*x702))+x706+x704+(((-1.0)*x700*x701)));
evalcond[4]=((0.719639)+(((2.15)*py))+(((-1.0)*(j0*j0)))+(((-0.64)*x704))+(((-1.0)*pp))+(((2.0)*j0*pz))+((pz*x703))+(((-1.0)*j0*x703)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x707 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x707.valid){
continue;
}
CheckValue<IkReal> x708=IKPowWithIntegerCheck(IKsign(((-6.11299795601339e-9)+(((-3.47904e-8)*py)))),-1);
if(!x708.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x707.value)+(((1.5707963267949)*(x708.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x709=IKcos(j1);
IkReal x710=IKsin(j1);
IkReal x711=((1.0)*pz);
IkReal x712=((0.140772144)*py);
IkReal x713=((0.64)*x710);
IkReal x714=(px*x709);
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x715=IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x716=((1.392)*x715);
evalcond[0]=((((-3.47904e-8)*py*x709))+px+(((-6.11299795601339e-9)*x709)));
evalcond[1]=((((-1.0)*px*x710))+(((-1.0)*x709*x711))+((j0*x709)));
evalcond[2]=((((-1.0)*x710*x712))+(((0.464857771469512)*x710))+((x710*x716))+(((-1.0)*x711))+j0);
evalcond[3]=((0.464857771469512)+(((-1.0)*x710*x711))+((j0*x710))+(((-1.0)*x712))+x714+x716);
evalcond[4]=((0.719639)+(((2.15)*py))+(((-1.0)*(j0*j0)))+(((-0.64)*x714))+(((-1.0)*pp))+(((2.0)*j0*pz))+((pz*x713))+(((-1.0)*j0*x713)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst0=((0.724288857965762)+(((-0.703860716481667)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.724288857965762)+sj3+(((0.703860716481667)*py)))))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
IkReal x717=((0.724288857347558)+(((-0.70386072)*py)));
sj2=0;
cj2=1.0;
j2=0;
sj3=x717;
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))))));
if( (x717) < -1-IKFAST_SINCOS_THRESH || (x717) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x717)))));
IkReal gconst0=((0.724288857965762)+(((-0.703860716481667)*py)));
j1eval[0]=((-1.0)+(((-5.69121734545592)*py)));
j1eval[1]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
j1eval[2]=IKsign(((-6.11299795601339e-9)+(((-3.47904e-8)*py))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x718=((0.724288857347558)+(((-0.70386072)*py)));
sj2=0;
cj2=1.0;
j2=0;
sj3=x718;
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))))));
if( (x718) < -1-IKFAST_SINCOS_THRESH || (x718) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x718)))));
IkReal gconst0=((0.724288857965762)+(((-0.703860716481667)*py)));
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
j1eval[0]=((3.30219998261525)+(((-1.0)*py))+(((-9.88831995057204)*(IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))))))));
j1eval[1]=((-1.0)+(((-5.69121734545592)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x719=((0.724288857347558)+(((-0.70386072)*py)));
sj2=0;
cj2=1.0;
j2=0;
sj3=x719;
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))))));
if( (x719) < -1-IKFAST_SINCOS_THRESH || (x719) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x719)))));
IkReal gconst0=((0.724288857965762)+(((-0.703860716481667)*py)));
IkReal x720=((5.69121734545592)*py);
j1eval[0]=(pz+(((-1.0)*j0))+(((-1.0)*j0*x720))+((pz*x720)));
j1eval[1]=((-1.0)+(((-1.0)*x720)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j0))+(IKabs(pz)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x721=((0.724288857347558)+(((-0.70386072)*py)));
IkReal x722=py*py;
IkReal x723=((-1.0)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=x721;
if((((0.475405650226653)+(((-0.495419908206086)*x722))+(((1.01959694901494)*py)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.475405650226653)+(((-0.495419908206086)*x722))+(((1.01959694901494)*py))))));
if( (x721) < -1-IKFAST_SINCOS_THRESH || (x721) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x721)))));
pz=0;
j0=0;
pp=((px*px)+x722);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x723);
rxp0_1=(px*r20);
rxp1_0=(r21*x723);
rxp1_1=(px*r21);
rxp2_0=(r22*x723);
rxp2_1=(px*r22);
IkReal gconst0=((0.724288857965762)+(((-0.703860716481667)*py)));
j1eval[0]=((-1.0)+(((-5.69121734545592)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x724=((0.724288857347558)+(((-0.70386072)*py)));
IkReal x725=py*py;
IkReal x726=((-1.0)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=x724;
if((((0.475405650226653)+(((-0.495419908206086)*x725))+(((1.01959694901494)*py)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.475405650226653)+(((-0.495419908206086)*x725))+(((1.01959694901494)*py))))));
if( (x724) < -1-IKFAST_SINCOS_THRESH || (x724) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x724)))));
pz=0;
j0=0;
pp=((px*px)+x725);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x726);
rxp0_1=(px*r20);
rxp1_0=(r21*x726);
rxp1_1=(px*r21);
rxp2_0=(r22*x726);
rxp2_1=(px*r22);
IkReal gconst0=((0.724288857965762)+(((-0.703860716481667)*py)));
j1eval[0]=px;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x728=IKPowWithIntegerCheck(px,-1);
if(!x728.valid){
continue;
}
IkReal x727=x728.value;
cj1array[0]=((((-1.5625)*px))+(((3.359375)*py*x727))+(((-1.5625)*x727*(py*py)))+(((1.1244359375)*x727)));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x729=IKcos(j1);
IkReal x730=IKsin(j1);
IkReal x731=((0.140772144)*py);
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x732=IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x733=((1.392)*x732);
evalcond[0]=((-1.0)*px*x730);
evalcond[1]=((((-3.47904e-8)*py*x729))+(((-6.11299795601339e-9)*x729))+px);
evalcond[2]=((0.464857771469512)+(((-1.0)*x733))+(((-1.0)*x731))+((px*x729)));
evalcond[3]=((((0.464857771469512)*x730))+(((-1.0)*x730*x733))+(((-1.0)*x730*x731)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x734=IKPowWithIntegerCheck(((-6.11299795601339e-9)+(((-3.47904e-8)*py))),-1);
if(!x734.valid){
continue;
}
cj1array[0]=((-1.0)*px*(x734.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x735=IKcos(j1);
IkReal x736=py*py;
IkReal x737=IKsin(j1);
IkReal x738=((0.140772144)*py);
IkReal x739=(px*x735);
if((((0.475405650226653)+(((-0.495419908206086)*x736))+(((1.01959694901494)*py)))) < -0.00001)
continue;
IkReal x740=IKsqrt(((0.475405650226653)+(((-0.495419908206086)*x736))+(((1.01959694901494)*py))));
IkReal x741=((1.392)*x740);
evalcond[0]=((-1.0)*px*x737);
evalcond[1]=((0.719639)+(((2.15)*py))+(((-1.0)*(px*px)))+(((-0.64)*x739))+(((-1.0)*x736)));
evalcond[2]=((0.464857771469512)+(((-1.0)*x738))+x739+(((-1.0)*x741)));
evalcond[3]=((((-1.0)*x737*x741))+(((0.464857771469512)*x737))+(((-1.0)*x737*x738)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x742=py*py;
IkReal x743=((3.47904e-8)*py);
if((((0.475405650226653)+(((-0.495419908206086)*x742))+(((1.01959694901494)*py)))) < -0.00001)
continue;
IkReal x744=IKsqrt(((0.475405650226653)+(((-0.495419908206086)*x742))+(((1.01959694901494)*py))));
CheckValue<IkReal> x745=IKPowWithIntegerCheck(((((-1.0)*j0*x743))+(((-6.11299795601339e-9)*j0))+(((6.11299795601339e-9)*pz))+((pz*x743))),-1);
if(!x745.valid){
continue;
}
CheckValue<IkReal> x746=IKPowWithIntegerCheck(((-6.11299795601339e-9)+(((-1.0)*x743))),-1);
if(!x746.valid){
continue;
}
if( IKabs(((x745.value)*(((2.84167460683006e-9)+(((-8.50929315477064e-9)*x744))+(px*px)+(((1.53120479839973e-8)*py))+(((-4.84282368e-8)*py*x744))+(((-4.8975191986176e-9)*x742)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x746.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x745.value)*(((2.84167460683006e-9)+(((-8.50929315477064e-9)*x744))+(px*px)+(((1.53120479839973e-8)*py))+(((-4.84282368e-8)*py*x744))+(((-4.8975191986176e-9)*x742))))))+IKsqr(((-1.0)*px*(x746.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x745.value)*(((2.84167460683006e-9)+(((-8.50929315477064e-9)*x744))+(px*px)+(((1.53120479839973e-8)*py))+(((-4.84282368e-8)*py*x744))+(((-4.8975191986176e-9)*x742))))), ((-1.0)*px*(x746.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x747=IKcos(j1);
IkReal x748=IKsin(j1);
IkReal x749=((1.0)*pz);
IkReal x750=((0.140772144)*py);
IkReal x751=((0.64)*x748);
IkReal x752=(px*x747);
IkReal x753=x744;
IkReal x754=((1.392)*x753);
evalcond[0]=((((-6.11299795601339e-9)*x747))+px+(((-3.47904e-8)*py*x747)));
evalcond[1]=(((j0*x747))+(((-1.0)*x747*x749))+(((-1.0)*px*x748)));
evalcond[2]=((((0.464857771469512)*x748))+(((-1.0)*x749))+(((-1.0)*x748*x754))+(((-1.0)*x748*x750))+j0);
evalcond[3]=((0.464857771469512)+((j0*x748))+x752+(((-1.0)*x750))+(((-1.0)*x754))+(((-1.0)*x748*x749)));
evalcond[4]=((0.719639)+(((2.15)*py))+((pz*x751))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-1.0)*j0*x751))+(((-0.64)*x752)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x755=IKPowWithIntegerCheck(((0.464857771469512)+(((-0.140772144)*py))+(((-1.392)*(IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))))))),-1);
if(!x755.valid){
continue;
}
CheckValue<IkReal> x756=IKPowWithIntegerCheck(((-6.11299795601339e-9)+(((-3.47904e-8)*py))),-1);
if(!x756.valid){
continue;
}
if( IKabs(((x755.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x756.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x755.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x756.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x755.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x756.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x757=IKcos(j1);
IkReal x758=IKsin(j1);
IkReal x759=((1.0)*pz);
IkReal x760=((0.140772144)*py);
IkReal x761=((0.64)*x758);
IkReal x762=(px*x757);
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x763=IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x764=((1.392)*x763);
evalcond[0]=((((-6.11299795601339e-9)*x757))+px+(((-3.47904e-8)*py*x757)));
evalcond[1]=((((-1.0)*px*x758))+((j0*x757))+(((-1.0)*x757*x759)));
evalcond[2]=((((-1.0)*x758*x764))+(((-1.0)*x758*x760))+(((0.464857771469512)*x758))+(((-1.0)*x759))+j0);
evalcond[3]=((0.464857771469512)+(((-1.0)*x764))+(((-1.0)*x760))+x762+(((-1.0)*x758*x759))+((j0*x758)));
evalcond[4]=((0.719639)+(((2.15)*py))+(((-1.0)*j0*x761))+(((-0.64)*x762))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+((pz*x761)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x765 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x765.valid){
continue;
}
CheckValue<IkReal> x766=IKPowWithIntegerCheck(IKsign(((-6.11299795601339e-9)+(((-3.47904e-8)*py)))),-1);
if(!x766.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x765.value)+(((1.5707963267949)*(x766.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x767=IKcos(j1);
IkReal x768=IKsin(j1);
IkReal x769=((1.0)*pz);
IkReal x770=((0.140772144)*py);
IkReal x771=((0.64)*x768);
IkReal x772=(px*x767);
if((((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x773=IKsqrt(((0.475405650226653)+(((1.01959694901494)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x774=((1.392)*x773);
evalcond[0]=((((-6.11299795601339e-9)*x767))+(((-3.47904e-8)*py*x767))+px);
evalcond[1]=((((-1.0)*px*x768))+((j0*x767))+(((-1.0)*x767*x769)));
evalcond[2]=((((-1.0)*x768*x770))+(((-1.0)*x768*x774))+(((0.464857771469512)*x768))+(((-1.0)*x769))+j0);
evalcond[3]=((0.464857771469512)+((j0*x768))+x772+(((-1.0)*x774))+(((-1.0)*x770))+(((-1.0)*x768*x769)));
evalcond[4]=((0.719639)+((pz*x771))+(((2.15)*py))+(((-1.0)*(j0*j0)))+(((-1.0)*j0*x771))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.64)*x772)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x775=IKcos(pz);
IkReal x776=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x777=IKsqrt(((-1.0)*(px*px)));
IkReal x778=IKcos(x777);
IkReal x779=IKsin(x777);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst1=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
IkReal gconst2=(((x776*x778))+((x775*x779)));
IkReal gconst3=((((-1.0)*x776*x779))+((x775*x778)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))))+(((-1.0)*pz))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x780=IKcos(pz);
IkReal x781=IKsin(pz);
IkReal x782=x777;
IkReal x783=IKcos(x782);
IkReal x784=IKsin(x782);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x785=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
sj2=0;
cj2=1.0;
j2=0;
sj0=gconst2;
cj0=gconst3;
j0=x785;
IkReal gconst1=x785;
IkReal gconst2=(((x781*x783))+((x780*x784)));
IkReal gconst3=((((-1.0)*x781*x784))+((x780*x783)));
j1eval[0]=IKabs(((7.162)+(((-6.96)*py))+(((-9.88832)*sj3))+px));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x786=((6.96)*py);
IkReal x787=((9.88832)*sj3);
IkReal x788=(x786+x787);
op[0]=((7.162)+(((-1.0)*x788))+px);
op[1]=0;
op[2]=((-7.162)+px+x788);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x789=IKcos(pz);
IkReal x790=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x791=IKsqrt(((-1.0)*(px*px)));
IkReal x792=IKcos(x791);
IkReal x793=IKsin(x791);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst4=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
IkReal gconst5=(((x790*x792))+(((-1.0)*x789*x793)));
IkReal gconst6=(((x790*x793))+((x789*x792)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*pz))+(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x794=IKcos(pz);
IkReal x795=IKsin(pz);
IkReal x796=x791;
IkReal x797=IKcos(x796);
IkReal x798=IKsin(x796);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x799=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
sj2=0;
cj2=1.0;
j2=0;
sj0=gconst5;
cj0=gconst6;
j0=x799;
IkReal gconst4=x799;
IkReal gconst5=((((-1.0)*x794*x798))+((x795*x797)));
IkReal gconst6=(((x794*x797))+((x795*x798)));
j1eval[0]=IKabs(((7.162)+(((-6.96)*py))+(((-9.88832)*sj3))+px));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x800=((6.96)*py);
IkReal x801=((9.88832)*sj3);
IkReal x802=(x801+x800);
op[0]=((7.162)+px+(((-1.0)*x802)));
op[1]=0;
op[2]=((-7.162)+px+x802);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x803=IKPowWithIntegerCheck(((0.32)+(((1.392)*cj3))+(((0.2)*sj3))),-1);
if(!x803.valid){
continue;
}
CheckValue<IkReal> x804=IKPowWithIntegerCheck(((-7.162)+(((6.96)*py))+(((9.88832)*sj3))),-1);
if(!x804.valid){
continue;
}
if( IKabs(((x803.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x804.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x803.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x804.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x803.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x804.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x805=IKcos(j1);
IkReal x806=IKsin(j1);
IkReal x807=((1.0)*pz);
IkReal x808=((0.2)*sj3);
IkReal x809=((1.392)*cj3);
IkReal x810=(pz*x806);
IkReal x811=(j0*x806);
IkReal x812=(px*x805);
evalcond[0]=((((-1.0)*x805*x807))+((j0*x805))+(((-1.0)*px*x806)));
evalcond[1]=((((-7.162)*x805))+(((6.96)*py*x805))+px+(((9.88832)*sj3*x805)));
evalcond[2]=(((x806*x808))+((x806*x809))+(((0.32)*x806))+(((-1.0)*x807))+j0);
evalcond[3]=((0.32)+(((-1.0)*x806*x807))+x812+x811+x809+x808);
evalcond[4]=((0.719639)+(((2.15)*py))+(((0.64)*x810))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.64)*x812))+(((-0.64)*x811)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x813=((0.2)*sj3);
IkReal x814=((1.392)*cj3);
CheckValue<IkReal> x815 = IKatan2WithCheck(IkReal(((((0.32)*j0))+(((-0.32)*pz))+(((-1.0)*pz*x813))+(((-1.0)*pz*x814))+((j0*x813))+((j0*x814)))),IkReal((((px*x814))+((px*x813))+(((0.32)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x815.valid){
continue;
}
CheckValue<IkReal> x816=IKPowWithIntegerCheck(IKsign(((((-1.0)*(j0*j0)))+(py*py)+(((-1.0)*pp))+(((2.0)*j0*pz)))),-1);
if(!x816.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x815.value)+(((1.5707963267949)*(x816.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x817=IKcos(j1);
IkReal x818=IKsin(j1);
IkReal x819=((1.0)*pz);
IkReal x820=((0.2)*sj3);
IkReal x821=((1.392)*cj3);
IkReal x822=(pz*x818);
IkReal x823=(j0*x818);
IkReal x824=(px*x817);
evalcond[0]=((((-1.0)*x817*x819))+(((-1.0)*px*x818))+((j0*x817)));
evalcond[1]=((((9.88832)*sj3*x817))+(((-7.162)*x817))+px+(((6.96)*py*x817)));
evalcond[2]=((((0.32)*x818))+(((-1.0)*x819))+((x818*x820))+((x818*x821))+j0);
evalcond[3]=((0.32)+(((-1.0)*x818*x819))+x823+x821+x820+x824);
evalcond[4]=((0.719639)+(((2.15)*py))+(((0.64)*x822))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.64)*x824))+(((-0.64)*x823)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x825 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x825.valid){
continue;
}
CheckValue<IkReal> x826=IKPowWithIntegerCheck(IKsign(((-7.162)+(((6.96)*py))+(((9.88832)*sj3)))),-1);
if(!x826.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x825.value)+(((1.5707963267949)*(x826.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x827=IKcos(j1);
IkReal x828=IKsin(j1);
IkReal x829=((1.0)*pz);
IkReal x830=((0.2)*sj3);
IkReal x831=((1.392)*cj3);
IkReal x832=(pz*x828);
IkReal x833=(j0*x828);
IkReal x834=(px*x827);
evalcond[0]=(((j0*x827))+(((-1.0)*px*x828))+(((-1.0)*x827*x829)));
evalcond[1]=((((9.88832)*sj3*x827))+px+(((-7.162)*x827))+(((6.96)*py*x827)));
evalcond[2]=((((-1.0)*x829))+(((0.32)*x828))+((x828*x830))+((x828*x831))+j0);
evalcond[3]=((0.32)+(((-1.0)*x828*x829))+x834+x830+x831+x833);
evalcond[4]=((0.719639)+(((2.15)*py))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.64)*x833))+(((-0.64)*x834))+(((0.64)*x832)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j1eval[0]=((1.12097701149425)+py+(((-1.42073563218391)*sj3)));
j1eval[1]=IKsign(((7.802)+(((-9.88832)*sj3))+(((6.96)*py))));
j1eval[2]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x835=((0.2)*sj3);
IkReal x836=((1.392)*cj3);
IkReal x837=((j0*j0)+pp+(((-1.0)*(py*py)))+(((-2.0)*j0*pz)));
j1eval[0]=x837;
j1eval[1]=IKsign(x837);
j1eval[2]=((((0.008)*(IKabs(((((25.0)*px*sj3))+(((174.0)*cj3*px))+(((-40.0)*px)))))))+(IKabs((((j0*x835))+((j0*x836))+(((-1.0)*pz*x835))+(((-1.0)*pz*x836))+(((-0.32)*j0))+(((0.32)*pz))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j1eval[0]=((1.6)+(((-1.0)*sj3))+(((-6.96)*cj3)));
j1eval[1]=((1.12097701149425)+py+(((-1.42073563218391)*sj3)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.48393862652341)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-568181818.181818)*pz))+(((568181818.181818)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((568181818.181818)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-568181818.181818)*pz))+(((568181818.181818)*j0))))+IKsqr(((568181818.181818)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-568181818.181818)*pz))+(((568181818.181818)*j0))), ((568181818.181818)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x838=IKcos(j1);
IkReal x839=IKsin(j1);
IkReal x840=((1.0)*pz);
IkReal x841=(px*x838);
IkReal x842=((1.0)*x839);
IkReal x843=(pz*x839);
evalcond[0]=((((-1.76e-9)*x838))+px);
evalcond[1]=((((-1.76e-9)*x839))+(((-1.0)*x840))+j0);
evalcond[2]=(((j0*x838))+(((-1.0)*px*x842))+(((-1.0)*x838*x840)));
evalcond[3]=((1.76e-9)+(((-1.0)*j0*x842))+(((-1.0)*x841))+x843);
evalcond[4]=((1.1264e-9)+(((-0.64)*j0*x839))+(((0.64)*x843))+(((-0.64)*x841)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-5.08464979997594)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-2570578695.50879)*pz))+(((2570578695.50879)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2570578695.50879)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-2570578695.50879)*pz))+(((2570578695.50879)*j0))))+IKsqr(((2570578695.50879)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-2570578695.50879)*pz))+(((2570578695.50879)*j0))), ((2570578695.50879)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x844=IKcos(j1);
IkReal x845=IKsin(j1);
IkReal x846=((1.0)*pz);
IkReal x847=(px*x844);
IkReal x848=((1.0)*x845);
IkReal x849=(pz*x845);
evalcond[0]=(px+(((-3.89017462000739e-10)*x844)));
evalcond[1]=((((-1.0)*x846))+(((-3.89017462000739e-10)*x845))+j0);
evalcond[2]=((((-1.0)*px*x848))+(((-1.0)*x844*x846))+((j0*x844)));
evalcond[3]=((3.89017462000739e-10)+(((-1.0)*j0*x848))+(((-1.0)*x847))+x849);
evalcond[4]=((2.48971175680473e-10)+(((0.64)*x849))+(((-0.64)*j0*x845))+(((-0.64)*x847)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst8=((0.789011682469823)+(((0.703860716481667)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.789011682469823)+sj3+(((-0.703860716481667)*py)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
IkReal x850=((0.78901168)+(((0.70386072)*py)));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x850;
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
cj3=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))));
if( (x850) < -1-IKFAST_SINCOS_THRESH || (x850) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x850);
IkReal gconst8=((0.789011682469823)+(((0.703860716481667)*py)));
j1eval[0]=((1.0)+(((-1.42452830188679)*py)));
j1eval[1]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
j1eval[2]=IKsign(((2.44224e-8)+(((-3.47904e-8)*py))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x851=((0.78901168)+(((0.70386072)*py)));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x851;
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
cj3=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))));
if( (x851) < -1-IKFAST_SINCOS_THRESH || (x851) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x851);
IkReal gconst8=((0.789011682469823)+(((0.703860716481667)*py)));
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
j1eval[0]=((1.15219999774955)+(((-1.0)*py))+(((-9.88831995057204)*(IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))))))));
j1eval[1]=((1.0)+(((-1.42452830188679)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x852=((0.78901168)+(((0.70386072)*py)));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x852;
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
cj3=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))));
if( (x852) < -1-IKFAST_SINCOS_THRESH || (x852) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x852);
IkReal gconst8=((0.789011682469823)+(((0.703860716481667)*py)));
IkReal x853=((1.42452830188679)*py);
j1eval[0]=(pz+((j0*x853))+(((-1.0)*pz*x853))+(((-1.0)*j0)));
j1eval[1]=((1.0)+(((-1.0)*x853)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j0))+(IKabs(pz)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x854=py*py;
IkReal x855=((0.78901168)+(((0.70386072)*py)));
IkReal x856=((-1.0)*py);
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x855;
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*x854)))) < -0.00001)
continue;
cj3=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*x854))));
if( (x855) < -1-IKFAST_SINCOS_THRESH || (x855) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x855);
pz=0;
j0=0;
pp=((px*px)+x854);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x856);
rxp0_1=(px*r20);
rxp1_0=(r21*x856);
rxp1_1=(px*r21);
rxp2_0=(r22*x856);
rxp2_1=(px*r22);
IkReal gconst8=((0.789011682469823)+(((0.703860716481667)*py)));
j1eval[0]=((1.0)+(((-1.42452830188679)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x857=py*py;
IkReal x858=((0.78901168)+(((0.70386072)*py)));
IkReal x859=((-1.0)*py);
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x858;
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*x857)))) < -0.00001)
continue;
cj3=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*x857))));
if( (x858) < -1-IKFAST_SINCOS_THRESH || (x858) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x858);
pz=0;
j0=0;
pp=((px*px)+x857);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x859);
rxp0_1=(px*r20);
rxp1_0=(r21*x859);
rxp1_1=(px*r21);
rxp2_0=(r22*x859);
rxp2_1=(px*r22);
IkReal gconst8=((0.789011682469823)+(((0.703860716481667)*py)));
j1eval[0]=px;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x861=IKPowWithIntegerCheck(px,-1);
if(!x861.valid){
continue;
}
IkReal x860=x861.value;
cj1array[0]=((((-1.5625)*px))+(((1.1244359375)*x860))+(((-1.5625)*x860*(py*py)))+(((-3.359375)*py*x860)));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x862=IKcos(j1);
IkReal x863=IKsin(j1);
IkReal x864=((0.140772144)*py);
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x865=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x866=((1.392)*x865);
evalcond[0]=((-1.0)*px*x863);
evalcond[1]=(px+(((2.44224e-8)*x862))+(((-3.47904e-8)*py*x862)));
evalcond[2]=((-0.162197664)+(((-1.0)*px*x862))+x866+x864);
evalcond[3]=((((0.162197664)*x863))+(((-1.0)*x863*x866))+(((-1.0)*x863*x864)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x867=IKPowWithIntegerCheck(((2.44224e-8)+(((-3.47904e-8)*py))),-1);
if(!x867.valid){
continue;
}
cj1array[0]=((-1.0)*px*(x867.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x868=py*py;
IkReal x869=IKcos(j1);
IkReal x870=IKsin(j1);
IkReal x871=((0.140772144)*py);
IkReal x872=(px*x869);
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*x868)))) < -0.00001)
continue;
IkReal x873=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*x868))));
IkReal x874=((1.392)*x873);
evalcond[0]=((-1.0)*px*x870);
evalcond[1]=((0.719639)+(((-2.15)*py))+(((-1.0)*(px*px)))+(((-1.0)*x868))+(((-0.64)*x872)));
evalcond[2]=((-0.162197664)+(((-1.0)*x872))+x871+x874);
evalcond[3]=((((-1.0)*x870*x871))+(((-1.0)*x870*x874))+(((0.162197664)*x870)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x875=j0*j0;
IkReal x876=(py*pz);
IkReal x877=((8.6976e-7)*py);
CheckValue<IkReal> x878=IKPowWithIntegerCheck(((((-5.566464e-7)*x876))+(((3.907584e-7)*pz))+(((5.566464e-7)*j0*py))+(((-3.907584e-7)*j0))),-1);
if(!x878.valid){
continue;
}
CheckValue<IkReal> x879=IKPowWithIntegerCheck(((2.44224e-8)+(((-3.47904e-8)*py))),-1);
if(!x879.valid){
continue;
}
if( IKabs(((x878.value)*(((-4.3938278784e-7)+(((1.93861721664e-6)*py))+(((6.1056e-7)*pp))+(((6.1056e-7)*x875))+(((-1.869984e-6)*(py*py)))+(((-16.0)*(px*px)))+(((-1.0)*x875*x877))+(((1.73952e-6)*j0*x876))+(((-1.0)*pp*x877))+(((-1.22112e-6)*j0*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x879.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x878.value)*(((-4.3938278784e-7)+(((1.93861721664e-6)*py))+(((6.1056e-7)*pp))+(((6.1056e-7)*x875))+(((-1.869984e-6)*(py*py)))+(((-16.0)*(px*px)))+(((-1.0)*x875*x877))+(((1.73952e-6)*j0*x876))+(((-1.0)*pp*x877))+(((-1.22112e-6)*j0*pz))))))+IKsqr(((-1.0)*px*(x879.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x878.value)*(((-4.3938278784e-7)+(((1.93861721664e-6)*py))+(((6.1056e-7)*pp))+(((6.1056e-7)*x875))+(((-1.869984e-6)*(py*py)))+(((-16.0)*(px*px)))+(((-1.0)*x875*x877))+(((1.73952e-6)*j0*x876))+(((-1.0)*pp*x877))+(((-1.22112e-6)*j0*pz))))), ((-1.0)*px*(x879.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x880=IKcos(j1);
IkReal x881=IKsin(j1);
IkReal x882=((1.0)*pz);
IkReal x883=((0.140772144)*py);
IkReal x884=(pz*x881);
IkReal x885=(j0*x881);
IkReal x886=(px*x880);
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x887=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x888=((1.392)*x887);
evalcond[0]=((((2.44224e-8)*x880))+(((-3.47904e-8)*py*x880))+px);
evalcond[1]=((((-1.0)*px*x881))+((j0*x880))+(((-1.0)*x880*x882)));
evalcond[2]=((((-1.0)*x882))+(((-1.0)*x881*x883))+(((-1.0)*x881*x888))+(((0.162197664)*x881))+j0);
evalcond[3]=((0.719639)+(((-2.15)*py))+(((0.64)*x884))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.64)*x886))+(((-0.64)*x885)));
evalcond[4]=((-0.162197664)+(((-1.0)*x885))+(((-1.0)*x886))+x884+x883+x888);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x889=IKPowWithIntegerCheck(((0.162197664)+(((-1.392)*(IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))))))+(((-0.140772144)*py))),-1);
if(!x889.valid){
continue;
}
CheckValue<IkReal> x890=IKPowWithIntegerCheck(((2.44224e-8)+(((-3.47904e-8)*py))),-1);
if(!x890.valid){
continue;
}
if( IKabs(((x889.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x890.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x889.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x890.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x889.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x890.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x891=IKcos(j1);
IkReal x892=IKsin(j1);
IkReal x893=((1.0)*pz);
IkReal x894=((0.140772144)*py);
IkReal x895=(pz*x892);
IkReal x896=(j0*x892);
IkReal x897=(px*x891);
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x898=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x899=((1.392)*x898);
evalcond[0]=((((2.44224e-8)*x891))+(((-3.47904e-8)*py*x891))+px);
evalcond[1]=((((-1.0)*px*x892))+((j0*x891))+(((-1.0)*x891*x893)));
evalcond[2]=((((-1.0)*x892*x894))+(((-1.0)*x892*x899))+(((-1.0)*x893))+(((0.162197664)*x892))+j0);
evalcond[3]=((0.719639)+(((-2.15)*py))+(((0.64)*x895))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.64)*x896))+(((-0.64)*x897)));
evalcond[4]=((-0.162197664)+(((-1.0)*x897))+(((-1.0)*x896))+x894+x895+x899);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x900 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x900.valid){
continue;
}
CheckValue<IkReal> x901=IKPowWithIntegerCheck(IKsign(((2.44224e-8)+(((-3.47904e-8)*py)))),-1);
if(!x901.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x900.value)+(((1.5707963267949)*(x901.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x902=IKcos(j1);
IkReal x903=IKsin(j1);
IkReal x904=((1.0)*pz);
IkReal x905=((0.140772144)*py);
IkReal x906=(pz*x903);
IkReal x907=(j0*x903);
IkReal x908=(px*x902);
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x909=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x910=((1.392)*x909);
evalcond[0]=((((-3.47904e-8)*py*x902))+px+(((2.44224e-8)*x902)));
evalcond[1]=((((-1.0)*x902*x904))+((j0*x902))+(((-1.0)*px*x903)));
evalcond[2]=((((-1.0)*x903*x905))+(((0.162197664)*x903))+(((-1.0)*x904))+(((-1.0)*x903*x910))+j0);
evalcond[3]=((0.719639)+(((-2.15)*py))+(((0.64)*x906))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.64)*x908))+(((-0.64)*x907)));
evalcond[4]=((-0.162197664)+(((-1.0)*x908))+(((-1.0)*x907))+x910+x905+x906);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst8=((0.789011682469823)+(((0.703860716481667)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.789011682469823)+sj3+(((-0.703860716481667)*py)))))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
IkReal x911=((0.78901168)+(((0.70386072)*py)));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x911;
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))))));
if( (x911) < -1-IKFAST_SINCOS_THRESH || (x911) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x911)))));
IkReal gconst8=((0.789011682469823)+(((0.703860716481667)*py)));
j1eval[0]=((1.0)+(((-1.42452830188679)*py)));
j1eval[1]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
j1eval[2]=IKsign(((2.44224e-8)+(((-3.47904e-8)*py))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x912=((0.78901168)+(((0.70386072)*py)));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x912;
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))))));
if( (x912) < -1-IKFAST_SINCOS_THRESH || (x912) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x912)))));
IkReal gconst8=((0.789011682469823)+(((0.703860716481667)*py)));
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
j1eval[0]=((1.15219999774955)+(((9.88831995057204)*(IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))))))+(((-1.0)*py)));
j1eval[1]=((1.0)+(((-1.42452830188679)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x913=((0.78901168)+(((0.70386072)*py)));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x913;
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))))));
if( (x913) < -1-IKFAST_SINCOS_THRESH || (x913) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x913)))));
IkReal gconst8=((0.789011682469823)+(((0.703860716481667)*py)));
IkReal x914=((1.42452830188679)*py);
j1eval[0]=(((j0*x914))+(((-1.0)*pz*x914))+pz+(((-1.0)*j0)));
j1eval[1]=((1.0)+(((-1.0)*x914)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j0))+(IKabs(pz)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x915=py*py;
IkReal x916=((0.78901168)+(((0.70386072)*py)));
IkReal x917=((-1.0)*py);
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x916;
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*x915)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*x915))))));
if( (x916) < -1-IKFAST_SINCOS_THRESH || (x916) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x916)))));
pz=0;
j0=0;
pp=((px*px)+x915);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x917);
rxp0_1=(px*r20);
rxp1_0=(r21*x917);
rxp1_1=(px*r21);
rxp2_0=(r22*x917);
rxp2_1=(px*r22);
IkReal gconst8=((0.789011682469823)+(((0.703860716481667)*py)));
j1eval[0]=((1.0)+(((-1.42452830188679)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x918=py*py;
IkReal x919=((0.78901168)+(((0.70386072)*py)));
IkReal x920=((-1.0)*py);
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x919;
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*x918)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*x918))))));
if( (x919) < -1-IKFAST_SINCOS_THRESH || (x919) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x919)))));
pz=0;
j0=0;
pp=((px*px)+x918);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x920);
rxp0_1=(px*r20);
rxp1_0=(r21*x920);
rxp1_1=(px*r21);
rxp2_0=(r22*x920);
rxp2_1=(px*r22);
IkReal gconst8=((0.789011682469823)+(((0.703860716481667)*py)));
j1eval[0]=px;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x922=IKPowWithIntegerCheck(px,-1);
if(!x922.valid){
continue;
}
IkReal x921=x922.value;
cj1array[0]=((((-1.5625)*px))+(((1.1244359375)*x921))+(((-1.5625)*x921*(py*py)))+(((-3.359375)*py*x921)));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x923=IKcos(j1);
IkReal x924=IKsin(j1);
IkReal x925=((0.140772144)*py);
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x926=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x927=((1.392)*x926);
evalcond[0]=((-1.0)*px*x924);
evalcond[1]=((((-3.47904e-8)*py*x923))+(((2.44224e-8)*x923))+px);
evalcond[2]=((-0.162197664)+(((-1.0)*x927))+x925+(((-1.0)*px*x923)));
evalcond[3]=(((x924*x927))+(((-1.0)*x924*x925))+(((0.162197664)*x924)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x928=IKPowWithIntegerCheck(((2.44224e-8)+(((-3.47904e-8)*py))),-1);
if(!x928.valid){
continue;
}
cj1array[0]=((-1.0)*px*(x928.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x929=IKcos(j1);
IkReal x930=py*py;
IkReal x931=IKsin(j1);
IkReal x932=((0.140772144)*py);
IkReal x933=(px*x929);
if((((0.377460564926139)+(((-0.495419908206086)*x930))+(((-1.11070865627123)*py)))) < -0.00001)
continue;
IkReal x934=IKsqrt(((0.377460564926139)+(((-0.495419908206086)*x930))+(((-1.11070865627123)*py))));
IkReal x935=((1.392)*x934);
evalcond[0]=((-1.0)*px*x931);
evalcond[1]=((0.719639)+(((-2.15)*py))+(((-1.0)*(px*px)))+(((-0.64)*x933))+(((-1.0)*x930)));
evalcond[2]=((-0.162197664)+(((-1.0)*x933))+x932+(((-1.0)*x935)));
evalcond[3]=((((-1.0)*x931*x932))+((x931*x935))+(((0.162197664)*x931)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x936=j0*j0;
IkReal x937=(py*pz);
IkReal x938=((8.6976e-7)*py);
CheckValue<IkReal> x939=IKPowWithIntegerCheck(((((3.907584e-7)*pz))+(((5.566464e-7)*j0*py))+(((-3.907584e-7)*j0))+(((-5.566464e-7)*x937))),-1);
if(!x939.valid){
continue;
}
CheckValue<IkReal> x940=IKPowWithIntegerCheck(((2.44224e-8)+(((-3.47904e-8)*py))),-1);
if(!x940.valid){
continue;
}
if( IKabs(((x939.value)*(((-4.3938278784e-7)+(((1.93861721664e-6)*py))+(((6.1056e-7)*pp))+(((1.73952e-6)*j0*x937))+(((-1.869984e-6)*(py*py)))+(((-16.0)*(px*px)))+(((-1.0)*x936*x938))+(((6.1056e-7)*x936))+(((-1.22112e-6)*j0*pz))+(((-1.0)*pp*x938)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x940.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x939.value)*(((-4.3938278784e-7)+(((1.93861721664e-6)*py))+(((6.1056e-7)*pp))+(((1.73952e-6)*j0*x937))+(((-1.869984e-6)*(py*py)))+(((-16.0)*(px*px)))+(((-1.0)*x936*x938))+(((6.1056e-7)*x936))+(((-1.22112e-6)*j0*pz))+(((-1.0)*pp*x938))))))+IKsqr(((-1.0)*px*(x940.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x939.value)*(((-4.3938278784e-7)+(((1.93861721664e-6)*py))+(((6.1056e-7)*pp))+(((1.73952e-6)*j0*x937))+(((-1.869984e-6)*(py*py)))+(((-16.0)*(px*px)))+(((-1.0)*x936*x938))+(((6.1056e-7)*x936))+(((-1.22112e-6)*j0*pz))+(((-1.0)*pp*x938))))), ((-1.0)*px*(x940.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x941=IKcos(j1);
IkReal x942=IKsin(j1);
IkReal x943=((1.0)*pz);
IkReal x944=((0.140772144)*py);
IkReal x945=(pz*x942);
IkReal x946=(j0*x942);
IkReal x947=(px*x941);
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x948=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x949=((1.392)*x948);
evalcond[0]=((((2.44224e-8)*x941))+px+(((-3.47904e-8)*py*x941)));
evalcond[1]=((((-1.0)*px*x942))+(((-1.0)*x941*x943))+((j0*x941)));
evalcond[2]=((((-1.0)*x943))+(((-1.0)*x942*x944))+((x942*x949))+(((0.162197664)*x942))+j0);
evalcond[3]=((0.719639)+(((-2.15)*py))+(((-0.64)*x947))+(((-0.64)*x946))+(((-1.0)*(j0*j0)))+(((0.64)*x945))+(((-1.0)*pp))+(((2.0)*j0*pz)));
evalcond[4]=((-0.162197664)+(((-1.0)*x949))+(((-1.0)*x946))+(((-1.0)*x947))+x944+x945);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x950=IKPowWithIntegerCheck(((0.162197664)+(((-0.140772144)*py))+(((1.392)*(IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))))))),-1);
if(!x950.valid){
continue;
}
CheckValue<IkReal> x951=IKPowWithIntegerCheck(((2.44224e-8)+(((-3.47904e-8)*py))),-1);
if(!x951.valid){
continue;
}
if( IKabs(((x950.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x951.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x950.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x951.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x950.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x951.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x952=IKcos(j1);
IkReal x953=IKsin(j1);
IkReal x954=((1.0)*pz);
IkReal x955=((0.140772144)*py);
IkReal x956=(pz*x953);
IkReal x957=(j0*x953);
IkReal x958=(px*x952);
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x959=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x960=((1.392)*x959);
evalcond[0]=((((2.44224e-8)*x952))+(((-3.47904e-8)*py*x952))+px);
evalcond[1]=((((-1.0)*px*x953))+(((-1.0)*x952*x954))+((j0*x952)));
evalcond[2]=((((0.162197664)*x953))+(((-1.0)*x953*x955))+(((-1.0)*x954))+j0+((x953*x960)));
evalcond[3]=((0.719639)+(((-2.15)*py))+(((-0.64)*x957))+(((-0.64)*x958))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((0.64)*x956)));
evalcond[4]=((-0.162197664)+(((-1.0)*x958))+(((-1.0)*x957))+x956+x955+(((-1.0)*x960)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x961 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x961.valid){
continue;
}
CheckValue<IkReal> x962=IKPowWithIntegerCheck(IKsign(((2.44224e-8)+(((-3.47904e-8)*py)))),-1);
if(!x962.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x961.value)+(((1.5707963267949)*(x962.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x963=IKcos(j1);
IkReal x964=IKsin(j1);
IkReal x965=((1.0)*pz);
IkReal x966=((0.140772144)*py);
IkReal x967=(pz*x964);
IkReal x968=(j0*x964);
IkReal x969=(px*x963);
if((((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py))))) < -0.00001)
continue;
IkReal x970=IKsqrt(((0.377460564926139)+(((-1.11070865627123)*py))+(((-0.495419908206086)*(py*py)))));
IkReal x971=((1.392)*x970);
evalcond[0]=((((2.44224e-8)*x963))+(((-3.47904e-8)*py*x963))+px);
evalcond[1]=((((-1.0)*x963*x965))+(((-1.0)*px*x964))+((j0*x963)));
evalcond[2]=((((-1.0)*x964*x966))+((x964*x971))+(((-1.0)*x965))+(((0.162197664)*x964))+j0);
evalcond[3]=((0.719639)+(((-2.15)*py))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((0.64)*x967))+(((-0.64)*x968))+(((-0.64)*x969)));
evalcond[4]=((-0.162197664)+(((-1.0)*x969))+(((-1.0)*x968))+x966+x967+(((-1.0)*x971)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x972=IKcos(pz);
IkReal x973=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x974=IKsqrt(((-1.0)*(px*px)));
IkReal x975=IKcos(x974);
IkReal x976=IKsin(x974);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst9=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
IkReal gconst10=(((x973*x975))+((x972*x976)));
IkReal gconst11=((((-1.0)*x973*x976))+((x972*x975)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))))+(((-1.0)*pz))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x977=IKcos(pz);
IkReal x978=IKsin(pz);
IkReal x979=x974;
IkReal x980=IKcos(x979);
IkReal x981=IKsin(x979);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x982=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj0=gconst10;
cj0=gconst11;
j0=x982;
IkReal gconst9=x982;
IkReal gconst10=(((x977*x981))+((x978*x980)));
IkReal gconst11=(((x977*x980))+(((-1.0)*x978*x981)));
j1eval[0]=IKabs(((-7.802)+(((-6.96)*py))+px+(((9.88832)*sj3))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x983=((6.96)*py);
IkReal x984=((9.88832)*sj3);
op[0]=((-7.802)+(((-1.0)*x983))+px+x984);
op[1]=0;
op[2]=((7.802)+(((-1.0)*x984))+px+x983);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x985=IKcos(pz);
IkReal x986=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x987=IKsqrt(((-1.0)*(px*px)));
IkReal x988=IKcos(x987);
IkReal x989=IKsin(x987);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst12=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
IkReal gconst13=(((x986*x988))+(((-1.0)*x985*x989)));
IkReal gconst14=(((x986*x989))+((x985*x988)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*pz))+(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x990=IKcos(pz);
IkReal x991=IKsin(pz);
IkReal x992=x987;
IkReal x993=IKcos(x992);
IkReal x994=IKsin(x992);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x995=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj0=gconst13;
cj0=gconst14;
j0=x995;
IkReal gconst12=x995;
IkReal gconst13=(((x991*x993))+(((-1.0)*x990*x994)));
IkReal gconst14=(((x991*x994))+((x990*x993)));
j1eval[0]=IKabs(((-7.802)+(((-6.96)*py))+px+(((9.88832)*sj3))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x996=((6.96)*py);
IkReal x997=((9.88832)*sj3);
op[0]=((-7.802)+(((-1.0)*x996))+px+x997);
op[1]=0;
op[2]=((7.802)+(((-1.0)*x997))+px+x996);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x998=IKPowWithIntegerCheck(((0.32)+(((-1.392)*cj3))+(((-0.2)*sj3))),-1);
if(!x998.valid){
continue;
}
CheckValue<IkReal> x999=IKPowWithIntegerCheck(((7.802)+(((-9.88832)*sj3))+(((6.96)*py))),-1);
if(!x999.valid){
continue;
}
if( IKabs(((x998.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x999.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x998.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x999.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x998.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x999.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1000=IKcos(j1);
IkReal x1001=IKsin(j1);
IkReal x1002=((1.0)*pz);
IkReal x1003=((0.2)*sj3);
IkReal x1004=((1.392)*cj3);
IkReal x1005=(pz*x1001);
IkReal x1006=(j0*x1001);
IkReal x1007=(px*x1000);
evalcond[0]=((((-1.0)*px*x1001))+((j0*x1000))+(((-1.0)*x1000*x1002)));
evalcond[1]=((((-9.88832)*sj3*x1000))+(((6.96)*py*x1000))+px+(((7.802)*x1000)));
evalcond[2]=((((-1.0)*x1002))+(((0.32)*x1001))+(((-1.0)*x1001*x1003))+(((-1.0)*x1001*x1004))+j0);
evalcond[3]=((-0.32)+(((-1.0)*x1007))+(((-1.0)*x1006))+x1005+x1004+x1003);
evalcond[4]=((0.719639)+(((-2.15)*py))+(((-1.0)*(j0*j0)))+(((-0.64)*x1007))+(((-0.64)*x1006))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((0.64)*x1005)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1008=((0.2)*sj3);
IkReal x1009=((1.392)*cj3);
CheckValue<IkReal> x1010 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x1009))+(((-1.0)*pz*x1008))+((j0*x1009))+((j0*x1008))+(((-0.32)*j0))+(((0.32)*pz)))),IkReal(((((-0.32)*px))+((px*x1008))+((px*x1009)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1010.valid){
continue;
}
CheckValue<IkReal> x1011=IKPowWithIntegerCheck(IKsign(((j0*j0)+pp+(((-1.0)*(py*py)))+(((-2.0)*j0*pz)))),-1);
if(!x1011.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1010.value)+(((1.5707963267949)*(x1011.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1012=IKcos(j1);
IkReal x1013=IKsin(j1);
IkReal x1014=((1.0)*pz);
IkReal x1015=((0.2)*sj3);
IkReal x1016=((1.392)*cj3);
IkReal x1017=(pz*x1013);
IkReal x1018=(j0*x1013);
IkReal x1019=(px*x1012);
evalcond[0]=((((-1.0)*x1012*x1014))+(((-1.0)*px*x1013))+((j0*x1012)));
evalcond[1]=((((7.802)*x1012))+(((6.96)*py*x1012))+(((-9.88832)*sj3*x1012))+px);
evalcond[2]=((((-1.0)*x1014))+(((0.32)*x1013))+(((-1.0)*x1013*x1015))+(((-1.0)*x1013*x1016))+j0);
evalcond[3]=((-0.32)+x1015+x1016+x1017+(((-1.0)*x1018))+(((-1.0)*x1019)));
evalcond[4]=((0.719639)+(((-2.15)*py))+(((0.64)*x1017))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.64)*x1019))+(((-0.64)*x1018)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1020 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1020.valid){
continue;
}
CheckValue<IkReal> x1021=IKPowWithIntegerCheck(IKsign(((7.802)+(((-9.88832)*sj3))+(((6.96)*py)))),-1);
if(!x1021.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1020.value)+(((1.5707963267949)*(x1021.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1022=IKcos(j1);
IkReal x1023=IKsin(j1);
IkReal x1024=((1.0)*pz);
IkReal x1025=((0.2)*sj3);
IkReal x1026=((1.392)*cj3);
IkReal x1027=(pz*x1023);
IkReal x1028=(j0*x1023);
IkReal x1029=(px*x1022);
evalcond[0]=(((j0*x1022))+(((-1.0)*x1022*x1024))+(((-1.0)*px*x1023)));
evalcond[1]=((((-9.88832)*sj3*x1022))+px+(((7.802)*x1022))+(((6.96)*py*x1022)));
evalcond[2]=((((-1.0)*x1023*x1025))+(((-1.0)*x1023*x1026))+(((0.32)*x1023))+(((-1.0)*x1024))+j0);
evalcond[3]=((-0.32)+x1025+x1027+x1026+(((-1.0)*x1029))+(((-1.0)*x1028)));
evalcond[4]=((0.719639)+(((-2.15)*py))+(((0.64)*x1027))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.64)*x1029))+(((-0.64)*x1028)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j1eval[0]=((9.7092)+(((-9.88832)*sj3))+(((-1.0)*py)));
j1eval[1]=IKsign(((1.395)+(((-0.14367816091954)*py))+(((-1.42073563218391)*sj3))));
j1eval[2]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x1030=((1.392)*sj3);
IkReal x1031=((0.2)*cj3);
IkReal x1032=((j0*j0)+pp+(((-1.0)*(py*py)))+(((-2.0)*j0*pz)));
j1eval[0]=x1032;
j1eval[1]=IKsign(x1032);
j1eval[2]=((((0.001)*(IKabs(((((-1395.0)*px))+(((1392.0)*px*sj3))+(((-200.0)*cj3*px)))))))+(IKabs((((j0*x1030))+(((-1.0)*pz*x1030))+(((-1.0)*j0*x1031))+(((1.395)*pz))+((pz*x1031))+(((-1.395)*j0))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j1eval[0]=((6.975)+cj3+(((-6.96)*sj3)));
j1eval[1]=((9.7092)+(((-9.88832)*sj3))+(((-1.0)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((4.44286385499897)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-646308528.390173)*pz))+(((646308528.390173)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((646308528.390173)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-646308528.390173)*pz))+(((646308528.390173)*j0))))+IKsqr(((646308528.390173)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-646308528.390173)*pz))+(((646308528.390173)*j0))), ((646308528.390173)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1033=IKcos(j1);
IkReal x1034=IKsin(j1);
IkReal x1035=((1.0)*px);
IkReal x1036=((1.0)*pz);
IkReal x1037=(j0*x1034);
IkReal x1038=(pz*x1034);
evalcond[0]=((((-1.54724865304006e-9)*x1033))+px);
evalcond[1]=((((-1.0)*x1036))+(((-1.54724865304006e-9)*x1034))+j0);
evalcond[2]=((((-1.0)*x1033*x1036))+((j0*x1033))+(((-1.0)*x1034*x1035)));
evalcond[3]=((1.54724865304006e-9)+(((-1.0)*x1033*x1035))+x1038+(((-1.0)*x1037)));
evalcond[4]=((4.31682374198177e-9)+(((-2.79)*x1037))+(((2.79)*x1038))+(((-2.79)*px*x1033)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.58667432072894)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((227272727.272727)*j0))+(((-227272727.272727)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((227272727.272727)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((227272727.272727)*j0))+(((-227272727.272727)*pz))))+IKsqr(((227272727.272727)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((227272727.272727)*j0))+(((-227272727.272727)*pz))), ((227272727.272727)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1039=IKcos(j1);
IkReal x1040=IKsin(j1);
IkReal x1041=((1.0)*px);
IkReal x1042=((1.0)*pz);
IkReal x1043=((2.79)*x1040);
evalcond[0]=(px+(((-4.4e-9)*x1039)));
evalcond[1]=((((-4.4e-9)*x1040))+(((-1.0)*x1042))+j0);
evalcond[2]=(((j0*x1039))+(((-1.0)*x1039*x1042))+(((-1.0)*x1040*x1041)));
evalcond[3]=((4.4e-9)+(((-1.0)*j0*x1040))+(((-1.0)*x1039*x1041))+((pz*x1040)));
evalcond[4]=((1.2276e-8)+((pz*x1043))+(((-1.0)*j0*x1043))+(((-2.79)*px*x1039)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst16=((0.981885699491926)+(((-0.101129413287596)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.981885699491926)+sj3+(((0.101129413287596)*py)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-394150434.875445)*pz))+(((394150434.875445)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((394150434.875445)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-394150434.875445)*pz))+(((394150434.875445)*j0))))+IKsqr(((394150434.875445)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-394150434.875445)*pz))+(((394150434.875445)*j0))), ((394150434.875445)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1044=IKcos(j1);
IkReal x1045=IKsin(j1);
IkReal x1046=((1.0)*px);
IkReal x1047=((1.0)*pz);
IkReal x1048=((0.140772143296333)*py);
IkReal x1049=(j0*x1045);
IkReal x1050=(pz*x1045);
if((((0.0359004731332515)+(((-0.0102271582318934)*(py*py)))+(((0.198595049410198)*py)))) < -0.00001)
continue;
IkReal x1051=IKsqrt(((0.0359004731332515)+(((-0.0102271582318934)*(py*py)))+(((0.198595049410198)*py))));
IkReal x1052=((0.2)*x1051);
evalcond[0]=(px+(((-2.53710236376121e-9)*x1044)));
evalcond[1]=((((-1.0)*x1044*x1047))+(((-1.0)*x1045*x1046))+((j0*x1044)));
evalcond[2]=((0.031639)+(((-2.79)*px*x1044))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((2.79)*x1050))+(((-2.79)*x1049)));
evalcond[3]=((((0.028215103821452)*x1045))+((x1045*x1048))+((x1045*x1052))+(((-1.0)*x1047))+j0);
evalcond[4]=((-0.028215103821452)+(((-1.0)*x1052))+x1050+(((-1.0)*x1044*x1046))+(((-1.0)*x1049))+(((-1.0)*x1048)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst16=((0.981885699491926)+(((-0.101129413287596)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.981885699491926)+sj3+(((0.101129413287596)*py)))))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-394150434.875445)*pz))+(((394150434.875445)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((394150434.875445)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-394150434.875445)*pz))+(((394150434.875445)*j0))))+IKsqr(((394150434.875445)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-394150434.875445)*pz))+(((394150434.875445)*j0))), ((394150434.875445)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1053=IKcos(j1);
IkReal x1054=IKsin(j1);
IkReal x1055=((1.0)*px);
IkReal x1056=((1.0)*pz);
IkReal x1057=((0.140772143296333)*py);
IkReal x1058=(j0*x1054);
IkReal x1059=(pz*x1054);
if((((0.0359004731332515)+(((-0.0102271582318934)*(py*py)))+(((0.198595049410198)*py)))) < -0.00001)
continue;
IkReal x1060=IKsqrt(((0.0359004731332515)+(((-0.0102271582318934)*(py*py)))+(((0.198595049410198)*py))));
IkReal x1061=((0.2)*x1060);
evalcond[0]=(px+(((-2.53710236376121e-9)*x1053)));
evalcond[1]=((((-1.0)*x1054*x1055))+((j0*x1053))+(((-1.0)*x1053*x1056)));
evalcond[2]=((0.031639)+(((-2.79)*px*x1053))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((2.79)*x1059))+(((-2.79)*x1058)));
evalcond[3]=((((-1.0)*x1056))+((x1054*x1057))+(((-1.0)*x1054*x1061))+(((0.028215103821452)*x1054))+j0);
evalcond[4]=((-0.028215103821452)+(((-1.0)*x1057))+x1059+x1061+(((-1.0)*x1058))+(((-1.0)*x1053*x1055)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1062=IKcos(pz);
IkReal x1063=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x1064=IKsqrt(((-1.0)*(px*px)));
IkReal x1065=IKcos(x1064);
IkReal x1066=IKsin(x1064);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst17=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
IkReal gconst18=(((x1062*x1066))+((x1063*x1065)));
IkReal gconst19=(((x1062*x1065))+(((-1.0)*x1063*x1066)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))))+(((-1.0)*pz))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x1067=IKcos(pz);
IkReal x1068=IKsin(pz);
IkReal x1069=x1064;
IkReal x1070=IKcos(x1069);
IkReal x1071=IKsin(x1069);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x1072=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj0=gconst18;
cj0=gconst19;
j0=x1072;
IkReal gconst17=x1072;
IkReal gconst18=(((x1068*x1070))+((x1067*x1071)));
IkReal gconst19=(((x1067*x1070))+(((-1.0)*x1068*x1071)));
j1eval[0]=IKabs(((-9.7092)+py+(((6.96)*px))+(((9.88832)*sj3))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1073=((6.96)*px);
IkReal x1074=((9.88832)*sj3);
op[0]=((-9.7092)+x1074+x1073+py);
op[1]=0;
op[2]=((9.7092)+x1073+(((-1.0)*py))+(((-1.0)*x1074)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1075=IKcos(pz);
IkReal x1076=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x1077=IKsqrt(((-1.0)*(px*px)));
IkReal x1078=IKcos(x1077);
IkReal x1079=IKsin(x1077);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst20=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
IkReal gconst21=(((x1076*x1078))+(((-1.0)*x1075*x1079)));
IkReal gconst22=(((x1075*x1078))+((x1076*x1079)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*pz))+(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x1080=IKcos(pz);
IkReal x1081=IKsin(pz);
IkReal x1082=x1077;
IkReal x1083=IKcos(x1082);
IkReal x1084=IKsin(x1082);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x1085=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj0=gconst21;
cj0=gconst22;
j0=x1085;
IkReal gconst20=x1085;
IkReal gconst21=(((x1081*x1083))+(((-1.0)*x1080*x1084)));
IkReal gconst22=(((x1081*x1084))+((x1080*x1083)));
j1eval[0]=IKabs(((-9.7092)+py+(((6.96)*px))+(((9.88832)*sj3))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1086=((6.96)*px);
IkReal x1087=((9.88832)*sj3);
op[0]=((-9.7092)+x1087+x1086+py);
op[1]=0;
op[2]=((9.7092)+x1086+(((-1.0)*py))+(((-1.0)*x1087)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1088=IKPowWithIntegerCheck(((1.395)+(((0.2)*cj3))+(((-1.392)*sj3))),-1);
if(!x1088.valid){
continue;
}
CheckValue<IkReal> x1089=IKPowWithIntegerCheck(((1.395)+(((-0.14367816091954)*py))+(((-1.42073563218391)*sj3))),-1);
if(!x1089.valid){
continue;
}
if( IKabs(((x1088.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x1089.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1088.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x1089.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x1088.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x1089.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1090=IKcos(j1);
IkReal x1091=IKsin(j1);
IkReal x1092=((0.2)*cj3);
IkReal x1093=((1.0)*px);
IkReal x1094=((1.392)*sj3);
IkReal x1095=((1.0)*pz);
IkReal x1096=(pz*x1091);
IkReal x1097=(j0*x1091);
evalcond[0]=((((-1.0)*x1091*x1093))+(((-1.0)*x1090*x1095))+((j0*x1090)));
evalcond[1]=((((-1.42073563218391)*sj3*x1090))+px+(((1.395)*x1090))+(((-0.14367816091954)*py*x1090)));
evalcond[2]=((((-1.0)*x1091*x1094))+(((-1.0)*x1095))+(((1.395)*x1091))+((x1091*x1092))+j0);
evalcond[3]=((-1.395)+x1094+x1096+(((-1.0)*x1090*x1093))+(((-1.0)*x1092))+(((-1.0)*x1097)));
evalcond[4]=((0.031639)+(((-2.79)*x1097))+(((-1.0)*(j0*j0)))+(((-2.79)*px*x1090))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((2.79)*x1096)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1098=((1.392)*sj3);
IkReal x1099=((0.2)*cj3);
CheckValue<IkReal> x1100 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x1098))+((j0*x1098))+(((1.395)*pz))+((pz*x1099))+(((-1.0)*j0*x1099))+(((-1.395)*j0)))),IkReal(((((-1.395)*px))+((px*x1098))+(((-1.0)*px*x1099)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1100.valid){
continue;
}
CheckValue<IkReal> x1101=IKPowWithIntegerCheck(IKsign(((j0*j0)+pp+(((-1.0)*(py*py)))+(((-2.0)*j0*pz)))),-1);
if(!x1101.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1100.value)+(((1.5707963267949)*(x1101.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1102=IKcos(j1);
IkReal x1103=IKsin(j1);
IkReal x1104=((0.2)*cj3);
IkReal x1105=((1.0)*px);
IkReal x1106=((1.392)*sj3);
IkReal x1107=((1.0)*pz);
IkReal x1108=(pz*x1103);
IkReal x1109=(j0*x1103);
evalcond[0]=((((-1.0)*x1103*x1105))+((j0*x1102))+(((-1.0)*x1102*x1107)));
evalcond[1]=((((-0.14367816091954)*py*x1102))+(((-1.42073563218391)*sj3*x1102))+(((1.395)*x1102))+px);
evalcond[2]=((((-1.0)*x1103*x1106))+(((1.395)*x1103))+(((-1.0)*x1107))+((x1103*x1104))+j0);
evalcond[3]=((-1.395)+x1106+x1108+(((-1.0)*x1109))+(((-1.0)*x1104))+(((-1.0)*x1102*x1105)));
evalcond[4]=((0.031639)+(((-2.79)*px*x1102))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((2.79)*x1108))+(((-2.79)*x1109)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1110=IKPowWithIntegerCheck(IKsign(((1.395)+(((-0.14367816091954)*py))+(((-1.42073563218391)*sj3)))),-1);
if(!x1110.valid){
continue;
}
CheckValue<IkReal> x1111 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1111.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1110.value)))+(x1111.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1112=IKcos(j1);
IkReal x1113=IKsin(j1);
IkReal x1114=((0.2)*cj3);
IkReal x1115=((1.0)*px);
IkReal x1116=((1.392)*sj3);
IkReal x1117=((1.0)*pz);
IkReal x1118=(pz*x1113);
IkReal x1119=(j0*x1113);
evalcond[0]=((((-1.0)*x1112*x1117))+(((-1.0)*x1113*x1115))+((j0*x1112)));
evalcond[1]=((((-0.14367816091954)*py*x1112))+(((-1.42073563218391)*sj3*x1112))+(((1.395)*x1112))+px);
evalcond[2]=(((x1113*x1114))+(((1.395)*x1113))+(((-1.0)*x1113*x1116))+(((-1.0)*x1117))+j0);
evalcond[3]=((-1.395)+x1116+x1118+(((-1.0)*x1119))+(((-1.0)*x1112*x1115))+(((-1.0)*x1114)));
evalcond[4]=((0.031639)+(((-2.79)*x1119))+(((-2.79)*px*x1112))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((2.79)*x1118)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j1eval[0]=((-5.2548)+(((-1.0)*py))+(((9.88832)*sj3)));
j1eval[1]=IKsign(((-0.755)+(((1.42073563218391)*sj3))+(((-0.14367816091954)*py))));
j1eval[2]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
IkReal x1120=((1.392)*sj3);
IkReal x1121=((0.2)*cj3);
IkReal x1122=((((-1.0)*(j0*j0)))+(py*py)+(((-1.0)*pp))+(((2.0)*j0*pz)));
j1eval[0]=x1122;
j1eval[1]=((IKabs(((((-0.755)*j0))+(((-1.0)*j0*x1121))+((pz*x1121))+(((-1.0)*pz*x1120))+(((0.755)*pz))+((j0*x1120)))))+(((0.001)*(IKabs(((((1392.0)*px*sj3))+(((-755.0)*px))+(((-200.0)*cj3*px))))))));
j1eval[2]=IKsign(x1122);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j1eval[0]=((-3.775)+(((6.96)*sj3))+(((-1.0)*cj3)));
j1eval[1]=((-5.2548)+(((-1.0)*py))+(((9.88832)*sj3)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.709426554693705)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((149110506.751359)*j0))+(((-149110506.751359)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((149110506.751359)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((149110506.751359)*j0))+(((-149110506.751359)*pz))))+IKsqr(((149110506.751359)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((149110506.751359)*j0))+(((-149110506.751359)*pz))), ((149110506.751359)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1123=IKcos(j1);
IkReal x1124=IKsin(j1);
IkReal x1125=((1.0)*pz);
IkReal x1126=(px*x1123);
IkReal x1127=((1.0)*x1124);
IkReal x1128=((1.51)*x1124);
evalcond[0]=((((-6.70643552749435e-9)*x1123))+px);
evalcond[1]=((((-6.70643552749435e-9)*x1124))+(((-1.0)*x1125))+j0);
evalcond[2]=((((-1.0)*x1123*x1125))+((j0*x1123))+(((-1.0)*px*x1127)));
evalcond[3]=((-6.70643552749435e-9)+x1126+((j0*x1124))+(((-1.0)*x1124*x1125)));
evalcond[4]=((-1.01267176465165e-8)+(((1.51)*x1126))+(((-1.0)*pz*x1128))+((j0*x1128)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-2.71756921821585)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((208333333.333333)*pz))+(((-208333333.333333)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-208333333.333333)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((208333333.333333)*pz))+(((-208333333.333333)*j0))))+IKsqr(((-208333333.333333)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((208333333.333333)*pz))+(((-208333333.333333)*j0))), ((-208333333.333333)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1129=IKcos(j1);
IkReal x1130=IKsin(j1);
IkReal x1131=((1.0)*pz);
IkReal x1132=(px*x1129);
IkReal x1133=((1.0)*x1130);
IkReal x1134=((1.51)*x1130);
evalcond[0]=((((4.8e-9)*x1129))+px);
evalcond[1]=((((4.8e-9)*x1130))+(((-1.0)*x1131))+j0);
evalcond[2]=(((j0*x1129))+(((-1.0)*px*x1133))+(((-1.0)*x1129*x1131)));
evalcond[3]=((4.8e-9)+x1132+(((-1.0)*x1130*x1131))+((j0*x1130)));
evalcond[4]=((7.248e-9)+(((1.51)*x1132))+(((-1.0)*pz*x1134))+((j0*x1134)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst24=((0.531414840943659)+(((0.101129413287596)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.531414840943659)+sj3+(((-0.101129413287596)*py)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((3324140250.76142)*j0))+(((-3324140250.76142)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((3324140250.76142)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3324140250.76142)*j0))+(((-3324140250.76142)*pz))))+IKsqr(((3324140250.76142)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((3324140250.76142)*j0))+(((-3324140250.76142)*pz))), ((3324140250.76142)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1135=IKcos(j1);
IkReal x1136=IKsin(j1);
IkReal x1137=((1.0)*pz);
IkReal x1138=((0.140772143296333)*py);
IkReal x1139=(px*x1135);
IkReal x1140=((1.0)*x1136);
IkReal x1141=((1.51)*x1136);
if((((0.717598266824826)+(((-0.0102271582318934)*(py*py)))+(((-0.107483342153907)*py)))) < -0.00001)
continue;
IkReal x1142=IKsqrt(((0.717598266824826)+(((-0.0102271582318934)*(py*py)))+(((-0.107483342153907)*py))));
IkReal x1143=((0.2)*x1142);
evalcond[0]=(px+(((-3.00829665586746e-10)*x1135)));
evalcond[1]=((((-1.0)*px*x1140))+((j0*x1135))+(((-1.0)*x1135*x1137)));
evalcond[2]=((1.407639)+(((1.51)*x1139))+((j0*x1141))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-1.0)*pz*x1141)));
evalcond[3]=((((-1.0)*x1136*x1143))+((x1136*x1138))+(((-0.0152705417011721)*x1136))+(((-1.0)*x1137))+j0);
evalcond[4]=((-0.0152705417011721)+x1139+x1138+(((-1.0)*x1143))+((j0*x1136))+(((-1.0)*x1136*x1137)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst24=((0.531414840943659)+(((0.101129413287596)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.531414840943659)+sj3+(((-0.101129413287596)*py)))))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((3324140250.76142)*j0))+(((-3324140250.76142)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((3324140250.76142)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3324140250.76142)*j0))+(((-3324140250.76142)*pz))))+IKsqr(((3324140250.76142)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((3324140250.76142)*j0))+(((-3324140250.76142)*pz))), ((3324140250.76142)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1144=IKcos(j1);
IkReal x1145=IKsin(j1);
IkReal x1146=((1.0)*pz);
IkReal x1147=((0.140772143296333)*py);
IkReal x1148=(px*x1144);
IkReal x1149=((1.0)*x1145);
IkReal x1150=((1.51)*x1145);
if((((0.717598266824826)+(((-0.0102271582318934)*(py*py)))+(((-0.107483342153907)*py)))) < -0.00001)
continue;
IkReal x1151=IKsqrt(((0.717598266824826)+(((-0.0102271582318934)*(py*py)))+(((-0.107483342153907)*py))));
IkReal x1152=((0.2)*x1151);
evalcond[0]=((((-3.00829665586746e-10)*x1144))+px);
evalcond[1]=((((-1.0)*px*x1149))+((j0*x1144))+(((-1.0)*x1144*x1146)));
evalcond[2]=((1.407639)+(((-1.0)*(j0*j0)))+((j0*x1150))+(((-1.0)*pp))+(((1.51)*x1148))+(((2.0)*j0*pz))+(((-1.0)*pz*x1150)));
evalcond[3]=(((x1145*x1147))+(((-0.0152705417011721)*x1145))+(((-1.0)*x1146))+((x1145*x1152))+j0);
evalcond[4]=((-0.0152705417011721)+(((-1.0)*x1145*x1146))+x1147+x1148+x1152+((j0*x1145)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1153=IKcos(pz);
IkReal x1154=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x1155=IKsqrt(((-1.0)*(px*px)));
IkReal x1156=IKcos(x1155);
IkReal x1157=IKsin(x1155);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst25=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
IkReal gconst26=(((x1153*x1157))+((x1154*x1156)));
IkReal gconst27=((((-1.0)*x1154*x1157))+((x1153*x1156)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))))+(((-1.0)*pz))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x1158=IKcos(pz);
IkReal x1159=IKsin(pz);
IkReal x1160=x1155;
IkReal x1161=IKcos(x1160);
IkReal x1162=IKsin(x1160);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x1163=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
sj0=gconst26;
cj0=gconst27;
j0=x1163;
IkReal gconst25=x1163;
IkReal gconst26=(((x1159*x1161))+((x1158*x1162)));
IkReal gconst27=((((-1.0)*x1159*x1162))+((x1158*x1161)));
j1eval[0]=IKabs(((5.2548)+(((-9.88832)*sj3))+py+(((6.96)*px))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1164=((6.96)*px);
IkReal x1165=((9.88832)*sj3);
op[0]=((5.2548)+x1164+py+(((-1.0)*x1165)));
op[1]=0;
op[2]=((-5.2548)+x1164+x1165+(((-1.0)*py)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1166=IKcos(pz);
IkReal x1167=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x1168=IKsqrt(((-1.0)*(px*px)));
IkReal x1169=IKcos(x1168);
IkReal x1170=IKsin(x1168);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst28=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
IkReal gconst29=((((-1.0)*x1166*x1170))+((x1167*x1169)));
IkReal gconst30=(((x1166*x1169))+((x1167*x1170)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*pz))+(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x1171=IKcos(pz);
IkReal x1172=IKsin(pz);
IkReal x1173=x1168;
IkReal x1174=IKcos(x1173);
IkReal x1175=IKsin(x1173);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x1176=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
sj0=gconst29;
cj0=gconst30;
j0=x1176;
IkReal gconst28=x1176;
IkReal gconst29=(((x1172*x1174))+(((-1.0)*x1171*x1175)));
IkReal gconst30=(((x1172*x1175))+((x1171*x1174)));
j1eval[0]=IKabs(((5.2548)+(((-9.88832)*sj3))+py+(((6.96)*px))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1177=((6.96)*px);
IkReal x1178=((9.88832)*sj3);
op[0]=((5.2548)+x1177+py+(((-1.0)*x1178)));
op[1]=0;
op[2]=((-5.2548)+x1177+x1178+(((-1.0)*py)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1179=IKPowWithIntegerCheck(((-0.755)+(((-0.2)*cj3))+(((1.392)*sj3))),-1);
if(!x1179.valid){
continue;
}
CheckValue<IkReal> x1180=IKPowWithIntegerCheck(((-0.755)+(((1.42073563218391)*sj3))+(((-0.14367816091954)*py))),-1);
if(!x1180.valid){
continue;
}
if( IKabs(((x1179.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x1180.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1179.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x1180.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x1179.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x1180.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1181=IKcos(j1);
IkReal x1182=IKsin(j1);
IkReal x1183=((0.2)*cj3);
IkReal x1184=((1.392)*sj3);
IkReal x1185=((1.0)*pz);
IkReal x1186=((1.0)*x1182);
IkReal x1187=((1.51)*x1182);
IkReal x1188=(px*x1181);
evalcond[0]=((((-1.0)*x1181*x1185))+((j0*x1181))+(((-1.0)*px*x1186)));
evalcond[1]=((((-0.14367816091954)*py*x1181))+(((-0.755)*x1181))+px+(((1.42073563218391)*sj3*x1181)));
evalcond[2]=((((-0.755)*x1182))+((x1182*x1184))+(((-1.0)*x1185))+(((-1.0)*x1182*x1183))+j0);
evalcond[3]=((-0.755)+x1188+x1184+(((-1.0)*x1183))+(((-1.0)*x1182*x1185))+((j0*x1182)));
evalcond[4]=((1.407639)+(((-1.0)*pz*x1187))+(((-1.0)*(j0*j0)))+(((1.51)*x1188))+(((-1.0)*pp))+(((2.0)*j0*pz))+((j0*x1187)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1189=((1.392)*sj3);
IkReal x1190=((0.2)*cj3);
CheckValue<IkReal> x1191=IKPowWithIntegerCheck(IKsign(((((-1.0)*(j0*j0)))+(py*py)+(((-1.0)*pp))+(((2.0)*j0*pz)))),-1);
if(!x1191.valid){
continue;
}
CheckValue<IkReal> x1192 = IKatan2WithCheck(IkReal(((((-0.755)*j0))+(((-1.0)*j0*x1190))+(((-1.0)*pz*x1189))+((pz*x1190))+(((0.755)*pz))+((j0*x1189)))),IkReal((((px*x1189))+(((-0.755)*px))+(((-1.0)*px*x1190)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1192.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1191.value)))+(x1192.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1193=IKcos(j1);
IkReal x1194=IKsin(j1);
IkReal x1195=((0.2)*cj3);
IkReal x1196=((1.392)*sj3);
IkReal x1197=((1.0)*pz);
IkReal x1198=((1.0)*x1194);
IkReal x1199=((1.51)*x1194);
IkReal x1200=(px*x1193);
evalcond[0]=((((-1.0)*x1193*x1197))+((j0*x1193))+(((-1.0)*px*x1198)));
evalcond[1]=((((-0.14367816091954)*py*x1193))+(((-0.755)*x1193))+px+(((1.42073563218391)*sj3*x1193)));
evalcond[2]=(((x1194*x1196))+(((-0.755)*x1194))+(((-1.0)*x1194*x1195))+(((-1.0)*x1197))+j0);
evalcond[3]=((-0.755)+x1196+x1200+(((-1.0)*x1194*x1197))+(((-1.0)*x1195))+((j0*x1194)));
evalcond[4]=((1.407639)+(((1.51)*x1200))+(((-1.0)*pz*x1199))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+((j0*x1199)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1201 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1201.valid){
continue;
}
CheckValue<IkReal> x1202=IKPowWithIntegerCheck(IKsign(((-0.755)+(((1.42073563218391)*sj3))+(((-0.14367816091954)*py)))),-1);
if(!x1202.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1201.value)+(((1.5707963267949)*(x1202.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1203=IKcos(j1);
IkReal x1204=IKsin(j1);
IkReal x1205=((0.2)*cj3);
IkReal x1206=((1.392)*sj3);
IkReal x1207=((1.0)*pz);
IkReal x1208=((1.0)*x1204);
IkReal x1209=((1.51)*x1204);
IkReal x1210=(px*x1203);
evalcond[0]=(((j0*x1203))+(((-1.0)*x1203*x1207))+(((-1.0)*px*x1208)));
evalcond[1]=((((1.42073563218391)*sj3*x1203))+(((-0.755)*x1203))+px+(((-0.14367816091954)*py*x1203)));
evalcond[2]=(((x1204*x1206))+(((-1.0)*x1204*x1205))+(((-0.755)*x1204))+(((-1.0)*x1207))+j0);
evalcond[3]=((-0.755)+(((-1.0)*x1204*x1207))+x1206+x1210+((j0*x1204))+(((-1.0)*x1205)));
evalcond[4]=((1.407639)+(((-1.0)*pz*x1209))+(((-1.0)*(j0*j0)))+((j0*x1209))+(((-1.0)*pp))+(((1.51)*x1210))+(((2.0)*j0*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1211=(pz*sj2);
IkReal x1212=(cj2*py);
IkReal x1213=((1.392)*sj3);
IkReal x1214=((0.32)*sj2);
IkReal x1215=((0.2)*cj3);
CheckValue<IkReal> x1216 = IKatan2WithCheck(IkReal(((((1.075)*pz))+(((-1.0)*pz*x1212))+((j0*x1212))+((j0*x1213))+(((-1.0)*j0*x1214))+(((-1.0)*j0*x1215))+(((-1.075)*j0))+(((0.32)*x1211))+((pz*x1215))+(((-1.0)*pz*x1213)))),IkReal((((px*x1213))+((px*x1212))+(((-1.0)*px*x1215))+(((-1.0)*px*x1214))+(((-1.075)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1216.valid){
continue;
}
CheckValue<IkReal> x1217=IKPowWithIntegerCheck(IKsign(((((-2.0)*j0*x1211))+(((-1.0)*sj2*(py*py)))+((sj2*(j0*j0)))+((pp*sj2)))),-1);
if(!x1217.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1216.value)+(((1.5707963267949)*(x1217.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1218=IKcos(j1);
IkReal x1219=IKsin(j1);
IkReal x1220=((0.2)*cj3);
IkReal x1221=((1.0)*pz);
IkReal x1222=((2.15)*sj2);
IkReal x1223=(cj2*py);
IkReal x1224=((1.392)*sj3);
IkReal x1225=((1.0)*sj2);
IkReal x1226=((1.392)*cj3);
IkReal x1227=(pz*x1219);
IkReal x1228=(j0*x1219);
IkReal x1229=(px*x1218);
IkReal x1230=(sj2*x1218);
IkReal x1231=(sj2*x1219);
IkReal x1232=((0.2)*cj2*sj3);
evalcond[0]=(((j0*x1218))+(((-1.0)*x1218*x1221))+(((-1.0)*px*x1219)));
evalcond[1]=(((cj2*x1229))+((cj2*x1228))+x1226+(((-1.0)*cj2*x1219*x1221))+(((0.32)*cj2))+((py*sj2))+(((0.2)*sj3)));
evalcond[2]=((-1.075)+x1224+x1223+((sj2*x1227))+(((-1.0)*x1225*x1228))+(((-1.0)*x1225*x1229))+(((-1.0)*x1220))+(((-0.32)*sj2)));
evalcond[3]=((((-1.0)*x1224*x1230))+((x1220*x1230))+px+((x1218*x1232))+(((1.075)*x1230))+(((0.32)*x1218))+((cj2*x1218*x1226)));
evalcond[4]=(((x1219*x1232))+(((-1.0)*x1221))+(((-1.0)*x1224*x1231))+((x1220*x1231))+((cj2*x1219*x1226))+(((1.075)*x1231))+(((0.32)*x1219))+j0);
evalcond[5]=((0.719639)+(((-0.688)*sj2))+(((-1.0)*(j0*j0)))+(((-1.0)*x1222*x1229))+(((-1.0)*x1222*x1228))+(((-1.0)*pp))+(((2.0)*j0*pz))+((x1222*x1227))+(((0.64)*x1227))+(((-0.64)*x1229))+(((-0.64)*x1228))+(((2.15)*x1223)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1233=((0.32)*cj2);
IkReal x1234=(py*sj2);
IkReal x1235=((1.0)*cj2);
IkReal x1236=((0.2)*sj3);
IkReal x1237=((1.392)*cj3);
CheckValue<IkReal> x1238=IKPowWithIntegerCheck(IKsign(((((2.0)*cj2*j0*pz))+(((-1.0)*pp*x1235))+((cj2*(py*py)))+(((-1.0)*x1235*(j0*j0))))),-1);
if(!x1238.valid){
continue;
}
CheckValue<IkReal> x1239 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x1233))+(((-1.0)*pz*x1237))+(((-1.0)*pz*x1236))+(((-1.0)*pz*x1234))+((j0*x1234))+((j0*x1233))+((j0*x1236))+((j0*x1237)))),IkReal((((px*x1234))+((px*x1237))+((px*x1236))+((px*x1233)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1239.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1238.value)))+(x1239.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1240=IKcos(j1);
IkReal x1241=IKsin(j1);
IkReal x1242=((0.2)*cj3);
IkReal x1243=((1.0)*pz);
IkReal x1244=((2.15)*sj2);
IkReal x1245=(cj2*py);
IkReal x1246=((1.392)*sj3);
IkReal x1247=((1.0)*sj2);
IkReal x1248=((1.392)*cj3);
IkReal x1249=(pz*x1241);
IkReal x1250=(j0*x1241);
IkReal x1251=(px*x1240);
IkReal x1252=(sj2*x1240);
IkReal x1253=(sj2*x1241);
IkReal x1254=((0.2)*cj2*sj3);
evalcond[0]=((((-1.0)*px*x1241))+((j0*x1240))+(((-1.0)*x1240*x1243)));
evalcond[1]=(x1248+(((-1.0)*cj2*x1241*x1243))+((cj2*x1251))+((cj2*x1250))+(((0.32)*cj2))+((py*sj2))+(((0.2)*sj3)));
evalcond[2]=((-1.075)+x1245+x1246+((sj2*x1249))+(((-1.0)*x1247*x1251))+(((-1.0)*x1247*x1250))+(((-1.0)*x1242))+(((-0.32)*sj2)));
evalcond[3]=((((1.075)*x1252))+(((0.32)*x1240))+((cj2*x1240*x1248))+(((-1.0)*x1246*x1252))+px+((x1240*x1254))+((x1242*x1252)));
evalcond[4]=((((1.075)*x1253))+((x1241*x1254))+((cj2*x1241*x1248))+(((0.32)*x1241))+(((-1.0)*x1246*x1253))+(((-1.0)*x1243))+j0+((x1242*x1253)));
evalcond[5]=((0.719639)+(((-0.688)*sj2))+(((2.15)*x1245))+(((-1.0)*(j0*j0)))+(((-0.64)*x1251))+(((-0.64)*x1250))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-1.0)*x1244*x1250))+(((-1.0)*x1244*x1251))+(((0.64)*x1249))+((x1244*x1249)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1255=IKPowWithIntegerCheck(IKsign(((0.32)+(((0.2)*cj3*sj2))+(((1.075)*sj2))+(((0.2)*cj2*sj3))+(((1.392)*cj2*cj3))+(((-1.392)*sj2*sj3)))),-1);
if(!x1255.valid){
continue;
}
CheckValue<IkReal> x1256 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1256.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1255.value)))+(x1256.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1257=IKcos(j1);
IkReal x1258=IKsin(j1);
IkReal x1259=((0.2)*cj3);
IkReal x1260=((1.0)*pz);
IkReal x1261=((2.15)*sj2);
IkReal x1262=(cj2*py);
IkReal x1263=((1.392)*sj3);
IkReal x1264=((1.0)*sj2);
IkReal x1265=((1.392)*cj3);
IkReal x1266=(pz*x1258);
IkReal x1267=(j0*x1258);
IkReal x1268=(px*x1257);
IkReal x1269=(sj2*x1257);
IkReal x1270=(sj2*x1258);
IkReal x1271=((0.2)*cj2*sj3);
evalcond[0]=((((-1.0)*px*x1258))+(((-1.0)*x1257*x1260))+((j0*x1257)));
evalcond[1]=(x1265+((cj2*x1268))+((cj2*x1267))+(((0.32)*cj2))+((py*sj2))+(((0.2)*sj3))+(((-1.0)*cj2*x1258*x1260)));
evalcond[2]=((-1.075)+(((-1.0)*x1259))+(((-1.0)*x1264*x1267))+(((-1.0)*x1264*x1268))+x1263+x1262+(((-0.32)*sj2))+((sj2*x1266)));
evalcond[3]=((((1.075)*x1269))+(((-1.0)*x1263*x1269))+((x1259*x1269))+((x1257*x1271))+px+((cj2*x1257*x1265))+(((0.32)*x1257)));
evalcond[4]=(((cj2*x1258*x1265))+(((1.075)*x1270))+((x1259*x1270))+((x1258*x1271))+(((-1.0)*x1263*x1270))+(((0.32)*x1258))+j0+(((-1.0)*x1260)));
evalcond[5]=((0.719639)+(((-1.0)*x1261*x1267))+(((-1.0)*x1261*x1268))+(((-0.688)*sj2))+(((0.64)*x1266))+((x1261*x1266))+(((-1.0)*(j0*j0)))+(((-0.64)*x1267))+(((-0.64)*x1268))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((2.15)*x1262)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x82=((1.0)*cj1);
IkReal x83=((1.0)*cj2);
IkReal x84=(r20*sj1);
IkReal x85=(sj2*sj3);
IkReal x86=(r22*sj1);
IkReal x87=(r21*sj1);
IkReal x88=(x85+(((-1.0)*cj3*x83)));
IkReal x89=(((cj2*cj3))+(((-1.0)*x85)));
IkReal x90=((((-1.0)*sj3*x83))+(((-1.0)*cj3*sj2)));
IkReal x91=(x82*x90);
new_r00=(((r10*x88))+(((-1.0)*r00*x91))+((x84*x90)));
new_r01=(((x87*x90))+((r11*x88))+(((-1.0)*r01*x91)));
new_r02=(((r12*x88))+((x86*x90))+(((-1.0)*r02*x91)));
new_r10=(((r00*sj1))+((cj1*r20)));
new_r11=(((r01*sj1))+((cj1*r21)));
new_r12=(((r02*sj1))+((cj1*r22)));
new_r20=(((x84*x89))+(((-1.0)*r00*x82*x89))+((r10*x90)));
new_r21=(((r11*x90))+(((-1.0)*r01*x82*x89))+((x87*x89)));
new_r22=(((r12*x90))+((x86*x89))+(((-1.0)*r02*x82*x89)));
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=new_r22;
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j4eval[3];
j4eval[0]=sj5;
j4eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j4eval[2]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=new_r12;
j4eval[1]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j6mul = 1;
j6=0;
j4mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].fmul = j6mul;
vinfos[6].freeind = 0;
vinfos[6].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 6;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j6mul = 1;
j6=0;
j4mul=1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].fmul = j6mul;
vinfos[6].freeind = 0;
vinfos[6].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 6;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x92=new_r22*new_r22;
IkReal x93=((16.0)*new_r10);
IkReal x94=((16.0)*new_r01);
IkReal x95=((16.0)*new_r22);
IkReal x96=((8.0)*new_r11);
IkReal x97=((8.0)*new_r00);
IkReal x98=(x92*x93);
IkReal x99=(x92*x94);
j4eval[0]=((IKabs((x94+(((-1.0)*x99)))))+(IKabs(((((16.0)*new_r00))+((new_r11*x95))+(((-32.0)*new_r00*x92)))))+(IKabs((x99+(((-1.0)*x94)))))+(IKabs(((((32.0)*new_r11))+(((-16.0)*new_r11*x92))+(((-1.0)*new_r00*x95)))))+(IKabs((((new_r22*x96))+(((-1.0)*x97)))))+(IKabs((x98+(((-1.0)*x93)))))+(IKabs((x93+(((-1.0)*x98)))))+(IKabs((((x92*x96))+(((-1.0)*new_r22*x97))))));
if( IKabs(j4eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j4, j6]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j4evalpoly[1];
IkReal x100=new_r22*new_r22;
IkReal x101=((16.0)*new_r10);
IkReal x102=(new_r11*new_r22);
IkReal x103=(x100*x101);
IkReal x104=((((8.0)*x102))+(((-8.0)*new_r00)));
op[0]=x104;
op[1]=((((-1.0)*x103))+x101);
op[2]=((((16.0)*x102))+(((-32.0)*new_r00*x100))+(((16.0)*new_r00)));
op[3]=((((-1.0)*x101))+x103);
op[4]=x104;
polyroots4(op,zeror,numroots);
IkReal j4array[4], cj4array[4], sj4array[4], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[4]={true,true,true,true};
_nj4 = 4;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x105=new_r22*new_r22;
IkReal x106=((16.0)*new_r01);
IkReal x107=(new_r00*new_r22);
IkReal x108=((8.0)*x107);
IkReal x109=(new_r11*x105);
IkReal x110=(x105*x106);
IkReal x111=((8.0)*x109);
j4evalpoly[0]=((((htj4*htj4*htj4*htj4)*(((((-1.0)*x108))+x111))))+(((htj4*htj4*htj4)*(((((-1.0)*x106))+x110))))+(((-1.0)*x108))+x111+(((htj4*htj4)*(((((32.0)*new_r11))+(((-16.0)*x109))+(((-16.0)*x107))))))+((htj4*(((((-1.0)*x110))+x106)))));
if( IKabs(j4evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j6eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x112=cj4*cj4;
IkReal x113=(cj4*new_r22);
IkReal x114=((-1.0)+x112+(((-1.0)*x112*(new_r22*new_r22))));
j6eval[0]=x114;
j6eval[1]=((IKabs((((new_r01*sj4))+(((-1.0)*new_r00*x113)))))+(IKabs((((new_r00*sj4))+((new_r01*x113))))));
j6eval[2]=IKsign(x114);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j6eval[0]=new_r22;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x115=new_r22*new_r22;
j6eval[0]=(((cj4*x115))+(((-1.0)*cj4)));
j6eval[1]=((((-1.0)*sj4))+((sj4*x115)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x116=IKsin(j6);
IkReal x117=IKcos(j6);
evalcond[0]=x116;
evalcond[1]=((-1.0)*x117);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x116)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x117)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x118=IKsin(j6);
IkReal x119=IKcos(j6);
evalcond[0]=x118;
evalcond[1]=((-1.0)*x119);
evalcond[2]=(new_r00+(((-1.0)*x118)));
evalcond[3]=(new_r01+(((-1.0)*x119)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x120=IKsin(j6);
IkReal x121=IKcos(j6);
evalcond[0]=x120;
evalcond[1]=((-1.0)*x121);
evalcond[2]=((((-1.0)*x120))+new_r10);
evalcond[3]=((((-1.0)*x121))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x122=IKsin(j6);
IkReal x123=IKcos(j6);
evalcond[0]=x122;
evalcond[1]=((-1.0)*x123);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x122)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x123)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x124=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x124.valid){
continue;
}
if((x124.value) < -0.00001)
continue;
IkReal gconst32=((-1.0)*(IKsqrt(x124.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj4+(((-1.0)*gconst32)))))+(IKabs(((-1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32)))));
cj4=gconst32;
if( (gconst32) < -1-IKFAST_SINCOS_THRESH || (gconst32) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst32);
CheckValue<IkReal> x125=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x125.valid){
continue;
}
if((x125.value) < -0.00001)
continue;
IkReal gconst32=((-1.0)*(IKsqrt(x125.value)));
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
CheckValue<IkReal> x126=IKPowWithIntegerCheck(gconst32,-1);
if(!x126.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32))))))))+((gconst32*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x126.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32))))))))+((gconst32*new_r10))))+IKsqr((new_r11*(x126.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32))))))))+((gconst32*new_r10))), (new_r11*(x126.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x127=IKcos(j6);
IkReal x128=IKsin(j6);
IkReal x129=((1.0)*x127);
IkReal x130=((1.0)*x128);
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
IkReal x131=IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32)))));
IkReal x132=((1.0)*x131);
evalcond[0]=x128;
evalcond[1]=((-1.0)*x127);
evalcond[2]=((((-1.0)*gconst32*x129))+new_r11);
evalcond[3]=((((-1.0)*gconst32*x130))+new_r10);
evalcond[4]=(((x127*x131))+new_r01);
evalcond[5]=(((x128*x131))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x132))+(((-1.0)*x130))+((gconst32*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x132))+(((-1.0)*x129))+((gconst32*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x133=IKPowWithIntegerCheck(IKsign(gconst32),-1);
if(!x133.valid){
continue;
}
CheckValue<IkReal> x134 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x134.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x133.value)))+(x134.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x135=IKcos(j6);
IkReal x136=IKsin(j6);
IkReal x137=((1.0)*x135);
IkReal x138=((1.0)*x136);
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
IkReal x139=IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32)))));
IkReal x140=((1.0)*x139);
evalcond[0]=x136;
evalcond[1]=((-1.0)*x135);
evalcond[2]=((((-1.0)*gconst32*x137))+new_r11);
evalcond[3]=((((-1.0)*gconst32*x138))+new_r10);
evalcond[4]=(((x135*x139))+new_r01);
evalcond[5]=(((x136*x139))+new_r00);
evalcond[6]=((((-1.0)*x138))+((gconst32*new_r10))+(((-1.0)*new_r00*x140)));
evalcond[7]=((((-1.0)*new_r01*x140))+(((-1.0)*x137))+((gconst32*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x141=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x141.valid){
continue;
}
if((x141.value) < -0.00001)
continue;
IkReal gconst32=((-1.0)*(IKsqrt(x141.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj4+(((-1.0)*gconst32)))))+(IKabs(((1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32)))))));
cj4=gconst32;
if( (gconst32) < -1-IKFAST_SINCOS_THRESH || (gconst32) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst32)));
CheckValue<IkReal> x142=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x142.valid){
continue;
}
if((x142.value) < -0.00001)
continue;
IkReal gconst32=((-1.0)*(IKsqrt(x142.value)));
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
CheckValue<IkReal> x143=IKPowWithIntegerCheck(gconst32,-1);
if(!x143.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32))))))))+((gconst32*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x143.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32))))))))+((gconst32*new_r10))))+IKsqr((new_r11*(x143.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32))))))))+((gconst32*new_r10))), (new_r11*(x143.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x144=IKcos(j6);
IkReal x145=IKsin(j6);
IkReal x146=((1.0)*x144);
IkReal x147=((1.0)*x145);
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
IkReal x148=IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32)))));
evalcond[0]=x145;
evalcond[1]=((-1.0)*x144);
evalcond[2]=(new_r11+(((-1.0)*gconst32*x146)));
evalcond[3]=(new_r10+(((-1.0)*gconst32*x147)));
evalcond[4]=((((-1.0)*x146*x148))+new_r01);
evalcond[5]=((((-1.0)*x147*x148))+new_r00);
evalcond[6]=((((-1.0)*x147))+((new_r00*x148))+((gconst32*new_r10)));
evalcond[7]=((((-1.0)*x146))+((new_r01*x148))+((gconst32*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x149=IKPowWithIntegerCheck(IKsign(gconst32),-1);
if(!x149.valid){
continue;
}
CheckValue<IkReal> x150 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x150.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x149.value)))+(x150.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x151=IKcos(j6);
IkReal x152=IKsin(j6);
IkReal x153=((1.0)*x151);
IkReal x154=((1.0)*x152);
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
IkReal x155=IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32)))));
evalcond[0]=x152;
evalcond[1]=((-1.0)*x151);
evalcond[2]=(new_r11+(((-1.0)*gconst32*x153)));
evalcond[3]=(new_r10+(((-1.0)*gconst32*x154)));
evalcond[4]=((((-1.0)*x153*x155))+new_r01);
evalcond[5]=((((-1.0)*x154*x155))+new_r00);
evalcond[6]=((((-1.0)*x154))+((new_r00*x155))+((gconst32*new_r10)));
evalcond[7]=((((-1.0)*x153))+((new_r01*x155))+((gconst32*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x156=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x156.valid){
continue;
}
if((x156.value) < -0.00001)
continue;
IkReal gconst33=IKsqrt(x156.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj4)))))+(IKabs((cj4+(((-1.0)*gconst33)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))));
cj4=gconst33;
if( (gconst33) < -1-IKFAST_SINCOS_THRESH || (gconst33) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst33);
CheckValue<IkReal> x157=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x157.valid){
continue;
}
if((x157.value) < -0.00001)
continue;
IkReal gconst33=IKsqrt(x157.value);
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
CheckValue<IkReal> x158=IKPowWithIntegerCheck(gconst33,-1);
if(!x158.valid){
continue;
}
if( IKabs((((gconst33*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x158.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst33*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33))))))))))+IKsqr((new_r11*(x158.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((gconst33*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33))))))))), (new_r11*(x158.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x159=IKcos(j6);
IkReal x160=IKsin(j6);
IkReal x161=((1.0)*x159);
IkReal x162=((1.0)*x160);
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
IkReal x163=IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))));
IkReal x164=((1.0)*x163);
evalcond[0]=x160;
evalcond[1]=((-1.0)*x159);
evalcond[2]=(new_r11+(((-1.0)*gconst33*x161)));
evalcond[3]=(new_r10+(((-1.0)*gconst33*x162)));
evalcond[4]=(new_r01+((x159*x163)));
evalcond[5]=(new_r00+((x160*x163)));
evalcond[6]=((((-1.0)*new_r00*x164))+(((-1.0)*x162))+((gconst33*new_r10)));
evalcond[7]=((((-1.0)*x161))+((gconst33*new_r11))+(((-1.0)*new_r01*x164)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x165 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x165.valid){
continue;
}
CheckValue<IkReal> x166=IKPowWithIntegerCheck(IKsign(gconst33),-1);
if(!x166.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x165.value)+(((1.5707963267949)*(x166.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x167=IKcos(j6);
IkReal x168=IKsin(j6);
IkReal x169=((1.0)*x167);
IkReal x170=((1.0)*x168);
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
IkReal x171=IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))));
IkReal x172=((1.0)*x171);
evalcond[0]=x168;
evalcond[1]=((-1.0)*x167);
evalcond[2]=(new_r11+(((-1.0)*gconst33*x169)));
evalcond[3]=(new_r10+(((-1.0)*gconst33*x170)));
evalcond[4]=(((x167*x171))+new_r01);
evalcond[5]=(((x168*x171))+new_r00);
evalcond[6]=((((-1.0)*x170))+((gconst33*new_r10))+(((-1.0)*new_r00*x172)));
evalcond[7]=((((-1.0)*x169))+((gconst33*new_r11))+(((-1.0)*new_r01*x172)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x173=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x173.valid){
continue;
}
if((x173.value) < -0.00001)
continue;
IkReal gconst33=IKsqrt(x173.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj4+(((-1.0)*gconst33)))))+(IKabs(((1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))))));
cj4=gconst33;
if( (gconst33) < -1-IKFAST_SINCOS_THRESH || (gconst33) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst33)));
CheckValue<IkReal> x174=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x174.valid){
continue;
}
if((x174.value) < -0.00001)
continue;
IkReal gconst33=IKsqrt(x174.value);
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
CheckValue<IkReal> x175=IKPowWithIntegerCheck(gconst33,-1);
if(!x175.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33))))))))+((gconst33*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x175.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33))))))))+((gconst33*new_r10))))+IKsqr((new_r11*(x175.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33))))))))+((gconst33*new_r10))), (new_r11*(x175.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x176=IKcos(j6);
IkReal x177=IKsin(j6);
IkReal x178=((1.0)*x176);
IkReal x179=((1.0)*x177);
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
IkReal x180=IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))));
evalcond[0]=x177;
evalcond[1]=((-1.0)*x176);
evalcond[2]=(new_r11+(((-1.0)*gconst33*x178)));
evalcond[3]=(new_r10+(((-1.0)*gconst33*x179)));
evalcond[4]=((((-1.0)*x178*x180))+new_r01);
evalcond[5]=(new_r00+(((-1.0)*x179*x180)));
evalcond[6]=(((new_r00*x180))+(((-1.0)*x179))+((gconst33*new_r10)));
evalcond[7]=(((new_r01*x180))+(((-1.0)*x178))+((gconst33*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x181 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x181.valid){
continue;
}
CheckValue<IkReal> x182=IKPowWithIntegerCheck(IKsign(gconst33),-1);
if(!x182.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x181.value)+(((1.5707963267949)*(x182.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x183=IKcos(j6);
IkReal x184=IKsin(j6);
IkReal x185=((1.0)*x183);
IkReal x186=((1.0)*x184);
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
IkReal x187=IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))));
evalcond[0]=x184;
evalcond[1]=((-1.0)*x183);
evalcond[2]=((((-1.0)*gconst33*x185))+new_r11);
evalcond[3]=((((-1.0)*gconst33*x186))+new_r10);
evalcond[4]=((((-1.0)*x185*x187))+new_r01);
evalcond[5]=((((-1.0)*x186*x187))+new_r00);
evalcond[6]=(((new_r00*x187))+(((-1.0)*x186))+((gconst33*new_r10)));
evalcond[7]=(((new_r01*x187))+(((-1.0)*x185))+((gconst33*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x188=new_r22*new_r22;
CheckValue<IkReal> x189=IKPowWithIntegerCheck(((((-1.0)*cj4))+((cj4*x188))),-1);
if(!x189.valid){
continue;
}
CheckValue<IkReal> x190=IKPowWithIntegerCheck(((((-1.0)*sj4))+((sj4*x188))),-1);
if(!x190.valid){
continue;
}
if( IKabs(((x189.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x190.value)*((((new_r10*new_r22))+new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x189.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))))+IKsqr(((x190.value)*((((new_r10*new_r22))+new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((x189.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))), ((x190.value)*((((new_r10*new_r22))+new_r01))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x191=IKsin(j6);
IkReal x192=IKcos(j6);
IkReal x193=((1.0)*sj4);
IkReal x194=(cj4*new_r01);
IkReal x195=(new_r10*sj4);
IkReal x196=(new_r11*sj4);
IkReal x197=(cj4*new_r00);
IkReal x198=((1.0)*x192);
IkReal x199=(sj4*x191);
IkReal x200=(new_r22*x191);
IkReal x201=((1.0)*x191);
evalcond[0]=(x196+x194+x200);
evalcond[1]=(x191+((new_r22*x194))+((new_r22*x196)));
evalcond[2]=(((cj4*new_r10))+(((-1.0)*x201))+(((-1.0)*new_r00*x193)));
evalcond[3]=(((cj4*new_r11))+(((-1.0)*x198))+(((-1.0)*new_r01*x193)));
evalcond[4]=(((cj4*x200))+((sj4*x192))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x198))+x197+x195);
evalcond[6]=(x199+(((-1.0)*cj4*new_r22*x198))+new_r00);
evalcond[7]=((((-1.0)*cj4*x198))+((new_r22*x199))+new_r11);
evalcond[8]=((((-1.0)*x198))+((new_r22*x197))+((new_r22*x195)));
evalcond[9]=((((-1.0)*cj4*x201))+(((-1.0)*new_r22*x192*x193))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x202=((1.0)*sj4);
CheckValue<IkReal> x203=IKPowWithIntegerCheck(new_r22,-1);
if(!x203.valid){
continue;
}
if( IKabs(((x203.value)*(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*x202)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r11))+(((-1.0)*new_r01*x202)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x203.value)*(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*x202))))))+IKsqr((((cj4*new_r11))+(((-1.0)*new_r01*x202))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((x203.value)*(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*x202))))), (((cj4*new_r11))+(((-1.0)*new_r01*x202))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x204=IKsin(j6);
IkReal x205=IKcos(j6);
IkReal x206=((1.0)*sj4);
IkReal x207=(cj4*new_r01);
IkReal x208=(new_r10*sj4);
IkReal x209=(new_r11*sj4);
IkReal x210=(cj4*new_r00);
IkReal x211=((1.0)*x205);
IkReal x212=(sj4*x204);
IkReal x213=(new_r22*x204);
IkReal x214=((1.0)*x204);
evalcond[0]=(x213+x207+x209);
evalcond[1]=(x204+((new_r22*x209))+((new_r22*x207)));
evalcond[2]=((((-1.0)*new_r00*x206))+((cj4*new_r10))+(((-1.0)*x214)));
evalcond[3]=(((cj4*new_r11))+(((-1.0)*x211))+(((-1.0)*new_r01*x206)));
evalcond[4]=(((cj4*x213))+((sj4*x205))+new_r01);
evalcond[5]=(x210+x208+(((-1.0)*new_r22*x211)));
evalcond[6]=(x212+(((-1.0)*cj4*new_r22*x211))+new_r00);
evalcond[7]=(((new_r22*x212))+(((-1.0)*cj4*x211))+new_r11);
evalcond[8]=(((new_r22*x210))+((new_r22*x208))+(((-1.0)*x211)));
evalcond[9]=((((-1.0)*new_r22*x205*x206))+(((-1.0)*cj4*x214))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x215=cj4*cj4;
IkReal x216=(cj4*new_r22);
CheckValue<IkReal> x217 = IKatan2WithCheck(IkReal((((new_r00*sj4))+((new_r01*x216)))),IkReal((((new_r01*sj4))+(((-1.0)*new_r00*x216)))),IKFAST_ATAN2_MAGTHRESH);
if(!x217.valid){
continue;
}
CheckValue<IkReal> x218=IKPowWithIntegerCheck(IKsign(((-1.0)+(((-1.0)*x215*(new_r22*new_r22)))+x215)),-1);
if(!x218.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x217.value)+(((1.5707963267949)*(x218.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x219=IKsin(j6);
IkReal x220=IKcos(j6);
IkReal x221=((1.0)*sj4);
IkReal x222=(cj4*new_r01);
IkReal x223=(new_r10*sj4);
IkReal x224=(new_r11*sj4);
IkReal x225=(cj4*new_r00);
IkReal x226=((1.0)*x220);
IkReal x227=(sj4*x219);
IkReal x228=(new_r22*x219);
IkReal x229=((1.0)*x219);
evalcond[0]=(x228+x222+x224);
evalcond[1]=(x219+((new_r22*x224))+((new_r22*x222)));
evalcond[2]=(((cj4*new_r10))+(((-1.0)*x229))+(((-1.0)*new_r00*x221)));
evalcond[3]=((((-1.0)*new_r01*x221))+((cj4*new_r11))+(((-1.0)*x226)));
evalcond[4]=(((sj4*x220))+((cj4*x228))+new_r01);
evalcond[5]=(x223+x225+(((-1.0)*new_r22*x226)));
evalcond[6]=(x227+(((-1.0)*cj4*new_r22*x226))+new_r00);
evalcond[7]=((((-1.0)*cj4*x226))+((new_r22*x227))+new_r11);
evalcond[8]=(((new_r22*x225))+((new_r22*x223))+(((-1.0)*x226)));
evalcond[9]=((((-1.0)*cj4*x229))+new_r10+(((-1.0)*new_r22*x220*x221)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x231=IKPowWithIntegerCheck(sj5,-1);
if(!x231.valid){
continue;
}
IkReal x230=x231.value;
CheckValue<IkReal> x232=IKPowWithIntegerCheck(new_r12,-1);
if(!x232.valid){
continue;
}
if( IKabs((x230*(x232.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x230)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x230*(x232.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))))+IKsqr((new_r02*x230))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x230*(x232.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))), (new_r02*x230));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x233=IKcos(j4);
IkReal x234=IKsin(j4);
IkReal x235=((1.0)*sj5);
IkReal x236=(new_r12*x234);
IkReal x237=(new_r02*x233);
IkReal x238=(sj5*x233);
IkReal x239=(sj5*x234);
evalcond[0]=((((-1.0)*x233*x235))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x234*x235)));
evalcond[2]=((((-1.0)*new_r02*x234))+((new_r12*x233)));
evalcond[3]=((((-1.0)*x235))+x236+x237);
evalcond[4]=(((new_r10*x239))+((new_r00*x238))+((cj5*new_r20)));
evalcond[5]=(((new_r11*x239))+((new_r01*x238))+((cj5*new_r21)));
evalcond[6]=((-1.0)+((cj5*new_r22))+((sj5*x236))+((sj5*x237)));
evalcond[7]=((((-1.0)*new_r22*x235))+((cj5*x236))+((cj5*x237)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
j6eval[0]=sj4;
j6eval[1]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=cj4;
j6eval[1]=cj5;
j6eval[2]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=new_r12;
j6eval[1]=IKsign(new_r12);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=cj5;
j6eval[1]=IKsign(cj5);
j6eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=new_r12;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x240=IKcos(j6);
IkReal x241=((1.0)*(IKsin(j6)));
evalcond[0]=(x240+new_r20);
evalcond[1]=((((-1.0)*x241))+new_r21);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x241)));
evalcond[3]=((((-1.0)*x240))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x242=IKsin(j6);
IkReal x243=((1.0)*(IKcos(j6)));
evalcond[0]=(x242+new_r21);
evalcond[1]=((((-1.0)*x243))+new_r20);
evalcond[2]=((((-1.0)*x242))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x243)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r12);
evalcond[1]=new_r20;
evalcond[2]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r12=0;
j6eval[0]=cj5;
j6eval[1]=IKsign(cj5);
j6eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r12=0;
j6eval[0]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r11;
evalcond[2]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x244=IKsin(j6);
IkReal x245=IKcos(j6);
evalcond[0]=x244;
evalcond[1]=((-1.0)*x245);
evalcond[2]=((((-1.0)*x244))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x245))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r11;
evalcond[2]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x246=IKsin(j6);
IkReal x247=IKcos(j6);
evalcond[0]=x246;
evalcond[1]=((-1.0)*x247);
evalcond[2]=((((-1.0)*x246))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x247))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x248=IKsin(j6);
IkReal x249=IKcos(j6);
IkReal x250=((-1.0)*x249);
evalcond[0]=x248;
evalcond[1]=(cj5*x248);
evalcond[2]=x250;
evalcond[3]=(cj5*x250);
evalcond[4]=((((-1.0)*x248))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x249))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x251=IKPowWithIntegerCheck(cj5,-1);
if(!x251.valid){
continue;
}
if( IKabs(((-1.0)*cj5*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r10*(x251.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*cj5*new_r11))+IKsqr((new_r10*(x251.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*cj5*new_r11), (new_r10*(x251.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x252=IKsin(j6);
IkReal x253=IKcos(j6);
IkReal x254=((1.0)*x253);
evalcond[0]=(((cj5*x252))+new_r11);
evalcond[1]=(((cj5*new_r11))+x252);
evalcond[2]=((((-1.0)*cj5*x254))+new_r10);
evalcond[3]=((((-1.0)*new_r00))+(((-1.0)*x252)));
evalcond[4]=((((-1.0)*new_r01))+(((-1.0)*x254)));
evalcond[5]=(((cj5*new_r10))+(((-1.0)*x254)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x255 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x255.valid){
continue;
}
CheckValue<IkReal> x256=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x256.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x255.value)+(((1.5707963267949)*(x256.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x257=IKsin(j6);
IkReal x258=IKcos(j6);
IkReal x259=((1.0)*x258);
evalcond[0]=(((cj5*x257))+new_r11);
evalcond[1]=(((cj5*new_r11))+x257);
evalcond[2]=((((-1.0)*cj5*x259))+new_r10);
evalcond[3]=((((-1.0)*new_r00))+(((-1.0)*x257)));
evalcond[4]=((((-1.0)*new_r01))+(((-1.0)*x259)));
evalcond[5]=(((cj5*new_r10))+(((-1.0)*x259)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x260=IKsin(j6);
IkReal x261=IKcos(j6);
IkReal x262=((-1.0)*x261);
evalcond[0]=x260;
evalcond[1]=(new_r22*x260);
evalcond[2]=x262;
evalcond[3]=(new_r22*x262);
evalcond[4]=((((-1.0)*x260))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x261))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x263=IKPowWithIntegerCheck(new_r12,-1);
if(!x263.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x263.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x263.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x263.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x264=IKsin(j6);
IkReal x265=IKcos(j6);
IkReal x266=((1.0)*sj5);
IkReal x267=((1.0)*x265);
IkReal x268=((1.0)*x264);
evalcond[0]=(((new_r12*x265))+new_r20);
evalcond[1]=(((cj5*x264))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x268))+new_r21);
evalcond[3]=((((-1.0)*cj5*x267))+new_r10);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x268)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x267)));
evalcond[6]=(((cj5*new_r11))+(((-1.0)*new_r21*x266))+x264);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*new_r20*x266))+(((-1.0)*x267)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x269 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x269.valid){
continue;
}
CheckValue<IkReal> x270=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x270.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x269.value)+(((1.5707963267949)*(x270.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x271=IKsin(j6);
IkReal x272=IKcos(j6);
IkReal x273=((1.0)*sj5);
IkReal x274=((1.0)*x272);
IkReal x275=((1.0)*x271);
evalcond[0]=(new_r20+((new_r12*x272)));
evalcond[1]=(((cj5*x271))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x275))+new_r21);
evalcond[3]=((((-1.0)*cj5*x274))+new_r10);
evalcond[4]=((((-1.0)*x275))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x274))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+(((-1.0)*new_r21*x273))+x271);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*new_r20*x273))+(((-1.0)*x274)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x276 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x276.valid){
continue;
}
CheckValue<IkReal> x277=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x277.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x276.value)+(((1.5707963267949)*(x277.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x278=IKsin(j6);
IkReal x279=IKcos(j6);
IkReal x280=((1.0)*sj5);
IkReal x281=((1.0)*x279);
IkReal x282=((1.0)*x278);
evalcond[0]=(new_r20+((new_r12*x279)));
evalcond[1]=(((cj5*x278))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x282))+new_r21);
evalcond[3]=((((-1.0)*cj5*x281))+new_r10);
evalcond[4]=((((-1.0)*x282))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x281))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+x278+(((-1.0)*new_r21*x280)));
evalcond[7]=(((cj5*new_r10))+(((-1.0)*x281))+(((-1.0)*new_r20*x280)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x283=IKsin(j6);
IkReal x284=IKcos(j6);
CheckValue<IkReal> x289=IKPowWithIntegerCheck(new_r12,-1);
if(!x289.valid){
continue;
}
IkReal x285=x289.value;
IkReal x286=new_r22*new_r22;
IkReal x287=((1.0)*x284);
IkReal x288=(x285*x286);
evalcond[0]=(((new_r12*x283))+new_r21);
evalcond[1]=((((-1.0)*x283))+new_r00);
evalcond[2]=((((-1.0)*x287))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x287))+new_r20);
evalcond[4]=((((-1.0)*new_r11))+((cj5*x283)));
evalcond[5]=((((-1.0)*new_r10))+(((-1.0)*cj5*x287)));
evalcond[6]=(((new_r21*x288))+((new_r12*new_r21))+x283);
evalcond[7]=(((new_r12*new_r20))+((new_r20*x288))+(((-1.0)*x287)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x290=IKcos(j6);
IkReal x291=IKsin(j6);
IkReal x292=((1.0)*sj4);
IkReal x293=((1.0)*x291);
IkReal x294=((1.0)*x290);
evalcond[0]=(x290+new_r20);
evalcond[1]=((((-1.0)*x293))+new_r21);
evalcond[2]=(((sj4*x290))+new_r01);
evalcond[3]=(((sj4*x291))+new_r00);
evalcond[4]=((((-1.0)*cj4*x294))+new_r11);
evalcond[5]=((((-1.0)*cj4*x293))+new_r10);
evalcond[6]=(((cj4*new_r10))+(((-1.0)*x293))+(((-1.0)*new_r00*x292)));
evalcond[7]=((((-1.0)*new_r01*x292))+((cj4*new_r11))+(((-1.0)*x294)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x295=IKcos(j6);
IkReal x296=IKsin(j6);
IkReal x297=((1.0)*sj4);
IkReal x298=((1.0)*x295);
IkReal x299=((1.0)*x296);
evalcond[0]=(x296+new_r21);
evalcond[1]=((((-1.0)*x298))+new_r20);
evalcond[2]=(((sj4*x295))+new_r01);
evalcond[3]=(((sj4*x296))+new_r00);
evalcond[4]=((((-1.0)*cj4*x298))+new_r11);
evalcond[5]=((((-1.0)*cj4*x299))+new_r10);
evalcond[6]=(((cj4*new_r10))+(((-1.0)*x299))+(((-1.0)*new_r00*x297)));
evalcond[7]=((((-1.0)*new_r01*x297))+((cj4*new_r11))+(((-1.0)*x298)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x300=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*x300))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x300)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x300))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x300))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*x300))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x300))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x301=IKsin(j6);
IkReal x302=IKcos(j6);
IkReal x303=((1.0)*sj4);
IkReal x304=((1.0)*x302);
IkReal x305=(sj4*x301);
IkReal x306=(sj4*x302);
IkReal x307=(cj4*x301);
IkReal x308=(cj4*x304);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x301);
evalcond[1]=(x306+x307+new_r01);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x304)));
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x301))+(((-1.0)*new_r00*x303)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x303))+(((-1.0)*x304)));
evalcond[5]=(x305+new_r00+(((-1.0)*x308)));
evalcond[6]=(x305+new_r11+(((-1.0)*x308)));
evalcond[7]=((((-1.0)*x302*x303))+(((-1.0)*x307))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x309=((1.0)*new_r00);
if( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x309)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x309)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x309))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x309))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x309))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x309))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x310=IKcos(j6);
IkReal x311=IKsin(j6);
IkReal x312=((1.0)*sj4);
IkReal x313=((1.0)*x311);
IkReal x314=(sj4*x310);
IkReal x315=((1.0)*x310);
IkReal x316=(cj4*x313);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x310);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x313)));
evalcond[2]=(((cj4*x310))+((sj4*x311))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x312))+((cj4*new_r10))+(((-1.0)*x313)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x315))+(((-1.0)*new_r01*x312)));
evalcond[5]=(x314+(((-1.0)*x316))+new_r01);
evalcond[6]=(x314+(((-1.0)*x316))+new_r10);
evalcond[7]=((((-1.0)*cj4*x315))+new_r11+(((-1.0)*x311*x312)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x317=IKcos(j6);
IkReal x318=IKsin(j6);
IkReal x319=((1.0)*sj5);
IkReal x320=((1.0)*x317);
IkReal x321=((1.0)*x318);
evalcond[0]=(((new_r02*x317))+new_r20);
evalcond[1]=((((-1.0)*x321))+new_r10);
evalcond[2]=((((-1.0)*x320))+new_r11);
evalcond[3]=(((cj5*x318))+new_r01);
evalcond[4]=((((-1.0)*new_r02*x321))+new_r21);
evalcond[5]=((((-1.0)*cj5*x320))+new_r00);
evalcond[6]=((((-1.0)*new_r21*x319))+((cj5*new_r01))+x318);
evalcond[7]=((((-1.0)*new_r20*x319))+((cj5*new_r00))+(((-1.0)*x320)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
j6eval[1]=IKsign(new_r02);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
j6eval[1]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x322=IKcos(j6);
IkReal x323=((1.0)*(IKsin(j6)));
evalcond[0]=(x322+new_r20);
evalcond[1]=((((-1.0)*x323))+new_r21);
evalcond[2]=((((-1.0)*x323))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x322))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x324=IKsin(j6);
IkReal x325=((1.0)*(IKcos(j6)));
evalcond[0]=(x324+new_r21);
evalcond[1]=((((-1.0)*x325))+new_r20);
evalcond[2]=((((-1.0)*x324))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x325))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x326=IKsin(j6);
IkReal x327=IKcos(j6);
IkReal x328=((-1.0)*x327);
evalcond[0]=x326;
evalcond[1]=(new_r22*x326);
evalcond[2]=x328;
evalcond[3]=(new_r22*x328);
evalcond[4]=((((-1.0)*x326))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x327))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x329=IKPowWithIntegerCheck(new_r02,-1);
if(!x329.valid){
continue;
}
CheckValue<IkReal> x330=IKPowWithIntegerCheck(cj5,-1);
if(!x330.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*(x329.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00*(x330.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x329.value)))+IKsqr(((-1.0)*new_r00*(x330.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*(x329.value)), ((-1.0)*new_r00*(x330.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x331=IKsin(j6);
IkReal x332=IKcos(j6);
CheckValue<IkReal> x337=IKPowWithIntegerCheck(new_r02,-1);
if(!x337.valid){
continue;
}
IkReal x333=x337.value;
IkReal x334=new_r22*new_r22;
IkReal x335=((1.0)*x332);
IkReal x336=(x333*x334);
evalcond[0]=(((new_r02*x331))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*new_r02*x335)));
evalcond[2]=((((-1.0)*x331))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x335)));
evalcond[4]=((((-1.0)*new_r01))+((cj5*x331)));
evalcond[5]=((((-1.0)*cj5*x335))+(((-1.0)*new_r00)));
evalcond[6]=(((new_r21*x336))+x331+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x335))+((new_r02*new_r20))+((new_r20*x336)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x338=IKPowWithIntegerCheck(new_r02,-1);
if(!x338.valid){
continue;
}
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r20*(x338.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr((new_r20*(x338.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), (new_r20*(x338.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x339=IKsin(j6);
IkReal x340=IKcos(j6);
CheckValue<IkReal> x345=IKPowWithIntegerCheck(new_r02,-1);
if(!x345.valid){
continue;
}
IkReal x341=x345.value;
IkReal x342=new_r22*new_r22;
IkReal x343=((1.0)*x340);
IkReal x344=(x341*x342);
evalcond[0]=(((new_r02*x339))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x343))+new_r20);
evalcond[2]=((((-1.0)*x339))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x343)));
evalcond[4]=((((-1.0)*new_r01))+((cj5*x339)));
evalcond[5]=((((-1.0)*cj5*x343))+(((-1.0)*new_r00)));
evalcond[6]=(((new_r21*x344))+x339+((new_r02*new_r21)));
evalcond[7]=(((new_r20*x344))+((new_r02*new_r20))+(((-1.0)*x343)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x346 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x346.valid){
continue;
}
CheckValue<IkReal> x347=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x347.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x346.value)+(((1.5707963267949)*(x347.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x348=IKsin(j6);
IkReal x349=IKcos(j6);
CheckValue<IkReal> x354=IKPowWithIntegerCheck(new_r02,-1);
if(!x354.valid){
continue;
}
IkReal x350=x354.value;
IkReal x351=new_r22*new_r22;
IkReal x352=((1.0)*x349);
IkReal x353=(x350*x351);
evalcond[0]=(((new_r02*x348))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x352))+new_r20);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x348)));
evalcond[3]=((((-1.0)*x352))+(((-1.0)*new_r11)));
evalcond[4]=(((cj5*x348))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*new_r00))+(((-1.0)*cj5*x352)));
evalcond[6]=(((new_r21*x353))+x348+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x352))+((new_r20*x353))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j6eval[0]=1.0;
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j6]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j6array[2], cj6array[2], sj6array[2], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[2]={true,true};
_nj6 = 2;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x356=IKPowWithIntegerCheck(sj5,-1);
if(!x356.valid){
continue;
}
IkReal x355=x356.value;
CheckValue<IkReal> x357=IKPowWithIntegerCheck(cj4,-1);
if(!x357.valid){
continue;
}
CheckValue<IkReal> x358=IKPowWithIntegerCheck(cj5,-1);
if(!x358.valid){
continue;
}
if( IKabs((x355*(x357.value)*(x358.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x355)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x355*(x357.value)*(x358.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x355))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x355*(x357.value)*(x358.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x355));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x359=IKsin(j6);
IkReal x360=IKcos(j6);
IkReal x361=((1.0)*sj5);
IkReal x362=((1.0)*sj4);
IkReal x363=(cj5*sj4);
IkReal x364=(cj4*new_r01);
IkReal x365=(cj4*new_r00);
IkReal x366=((1.0)*x360);
IkReal x367=(cj5*x359);
IkReal x368=((1.0)*x359);
evalcond[0]=(((sj5*x360))+new_r20);
evalcond[1]=((((-1.0)*x359*x361))+new_r21);
evalcond[2]=(((new_r11*sj4))+x364+x367);
evalcond[3]=((((-1.0)*new_r00*x362))+(((-1.0)*x368))+((cj4*new_r10)));
evalcond[4]=((((-1.0)*x366))+((cj4*new_r11))+(((-1.0)*new_r01*x362)));
evalcond[5]=(((sj4*x360))+((cj4*x367))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x366))+x365);
evalcond[7]=(((sj4*x359))+(((-1.0)*cj4*cj5*x366))+new_r00);
evalcond[8]=((((-1.0)*cj4*x366))+((x359*x363))+new_r11);
evalcond[9]=((((-1.0)*cj4*x368))+(((-1.0)*cj5*x360*x362))+new_r10);
evalcond[10]=(x359+((cj5*x364))+((new_r11*x363))+(((-1.0)*new_r21*x361)));
evalcond[11]=((((-1.0)*new_r20*x361))+(((-1.0)*x366))+((cj5*x365))+((new_r10*x363)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x370=IKPowWithIntegerCheck(sj5,-1);
if(!x370.valid){
continue;
}
IkReal x369=x370.value;
CheckValue<IkReal> x371=IKPowWithIntegerCheck(sj4,-1);
if(!x371.valid){
continue;
}
if( IKabs((x369*(x371.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x369)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x369*(x371.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x369))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x369*(x371.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x369));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x372=IKsin(j6);
IkReal x373=IKcos(j6);
IkReal x374=((1.0)*sj5);
IkReal x375=((1.0)*sj4);
IkReal x376=(cj5*sj4);
IkReal x377=(cj4*new_r01);
IkReal x378=(cj4*new_r00);
IkReal x379=((1.0)*x373);
IkReal x380=(cj5*x372);
IkReal x381=((1.0)*x372);
evalcond[0]=(((sj5*x373))+new_r20);
evalcond[1]=((((-1.0)*x372*x374))+new_r21);
evalcond[2]=(((new_r11*sj4))+x380+x377);
evalcond[3]=((((-1.0)*new_r00*x375))+((cj4*new_r10))+(((-1.0)*x381)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x379))+(((-1.0)*new_r01*x375)));
evalcond[5]=(((sj4*x373))+new_r01+((cj4*x380)));
evalcond[6]=((((-1.0)*cj5*x379))+((new_r10*sj4))+x378);
evalcond[7]=(((sj4*x372))+(((-1.0)*cj4*cj5*x379))+new_r00);
evalcond[8]=((((-1.0)*cj4*x379))+((x372*x376))+new_r11);
evalcond[9]=((((-1.0)*cj5*x373*x375))+(((-1.0)*cj4*x381))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x374))+((cj5*x377))+x372+((new_r11*x376)));
evalcond[11]=((((-1.0)*new_r20*x374))+(((-1.0)*x379))+((cj5*x378))+((new_r10*x376)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x382=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x382.valid){
continue;
}
CheckValue<IkReal> x383 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x383.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x382.value)))+(x383.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x384=IKsin(j6);
IkReal x385=IKcos(j6);
IkReal x386=((1.0)*sj5);
IkReal x387=((1.0)*sj4);
IkReal x388=(cj5*sj4);
IkReal x389=(cj4*new_r01);
IkReal x390=(cj4*new_r00);
IkReal x391=((1.0)*x385);
IkReal x392=(cj5*x384);
IkReal x393=((1.0)*x384);
evalcond[0]=(((sj5*x385))+new_r20);
evalcond[1]=((((-1.0)*x384*x386))+new_r21);
evalcond[2]=(((new_r11*sj4))+x389+x392);
evalcond[3]=((((-1.0)*x393))+((cj4*new_r10))+(((-1.0)*new_r00*x387)));
evalcond[4]=((((-1.0)*x391))+((cj4*new_r11))+(((-1.0)*new_r01*x387)));
evalcond[5]=(((cj4*x392))+((sj4*x385))+new_r01);
evalcond[6]=((((-1.0)*cj5*x391))+((new_r10*sj4))+x390);
evalcond[7]=((((-1.0)*cj4*cj5*x391))+((sj4*x384))+new_r00);
evalcond[8]=((((-1.0)*cj4*x391))+((x384*x388))+new_r11);
evalcond[9]=((((-1.0)*cj5*x385*x387))+(((-1.0)*cj4*x393))+new_r10);
evalcond[10]=(x384+((new_r11*x388))+(((-1.0)*new_r21*x386))+((cj5*x389)));
evalcond[11]=((((-1.0)*x391))+((cj5*x390))+(((-1.0)*new_r20*x386))+((new_r10*x388)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x394=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x394.valid){
continue;
}
CheckValue<IkReal> x395 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x395.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x394.value)))+(x395.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
evalcond[0]=(new_r20+((sj5*(IKcos(j6)))));
evalcond[1]=((((-1.0)*sj5*(IKsin(j6))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj5;
j4eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j4eval[2]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=cj6;
j4eval[1]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j6)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), new_r10);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x396=IKsin(j4);
IkReal x397=IKcos(j4);
IkReal x398=((1.0)*sj5);
IkReal x399=(new_r22*x396);
IkReal x400=(new_r11*x396);
IkReal x401=(new_r02*x397);
IkReal x402=(new_r22*x397);
IkReal x403=(new_r12*x396);
IkReal x404=(sj5*x397);
IkReal x405=((1.0)*x396);
IkReal x406=(new_r10*x396);
evalcond[0]=(x396+new_r00);
evalcond[1]=(x402+new_r01);
evalcond[2]=(x399+new_r11);
evalcond[3]=((((-1.0)*x397))+new_r10);
evalcond[4]=((((-1.0)*x397*x398))+new_r02);
evalcond[5]=((((-1.0)*x396*x398))+new_r12);
evalcond[6]=(x406+((new_r00*x397)));
evalcond[7]=((((-1.0)*new_r02*x405))+((new_r12*x397)));
evalcond[8]=(((new_r11*x397))+(((-1.0)*new_r01*x405)));
evalcond[9]=(x400+((new_r01*x397))+new_r22);
evalcond[10]=((-1.0)+(((-1.0)*new_r00*x405))+((new_r10*x397)));
evalcond[11]=(((sj5*x406))+((new_r00*x404)));
evalcond[12]=(((new_r00*x402))+((new_r10*x399)));
evalcond[13]=((((-1.0)*x398))+x401+x403);
evalcond[14]=(((cj5*new_r21))+((sj5*x400))+((new_r01*x404)));
evalcond[15]=((-1.0)+(new_r22*new_r22)+((sj5*x401))+((sj5*x403)));
evalcond[16]=(((new_r22*x401))+(((-1.0)*new_r22*x398))+((new_r12*x399)));
evalcond[17]=((1.0)+((new_r11*x399))+(((-1.0)*sj5*x398))+((new_r01*x402)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j6)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x407=IKcos(j4);
IkReal x408=IKsin(j4);
IkReal x409=((1.0)*sj5);
IkReal x410=((1.0)*x407);
IkReal x411=(new_r22*x408);
IkReal x412=(new_r11*x408);
IkReal x413=(new_r02*x407);
IkReal x414=(new_r01*x407);
IkReal x415=(new_r12*x408);
IkReal x416=(new_r00*x407);
IkReal x417=((1.0)*x408);
IkReal x418=(new_r10*x408);
evalcond[0]=(x407+new_r10);
evalcond[1]=(new_r00+(((-1.0)*x417)));
evalcond[2]=((((-1.0)*x407*x409))+new_r02);
evalcond[3]=(new_r12+(((-1.0)*x408*x409)));
evalcond[4]=(new_r01+(((-1.0)*new_r22*x410)));
evalcond[5]=(new_r11+(((-1.0)*x411)));
evalcond[6]=(x416+x418);
evalcond[7]=(((new_r12*x407))+(((-1.0)*new_r02*x417)));
evalcond[8]=(((new_r11*x407))+(((-1.0)*new_r01*x417)));
evalcond[9]=((1.0)+((new_r10*x407))+(((-1.0)*new_r00*x417)));
evalcond[10]=(((sj5*x416))+((sj5*x418)));
evalcond[11]=(((new_r22*x416))+((new_r10*x411)));
evalcond[12]=(x413+x415+(((-1.0)*x409)));
evalcond[13]=(x412+x414+(((-1.0)*new_r22)));
evalcond[14]=(((sj5*x412))+((sj5*x414))+((cj5*new_r21)));
evalcond[15]=((-1.0)+(new_r22*new_r22)+((sj5*x413))+((sj5*x415)));
evalcond[16]=(((new_r22*x413))+((new_r12*x411))+(((-1.0)*new_r22*x409)));
evalcond[17]=((-1.0)+((new_r22*x414))+((new_r11*x411))+(sj5*sj5));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x419=((1.0)*sj6);
if( IKabs(((((-1.0)*cj6*new_r01))+(((-1.0)*new_r00*x419)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj6*new_r00))+(((-1.0)*new_r01*x419)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj6*new_r01))+(((-1.0)*new_r00*x419))))+IKsqr((((cj6*new_r00))+(((-1.0)*new_r01*x419))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj6*new_r01))+(((-1.0)*new_r00*x419))), (((cj6*new_r00))+(((-1.0)*new_r01*x419))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x420=IKcos(j4);
IkReal x421=IKsin(j4);
IkReal x422=((1.0)*cj6);
IkReal x423=(sj6*x421);
IkReal x424=(cj6*x421);
IkReal x425=(sj6*x420);
IkReal x426=((1.0)*x421);
IkReal x427=(x420*x422);
evalcond[0]=(sj6+((new_r11*x421))+((new_r01*x420)));
evalcond[1]=(x425+x424+new_r01);
evalcond[2]=((((-1.0)*x427))+x423+new_r00);
evalcond[3]=((((-1.0)*x427))+x423+new_r11);
evalcond[4]=((((-1.0)*x422))+((new_r10*x421))+((new_r00*x420)));
evalcond[5]=((((-1.0)*x425))+(((-1.0)*x421*x422))+new_r10);
evalcond[6]=((((-1.0)*sj6))+(((-1.0)*new_r00*x426))+((new_r10*x420)));
evalcond[7]=((((-1.0)*x422))+((new_r11*x420))+(((-1.0)*new_r01*x426)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x428=((1.0)*new_r00);
if( IKabs(((((-1.0)*cj6*new_r01))+(((-1.0)*sj6*x428)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj6*x428))+((new_r01*sj6)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj6*new_r01))+(((-1.0)*sj6*x428))))+IKsqr(((((-1.0)*cj6*x428))+((new_r01*sj6))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj6*new_r01))+(((-1.0)*sj6*x428))), ((((-1.0)*cj6*x428))+((new_r01*sj6))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x429=IKsin(j4);
IkReal x430=IKcos(j4);
IkReal x431=((1.0)*sj6);
IkReal x432=(cj6*x429);
IkReal x433=(cj6*x430);
IkReal x434=((1.0)*x429);
IkReal x435=(x430*x431);
evalcond[0]=(((new_r00*x430))+cj6+((new_r10*x429)));
evalcond[1]=(((sj6*x429))+x433+new_r00);
evalcond[2]=((((-1.0)*x435))+x432+new_r01);
evalcond[3]=((((-1.0)*x435))+x432+new_r10);
evalcond[4]=(((new_r01*x430))+(((-1.0)*x431))+((new_r11*x429)));
evalcond[5]=((((-1.0)*x433))+(((-1.0)*x429*x431))+new_r11);
evalcond[6]=((((-1.0)*new_r00*x434))+(((-1.0)*x431))+((new_r10*x430)));
evalcond[7]=((((-1.0)*new_r01*x434))+((new_r11*x430))+(((-1.0)*cj6)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x437 = IKatan2WithCheck(IkReal((new_r01*new_r22)),IkReal((new_r11*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x437.valid){
continue;
}
IkReal x436=x437.value;
j4array[0]=((-1.0)*x436);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x436)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x438=IKcos(j4);
IkReal x439=IKsin(j4);
IkReal x440=(new_r00*x438);
IkReal x441=(new_r10*x439);
IkReal x442=((1.0)*x439);
evalcond[0]=(((new_r01*x438))+((new_r11*x439)));
evalcond[1]=(x441+x440);
evalcond[2]=((((-1.0)*new_r00*x442))+((new_r10*x438)));
evalcond[3]=((((-1.0)*new_r01*x442))+((new_r11*x438)));
evalcond[4]=(((new_r22*x440))+((new_r22*x441)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x444 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x444.valid){
continue;
}
IkReal x443=x444.value;
j4array[0]=((-1.0)*x443);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x443)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x445=IKcos(j4);
IkReal x446=IKsin(j4);
IkReal x447=(new_r01*x445);
IkReal x448=(new_r11*x446);
IkReal x449=((1.0)*x446);
evalcond[0]=(x448+x447);
evalcond[1]=((((-1.0)*new_r00*x449))+((new_r10*x445)));
evalcond[2]=((((-1.0)*new_r01*x449))+((new_r11*x445)));
evalcond[3]=(((new_r22*x448))+((new_r22*x447)));
evalcond[4]=(((new_r10*new_r22*x446))+((new_r00*new_r22*x445)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x451 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x451.valid){
continue;
}
IkReal x450=x451.value;
j4array[0]=((-1.0)*x450);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x450)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x452=IKcos(j4);
IkReal x453=IKsin(j4);
IkReal x454=(new_r00*x452);
IkReal x455=(new_r22*x453);
IkReal x456=((1.0)*x453);
evalcond[0]=(((new_r10*x453))+x454);
evalcond[1]=(((new_r10*x452))+(((-1.0)*new_r00*x456)));
evalcond[2]=(((new_r11*x452))+(((-1.0)*new_r01*x456)));
evalcond[3]=(((new_r11*x455))+((new_r01*new_r22*x452)));
evalcond[4]=(((new_r10*x455))+((new_r22*x454)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x458=IKPowWithIntegerCheck(sj5,-1);
if(!x458.valid){
continue;
}
IkReal x457=x458.value;
CheckValue<IkReal> x459=IKPowWithIntegerCheck(cj6,-1);
if(!x459.valid){
continue;
}
if( IKabs((x457*(x459.value)*(((((-1.0)*new_r01*sj5))+(((-1.0)*cj5*new_r02*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x457)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x457*(x459.value)*(((((-1.0)*new_r01*sj5))+(((-1.0)*cj5*new_r02*sj6))))))+IKsqr((new_r02*x457))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x457*(x459.value)*(((((-1.0)*new_r01*sj5))+(((-1.0)*cj5*new_r02*sj6))))), (new_r02*x457));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x460=IKcos(j4);
IkReal x461=IKsin(j4);
IkReal x462=((1.0)*cj6);
IkReal x463=(cj5*sj6);
IkReal x464=((1.0)*sj5);
IkReal x465=((1.0)*sj6);
IkReal x466=(cj5*x461);
IkReal x467=(new_r11*x461);
IkReal x468=(cj5*x460);
IkReal x469=(new_r02*x460);
IkReal x470=(new_r12*x461);
IkReal x471=(sj5*x460);
IkReal x472=((1.0)*x461);
IkReal x473=(new_r10*x461);
evalcond[0]=((((-1.0)*x460*x464))+new_r02);
evalcond[1]=((((-1.0)*x461*x464))+new_r12);
evalcond[2]=(((new_r12*x460))+(((-1.0)*new_r02*x472)));
evalcond[3]=(((cj6*x461))+((x460*x463))+new_r01);
evalcond[4]=((((-1.0)*x464))+x469+x470);
evalcond[5]=(((new_r01*x460))+x463+x467);
evalcond[6]=(((sj6*x461))+(((-1.0)*x462*x468))+new_r00);
evalcond[7]=(((x461*x463))+(((-1.0)*x460*x462))+new_r11);
evalcond[8]=(((new_r10*x460))+(((-1.0)*new_r00*x472))+(((-1.0)*x465)));
evalcond[9]=(((new_r11*x460))+(((-1.0)*x462))+(((-1.0)*new_r01*x472)));
evalcond[10]=(((new_r00*x460))+(((-1.0)*cj5*x462))+x473);
evalcond[11]=((((-1.0)*x462*x466))+(((-1.0)*x460*x465))+new_r10);
evalcond[12]=(((sj5*x473))+((new_r00*x471))+((cj5*new_r20)));
evalcond[13]=(((new_r01*x471))+((cj5*new_r21))+((sj5*x467)));
evalcond[14]=((-1.0)+((sj5*x470))+((cj5*new_r22))+((sj5*x469)));
evalcond[15]=(((new_r12*x466))+(((-1.0)*new_r22*x464))+((new_r02*x468)));
evalcond[16]=((((-1.0)*new_r21*x464))+((new_r11*x466))+sj6+((new_r01*x468)));
evalcond[17]=(((new_r10*x466))+((new_r00*x468))+(((-1.0)*new_r20*x464))+(((-1.0)*x462)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x474=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x474.valid){
continue;
}
CheckValue<IkReal> x475 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x475.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x474.value)))+(x475.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x476=IKcos(j4);
IkReal x477=IKsin(j4);
IkReal x478=((1.0)*cj6);
IkReal x479=(cj5*sj6);
IkReal x480=((1.0)*sj5);
IkReal x481=((1.0)*sj6);
IkReal x482=(cj5*x477);
IkReal x483=(new_r11*x477);
IkReal x484=(cj5*x476);
IkReal x485=(new_r02*x476);
IkReal x486=(new_r12*x477);
IkReal x487=(sj5*x476);
IkReal x488=((1.0)*x477);
IkReal x489=(new_r10*x477);
evalcond[0]=((((-1.0)*x476*x480))+new_r02);
evalcond[1]=((((-1.0)*x477*x480))+new_r12);
evalcond[2]=(((new_r12*x476))+(((-1.0)*new_r02*x488)));
evalcond[3]=(((cj6*x477))+new_r01+((x476*x479)));
evalcond[4]=((((-1.0)*x480))+x485+x486);
evalcond[5]=(((new_r01*x476))+x483+x479);
evalcond[6]=(((sj6*x477))+new_r00+(((-1.0)*x478*x484)));
evalcond[7]=((((-1.0)*x476*x478))+((x477*x479))+new_r11);
evalcond[8]=((((-1.0)*x481))+(((-1.0)*new_r00*x488))+((new_r10*x476)));
evalcond[9]=((((-1.0)*new_r01*x488))+((new_r11*x476))+(((-1.0)*x478)));
evalcond[10]=((((-1.0)*cj5*x478))+((new_r00*x476))+x489);
evalcond[11]=((((-1.0)*x476*x481))+new_r10+(((-1.0)*x478*x482)));
evalcond[12]=(((cj5*new_r20))+((sj5*x489))+((new_r00*x487)));
evalcond[13]=(((cj5*new_r21))+((sj5*x483))+((new_r01*x487)));
evalcond[14]=((-1.0)+((cj5*new_r22))+((sj5*x486))+((sj5*x485)));
evalcond[15]=(((new_r02*x484))+((new_r12*x482))+(((-1.0)*new_r22*x480)));
evalcond[16]=((((-1.0)*new_r21*x480))+sj6+((new_r11*x482))+((new_r01*x484)));
evalcond[17]=((((-1.0)*new_r20*x480))+(((-1.0)*x478))+((new_r10*x482))+((new_r00*x484)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x490=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x490.valid){
continue;
}
CheckValue<IkReal> x491 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x491.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x490.value)))+(x491.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x492=IKcos(j4);
IkReal x493=IKsin(j4);
IkReal x494=((1.0)*sj5);
IkReal x495=(new_r12*x493);
IkReal x496=(new_r02*x492);
IkReal x497=(sj5*x492);
IkReal x498=(sj5*x493);
evalcond[0]=(new_r02+(((-1.0)*x492*x494)));
evalcond[1]=((((-1.0)*x493*x494))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x493))+((new_r12*x492)));
evalcond[3]=((((-1.0)*x494))+x496+x495);
evalcond[4]=(((cj5*new_r20))+((new_r10*x498))+((new_r00*x497)));
evalcond[5]=(((cj5*new_r21))+((new_r11*x498))+((new_r01*x497)));
evalcond[6]=((-1.0)+((cj5*new_r22))+((sj5*x496))+((sj5*x495)));
evalcond[7]=(((cj5*x495))+((cj5*x496))+(((-1.0)*new_r22*x494)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
j6eval[0]=sj4;
j6eval[1]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=cj4;
j6eval[1]=cj5;
j6eval[2]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=new_r12;
j6eval[1]=IKsign(new_r12);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=cj5;
j6eval[1]=IKsign(cj5);
j6eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=new_r12;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x499=IKcos(j6);
IkReal x500=((1.0)*(IKsin(j6)));
evalcond[0]=(x499+new_r20);
evalcond[1]=((((-1.0)*x500))+new_r21);
evalcond[2]=((((-1.0)*x500))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x499))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x501=IKsin(j6);
IkReal x502=((1.0)*(IKcos(j6)));
evalcond[0]=(x501+new_r21);
evalcond[1]=((((-1.0)*x502))+new_r20);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x501)));
evalcond[3]=((((-1.0)*x502))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r12);
evalcond[1]=new_r20;
evalcond[2]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r12=0;
j6eval[0]=cj5;
j6eval[1]=IKsign(cj5);
j6eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r12=0;
j6eval[0]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r11;
evalcond[2]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x503=IKsin(j6);
IkReal x504=IKcos(j6);
evalcond[0]=x503;
evalcond[1]=((-1.0)*x504);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x503)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x504)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r11;
evalcond[2]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x505=IKsin(j6);
IkReal x506=IKcos(j6);
evalcond[0]=x505;
evalcond[1]=((-1.0)*x506);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x505)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x506)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x507=IKsin(j6);
IkReal x508=IKcos(j6);
IkReal x509=((-1.0)*x508);
evalcond[0]=x507;
evalcond[1]=(cj5*x507);
evalcond[2]=x509;
evalcond[3]=(cj5*x509);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x507)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x508)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x510=IKPowWithIntegerCheck(cj5,-1);
if(!x510.valid){
continue;
}
if( IKabs(((-1.0)*cj5*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r10*(x510.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*cj5*new_r11))+IKsqr((new_r10*(x510.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*cj5*new_r11), (new_r10*(x510.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x511=IKsin(j6);
IkReal x512=IKcos(j6);
IkReal x513=((1.0)*x512);
evalcond[0]=(((cj5*x511))+new_r11);
evalcond[1]=(((cj5*new_r11))+x511);
evalcond[2]=((((-1.0)*cj5*x513))+new_r10);
evalcond[3]=((((-1.0)*x511))+(((-1.0)*new_r00)));
evalcond[4]=((((-1.0)*new_r01))+(((-1.0)*x513)));
evalcond[5]=(((cj5*new_r10))+(((-1.0)*x513)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x514 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x514.valid){
continue;
}
CheckValue<IkReal> x515=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x515.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x514.value)+(((1.5707963267949)*(x515.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x516=IKsin(j6);
IkReal x517=IKcos(j6);
IkReal x518=((1.0)*x517);
evalcond[0]=(((cj5*x516))+new_r11);
evalcond[1]=(((cj5*new_r11))+x516);
evalcond[2]=((((-1.0)*cj5*x518))+new_r10);
evalcond[3]=((((-1.0)*x516))+(((-1.0)*new_r00)));
evalcond[4]=((((-1.0)*new_r01))+(((-1.0)*x518)));
evalcond[5]=(((cj5*new_r10))+(((-1.0)*x518)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x519=IKsin(j6);
IkReal x520=IKcos(j6);
IkReal x521=((-1.0)*x520);
evalcond[0]=x519;
evalcond[1]=(new_r22*x519);
evalcond[2]=x521;
evalcond[3]=(new_r22*x521);
evalcond[4]=((((-1.0)*x519))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x520))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x522=IKPowWithIntegerCheck(new_r12,-1);
if(!x522.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x522.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x522.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x522.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x523=IKsin(j6);
IkReal x524=IKcos(j6);
IkReal x525=((1.0)*sj5);
IkReal x526=((1.0)*x524);
IkReal x527=((1.0)*x523);
evalcond[0]=(((new_r12*x524))+new_r20);
evalcond[1]=(((cj5*x523))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x527))+new_r21);
evalcond[3]=(new_r10+(((-1.0)*cj5*x526)));
evalcond[4]=((((-1.0)*x527))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x526))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+(((-1.0)*new_r21*x525))+x523);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*new_r20*x525))+(((-1.0)*x526)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x528 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x528.valid){
continue;
}
CheckValue<IkReal> x529=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x529.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x528.value)+(((1.5707963267949)*(x529.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x530=IKsin(j6);
IkReal x531=IKcos(j6);
IkReal x532=((1.0)*sj5);
IkReal x533=((1.0)*x531);
IkReal x534=((1.0)*x530);
evalcond[0]=(((new_r12*x531))+new_r20);
evalcond[1]=(((cj5*x530))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x534))+new_r21);
evalcond[3]=(new_r10+(((-1.0)*cj5*x533)));
evalcond[4]=((((-1.0)*x534))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x533))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+(((-1.0)*new_r21*x532))+x530);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*x533))+(((-1.0)*new_r20*x532)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x535 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x535.valid){
continue;
}
CheckValue<IkReal> x536=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x536.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x535.value)+(((1.5707963267949)*(x536.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x537=IKsin(j6);
IkReal x538=IKcos(j6);
IkReal x539=((1.0)*sj5);
IkReal x540=((1.0)*x538);
IkReal x541=((1.0)*x537);
evalcond[0]=(((new_r12*x538))+new_r20);
evalcond[1]=(((cj5*x537))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x541))+new_r21);
evalcond[3]=(new_r10+(((-1.0)*cj5*x540)));
evalcond[4]=((((-1.0)*x541))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x540))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+(((-1.0)*new_r21*x539))+x537);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*new_r20*x539))+(((-1.0)*x540)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x542=IKsin(j6);
IkReal x543=IKcos(j6);
CheckValue<IkReal> x548=IKPowWithIntegerCheck(new_r12,-1);
if(!x548.valid){
continue;
}
IkReal x544=x548.value;
IkReal x545=new_r22*new_r22;
IkReal x546=((1.0)*x543);
IkReal x547=(x544*x545);
evalcond[0]=(((new_r12*x542))+new_r21);
evalcond[1]=((((-1.0)*x542))+new_r00);
evalcond[2]=((((-1.0)*x546))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x546))+new_r20);
evalcond[4]=(((cj5*x542))+(((-1.0)*new_r11)));
evalcond[5]=((((-1.0)*new_r10))+(((-1.0)*cj5*x546)));
evalcond[6]=(((new_r12*new_r21))+x542+((new_r21*x547)));
evalcond[7]=((((-1.0)*x546))+((new_r12*new_r20))+((new_r20*x547)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x549=IKcos(j6);
IkReal x550=IKsin(j6);
IkReal x551=((1.0)*sj4);
IkReal x552=((1.0)*x550);
IkReal x553=((1.0)*x549);
evalcond[0]=(x549+new_r20);
evalcond[1]=((((-1.0)*x552))+new_r21);
evalcond[2]=(new_r01+((sj4*x549)));
evalcond[3]=(((sj4*x550))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*cj4*x553)));
evalcond[5]=(new_r10+(((-1.0)*cj4*x552)));
evalcond[6]=(((cj4*new_r10))+(((-1.0)*new_r00*x551))+(((-1.0)*x552)));
evalcond[7]=(((cj4*new_r11))+(((-1.0)*new_r01*x551))+(((-1.0)*x553)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x554=IKcos(j6);
IkReal x555=IKsin(j6);
IkReal x556=((1.0)*sj4);
IkReal x557=((1.0)*x554);
IkReal x558=((1.0)*x555);
evalcond[0]=(x555+new_r21);
evalcond[1]=((((-1.0)*x557))+new_r20);
evalcond[2]=(((sj4*x554))+new_r01);
evalcond[3]=(((sj4*x555))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*cj4*x557)));
evalcond[5]=(new_r10+(((-1.0)*cj4*x558)));
evalcond[6]=(((cj4*new_r10))+(((-1.0)*new_r00*x556))+(((-1.0)*x558)));
evalcond[7]=(((cj4*new_r11))+(((-1.0)*new_r01*x556))+(((-1.0)*x557)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x559=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x559)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x559)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x559))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x559))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x559))), (((cj4*new_r00))+(((-1.0)*sj4*x559))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x560=IKsin(j6);
IkReal x561=IKcos(j6);
IkReal x562=((1.0)*sj4);
IkReal x563=((1.0)*x561);
IkReal x564=(sj4*x560);
IkReal x565=(sj4*x561);
IkReal x566=(cj4*x560);
IkReal x567=(cj4*x563);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x560);
evalcond[1]=(x566+x565+new_r01);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x563)));
evalcond[3]=((((-1.0)*new_r00*x562))+((cj4*new_r10))+(((-1.0)*x560)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x563))+(((-1.0)*new_r01*x562)));
evalcond[5]=(x564+new_r00+(((-1.0)*x567)));
evalcond[6]=(x564+new_r11+(((-1.0)*x567)));
evalcond[7]=((((-1.0)*x566))+new_r10+(((-1.0)*x561*x562)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x568=((1.0)*new_r00);
if( IKabs(((((-1.0)*sj4*x568))+((cj4*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x568)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj4*x568))+((cj4*new_r01))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x568))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*sj4*x568))+((cj4*new_r01))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x568))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x569=IKcos(j6);
IkReal x570=IKsin(j6);
IkReal x571=((1.0)*sj4);
IkReal x572=((1.0)*x570);
IkReal x573=(sj4*x569);
IkReal x574=((1.0)*x569);
IkReal x575=(cj4*x572);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x569);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x572)));
evalcond[2]=(((sj4*x570))+new_r00+((cj4*x569)));
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x572))+(((-1.0)*new_r00*x571)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x574))+(((-1.0)*new_r01*x571)));
evalcond[5]=((((-1.0)*x575))+x573+new_r01);
evalcond[6]=((((-1.0)*x575))+x573+new_r10);
evalcond[7]=((((-1.0)*x570*x571))+(((-1.0)*cj4*x574))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x576=IKcos(j6);
IkReal x577=IKsin(j6);
IkReal x578=((1.0)*sj5);
IkReal x579=((1.0)*x576);
IkReal x580=((1.0)*x577);
evalcond[0]=(new_r20+((new_r02*x576)));
evalcond[1]=(new_r10+(((-1.0)*x580)));
evalcond[2]=((((-1.0)*x579))+new_r11);
evalcond[3]=(((cj5*x577))+new_r01);
evalcond[4]=((((-1.0)*new_r02*x580))+new_r21);
evalcond[5]=((((-1.0)*cj5*x579))+new_r00);
evalcond[6]=(((cj5*new_r01))+x577+(((-1.0)*new_r21*x578)));
evalcond[7]=(((cj5*new_r00))+(((-1.0)*x579))+(((-1.0)*new_r20*x578)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
j6eval[1]=IKsign(new_r02);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
j6eval[1]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x581=IKcos(j6);
IkReal x582=((1.0)*(IKsin(j6)));
evalcond[0]=(x581+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x582)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x582)));
evalcond[3]=((((-1.0)*x581))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x583=IKsin(j6);
IkReal x584=((1.0)*(IKcos(j6)));
evalcond[0]=(x583+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x584)));
evalcond[2]=((((-1.0)*x583))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x584)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x585=IKsin(j6);
IkReal x586=IKcos(j6);
IkReal x587=((-1.0)*x586);
evalcond[0]=x585;
evalcond[1]=(new_r22*x585);
evalcond[2]=x587;
evalcond[3]=(new_r22*x587);
evalcond[4]=((((-1.0)*x585))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x586))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x588=IKPowWithIntegerCheck(new_r02,-1);
if(!x588.valid){
continue;
}
CheckValue<IkReal> x589=IKPowWithIntegerCheck(cj5,-1);
if(!x589.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*(x588.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00*(x589.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x588.value)))+IKsqr(((-1.0)*new_r00*(x589.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*(x588.value)), ((-1.0)*new_r00*(x589.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x590=IKsin(j6);
IkReal x591=IKcos(j6);
CheckValue<IkReal> x596=IKPowWithIntegerCheck(new_r02,-1);
if(!x596.valid){
continue;
}
IkReal x592=x596.value;
IkReal x593=new_r22*new_r22;
IkReal x594=((1.0)*x591);
IkReal x595=(x592*x593);
evalcond[0]=(((new_r02*x590))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x594))+new_r20);
evalcond[2]=((((-1.0)*x590))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x594))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*new_r01))+((cj5*x590)));
evalcond[5]=((((-1.0)*cj5*x594))+(((-1.0)*new_r00)));
evalcond[6]=(x590+((new_r21*x595))+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x594))+((new_r20*x595))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x597=IKPowWithIntegerCheck(new_r02,-1);
if(!x597.valid){
continue;
}
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r20*(x597.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr((new_r20*(x597.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), (new_r20*(x597.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x598=IKsin(j6);
IkReal x599=IKcos(j6);
CheckValue<IkReal> x604=IKPowWithIntegerCheck(new_r02,-1);
if(!x604.valid){
continue;
}
IkReal x600=x604.value;
IkReal x601=new_r22*new_r22;
IkReal x602=((1.0)*x599);
IkReal x603=(x600*x601);
evalcond[0]=(((new_r02*x598))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x602))+new_r20);
evalcond[2]=((((-1.0)*x598))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x602)));
evalcond[4]=((((-1.0)*new_r01))+((cj5*x598)));
evalcond[5]=((((-1.0)*cj5*x602))+(((-1.0)*new_r00)));
evalcond[6]=(((new_r21*x603))+x598+((new_r02*new_r21)));
evalcond[7]=(((new_r20*x603))+(((-1.0)*x602))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x605 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x605.valid){
continue;
}
CheckValue<IkReal> x606=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x606.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x605.value)+(((1.5707963267949)*(x606.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x607=IKsin(j6);
IkReal x608=IKcos(j6);
CheckValue<IkReal> x613=IKPowWithIntegerCheck(new_r02,-1);
if(!x613.valid){
continue;
}
IkReal x609=x613.value;
IkReal x610=new_r22*new_r22;
IkReal x611=((1.0)*x608);
IkReal x612=(x609*x610);
evalcond[0]=(((new_r02*x607))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x611))+new_r20);
evalcond[2]=((((-1.0)*x607))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x611))+(((-1.0)*new_r11)));
evalcond[4]=(((cj5*x607))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*cj5*x611))+(((-1.0)*new_r00)));
evalcond[6]=(((new_r21*x612))+x607+((new_r02*new_r21)));
evalcond[7]=(((new_r20*x612))+(((-1.0)*x611))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j6eval[0]=1.0;
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j6]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j6array[2], cj6array[2], sj6array[2], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[2]={true,true};
_nj6 = 2;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x615=IKPowWithIntegerCheck(sj5,-1);
if(!x615.valid){
continue;
}
IkReal x614=x615.value;
CheckValue<IkReal> x616=IKPowWithIntegerCheck(cj4,-1);
if(!x616.valid){
continue;
}
CheckValue<IkReal> x617=IKPowWithIntegerCheck(cj5,-1);
if(!x617.valid){
continue;
}
if( IKabs((x614*(x616.value)*(x617.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x614)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x614*(x616.value)*(x617.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x614))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x614*(x616.value)*(x617.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x614));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x618=IKsin(j6);
IkReal x619=IKcos(j6);
IkReal x620=((1.0)*sj5);
IkReal x621=((1.0)*sj4);
IkReal x622=(cj5*sj4);
IkReal x623=(cj4*new_r01);
IkReal x624=(cj4*new_r00);
IkReal x625=((1.0)*x619);
IkReal x626=(cj5*x618);
IkReal x627=((1.0)*x618);
evalcond[0]=(new_r20+((sj5*x619)));
evalcond[1]=((((-1.0)*x618*x620))+new_r21);
evalcond[2]=(((new_r11*sj4))+x626+x623);
evalcond[3]=((((-1.0)*new_r00*x621))+((cj4*new_r10))+(((-1.0)*x627)));
evalcond[4]=((((-1.0)*new_r01*x621))+((cj4*new_r11))+(((-1.0)*x625)));
evalcond[5]=(((sj4*x619))+((cj4*x626))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x625))+x624);
evalcond[7]=(((sj4*x618))+(((-1.0)*cj4*cj5*x625))+new_r00);
evalcond[8]=(((x618*x622))+(((-1.0)*cj4*x625))+new_r11);
evalcond[9]=((((-1.0)*cj4*x627))+new_r10+(((-1.0)*cj5*x619*x621)));
evalcond[10]=(((cj5*x623))+(((-1.0)*new_r21*x620))+((new_r11*x622))+x618);
evalcond[11]=((((-1.0)*x625))+((cj5*x624))+((new_r10*x622))+(((-1.0)*new_r20*x620)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x629=IKPowWithIntegerCheck(sj5,-1);
if(!x629.valid){
continue;
}
IkReal x628=x629.value;
CheckValue<IkReal> x630=IKPowWithIntegerCheck(sj4,-1);
if(!x630.valid){
continue;
}
if( IKabs((x628*(x630.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x628)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x628*(x630.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x628))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x628*(x630.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x628));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x631=IKsin(j6);
IkReal x632=IKcos(j6);
IkReal x633=((1.0)*sj5);
IkReal x634=((1.0)*sj4);
IkReal x635=(cj5*sj4);
IkReal x636=(cj4*new_r01);
IkReal x637=(cj4*new_r00);
IkReal x638=((1.0)*x632);
IkReal x639=(cj5*x631);
IkReal x640=((1.0)*x631);
evalcond[0]=(((sj5*x632))+new_r20);
evalcond[1]=((((-1.0)*x631*x633))+new_r21);
evalcond[2]=(((new_r11*sj4))+x636+x639);
evalcond[3]=((((-1.0)*new_r00*x634))+((cj4*new_r10))+(((-1.0)*x640)));
evalcond[4]=((((-1.0)*new_r01*x634))+((cj4*new_r11))+(((-1.0)*x638)));
evalcond[5]=(((sj4*x632))+((cj4*x639))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x638))+x637);
evalcond[7]=(((sj4*x631))+new_r00+(((-1.0)*cj4*cj5*x638)));
evalcond[8]=((((-1.0)*cj4*x638))+new_r11+((x631*x635)));
evalcond[9]=((((-1.0)*cj5*x632*x634))+new_r10+(((-1.0)*cj4*x640)));
evalcond[10]=(((cj5*x636))+(((-1.0)*new_r21*x633))+((new_r11*x635))+x631);
evalcond[11]=((((-1.0)*x638))+((cj5*x637))+(((-1.0)*new_r20*x633))+((new_r10*x635)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x641=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x641.valid){
continue;
}
CheckValue<IkReal> x642 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x642.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x641.value)))+(x642.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x643=IKsin(j6);
IkReal x644=IKcos(j6);
IkReal x645=((1.0)*sj5);
IkReal x646=((1.0)*sj4);
IkReal x647=(cj5*sj4);
IkReal x648=(cj4*new_r01);
IkReal x649=(cj4*new_r00);
IkReal x650=((1.0)*x644);
IkReal x651=(cj5*x643);
IkReal x652=((1.0)*x643);
evalcond[0]=(((sj5*x644))+new_r20);
evalcond[1]=((((-1.0)*x643*x645))+new_r21);
evalcond[2]=(((new_r11*sj4))+x648+x651);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x652))+(((-1.0)*new_r00*x646)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x650))+(((-1.0)*new_r01*x646)));
evalcond[5]=(((cj4*x651))+((sj4*x644))+new_r01);
evalcond[6]=(((new_r10*sj4))+x649+(((-1.0)*cj5*x650)));
evalcond[7]=(((sj4*x643))+(((-1.0)*cj4*cj5*x650))+new_r00);
evalcond[8]=(((x643*x647))+new_r11+(((-1.0)*cj4*x650)));
evalcond[9]=((((-1.0)*cj5*x644*x646))+new_r10+(((-1.0)*cj4*x652)));
evalcond[10]=(((cj5*x648))+((new_r11*x647))+(((-1.0)*new_r21*x645))+x643);
evalcond[11]=(((cj5*x649))+(((-1.0)*x650))+((new_r10*x647))+(((-1.0)*new_r20*x645)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "705f0cd0345a9f97fa531c455c6815bb"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
