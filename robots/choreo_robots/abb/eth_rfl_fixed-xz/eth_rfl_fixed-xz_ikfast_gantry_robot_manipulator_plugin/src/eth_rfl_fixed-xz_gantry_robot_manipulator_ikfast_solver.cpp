/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2018-09-13 19:41:00.324221
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50;
x0=IKcos(j[1]);
x1=IKsin(j[2]);
x2=IKsin(j[3]);
x3=IKcos(j[2]);
x4=IKcos(j[3]);
x5=IKcos(j[5]);
x6=IKsin(j[5]);
x7=IKsin(j[4]);
x8=IKcos(j[4]);
x9=IKsin(j[1]);
x10=IKsin(j[6]);
x11=IKcos(j[6]);
x12=((0.15)*x1);
x13=((1.38)*x3);
x14=((1.0)*x6);
x15=((0.14)*x3);
x16=((1.0)*x0);
x17=((1.0)*x7);
x18=((1.38)*x2);
x19=((0.14)*x9);
x20=((0.15)*x3);
x21=((0.14)*x8);
x22=((1.0)*x2);
x23=((1.0)*x3);
x24=((1.0)*x5);
x25=(x4*x9);
x26=(x1*x4);
x27=(x0*x4);
x28=(x0*x1);
x29=(x1*x2);
x30=(x6*x8);
x31=(x8*x9);
x32=(x0*x7);
x33=(x1*x9);
x34=(x23*x4);
x35=(x22*x9);
x36=(x0*x2*x3);
x37=(x16*x3*x4);
x38=(x22*x33);
x39=((((-1.0)*x34))+x29);
x40=((((-1.0)*x1*x22))+x34);
x41=(((x22*x3))+(((1.0)*x26)));
x42=(((x0*x26))+x36);
IkReal x51=((1.0)*x16);
x43=((((-1.0)*x26*x51))+(((-1.0)*x2*x3*x51)));
x44=((((1.0)*x1*x25))+((x3*x35)));
x45=((-1.0)*x44);
x46=(((x7*x9))+((x42*x8)));
x47=(x32+((x45*x8)));
x48=(((x41*x6))+((x39*x5*x8)));
x49=(((x14*(((((-1.0)*x37))+((x16*x29))))))+(((-1.0)*x24*x46)));
x50=(((x14*(((((-1.0)*x38))+((x23*x25))))))+(((-1.0)*x24*x47)));
eerot[0]=(((x46*x6))+((x5*(((((-1.0)*x37))+((x2*x28)))))));
eerot[1]=(((x10*x49))+((x11*((x31+((x43*x7)))))));
eerot[2]=(((x10*(((((-1.0)*x31))+(((-1.0)*x17*x43))))))+((x11*x49)));
IkReal x52=((1.0)*x27);
eetrans[0]=((0.545)+((x18*x28))+(((-1.0)*x0*x2*x20))+(((-1.0)*x13*x52))+(((-1.0)*x12*x52))+((x5*(((((0.14)*x2*x28))+(((-1.0)*x15*x52))))))+(((-0.2)*x0))+((x6*((((x19*x7))+((x21*x42))))))+(((-0.89)*x28)));
eerot[3]=(((x47*x6))+((x5*(((((-1.0)*x38))+((x25*x3)))))));
eerot[4]=(((x10*x50))+((x11*((((x0*x8))+((x44*x7)))))));
eerot[5]=(((x10*(((((-1.0)*x16*x8))+(((-1.0)*x17*x44))))))+((x11*x50)));
eetrans[1]=((-0.0075)+(((0.2)*x9))+(((-1.0)*x18*x33))+((x5*(((((-1.0)*x19*x29))+((x15*x25))))))+((x6*((((x21*x45))+(((0.14)*x32))))))+(((0.89)*x33))+((x2*x20*x9))+((x12*x25))+((x13*x25))+j[0]);
eerot[6]=(((x41*x5))+((x30*x40)));
eerot[7]=(((x10*x48))+((x11*x39*x7)));
eerot[8]=(((x11*x48))+((x10*x40*x7)));
eetrans[2]=((-2.88)+(((1.38)*x26))+((x30*(((((-0.14)*x29))+((x15*x4))))))+((x5*(((((0.14)*x26))+((x15*x2))))))+(((-1.0)*x20*x4))+((x12*x2))+(((-0.89)*x3))+((x13*x2)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j2,cj2,sj2,htj2,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij2[2], _nj2;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij2[0] = -1; _ij2[1] = -1; _nj2 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]), htj2=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
new_px=((-0.545)+px+(((-0.14)*r00)));
new_r10=r22;
new_r11=((-1.0)*r21);
new_r12=((-1.0)*r20);
new_py=((-2.2)+(((0.14)*r20))+(((-1.0)*pz)));
new_r20=((-1.0)*r12);
new_r21=r11;
new_r22=r10;
new_pz=((0.0075)+(((-0.14)*r10))+py);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x53=((1.0)*px);
IkReal x54=((1.0)*pz);
IkReal x55=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x55))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x54)));
rxp0_2=((((-1.0)*r10*x53))+((py*r00)));
rxp1_0=((((-1.0)*r21*x55))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x54)));
rxp1_2=((((-1.0)*r11*x53))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x55)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x54)));
rxp2_2=((((-1.0)*r12*x53))+((py*r02)));
{
IkReal j3eval[1];
j3eval[0]=((sj2*sj2)+(cj2*cj2));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1, j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x56=((((-1.38)*sj2))+(((0.15)*cj2)));
IkReal x57=((((-1.38)*cj2))+(((-0.15)*sj2)));
CheckValue<IkReal> x60 = IKatan2WithCheck(IkReal(x56),IkReal(x57),IKFAST_ATAN2_MAGTHRESH);
if(!x60.valid){
continue;
}
IkReal x58=((1.0)*(x60.value));
if((((x57*x57)+(x56*x56))) < -0.00001)
continue;
CheckValue<IkReal> x61=IKPowWithIntegerCheck(IKabs(IKsqrt(((x57*x57)+(x56*x56)))),-1);
if(!x61.valid){
continue;
}
if( (((x61.value)*(((0.68)+(((0.89)*cj2))+(((-1.0)*py)))))) < -1-IKFAST_SINCOS_THRESH || (((x61.value)*(((0.68)+(((0.89)*cj2))+(((-1.0)*py)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x59=IKasin(((x61.value)*(((0.68)+(((0.89)*cj2))+(((-1.0)*py))))));
j3array[0]=((((-1.0)*x58))+(((-1.0)*x59)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+x59+(((-1.0)*x58)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
if((((3.2214)+(((-1.8168)*cj3*sj2))+(((0.267)*cj3))+(((-0.756)*sj2*sj3))+(((0.756)*cj2*cj3))+(((-1.0)*pp))+(pz*pz)+(((1.2104)*cj2))+(((-1.8168)*cj2*sj3))+(((-2.4564)*sj3))+(((0.356)*sj2)))) < -0.00001)
continue;
IkReal x62=IKsqrt(((3.2214)+(((-1.8168)*cj3*sj2))+(((0.267)*cj3))+(((-0.756)*sj2*sj3))+(((0.756)*cj2*cj3))+(((-1.0)*pp))+(pz*pz)+(((1.2104)*cj2))+(((-1.8168)*cj2*sj3))+(((-2.4564)*sj3))+(((0.356)*sj2))));
j0array[0]=(pz+x62);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=(pz+(((-1.0)*x62)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0valid[0] = true;
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j1eval[3];
IkReal x63=(cj3*sj2);
IkReal x64=(cj2*sj3);
IkReal x65=(cj2*cj3);
IkReal x66=(sj2*sj3);
j1eval[0]=((1.33333333333333)+(((5.93333333333333)*sj2))+(((9.2)*x65))+x63+x64+(((-9.2)*x66)));
j1eval[1]=IKsign(((0.2)+(((-1.38)*x66))+(((1.38)*x65))+(((0.89)*sj2))+(((0.15)*x63))+(((0.15)*x64))));
j1eval[2]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x67=((1.0)*cj2);
IkReal x68=((((2.0)*cj2*j0*pz))+(((-1.0)*x67*(j0*j0)))+((cj2*(py*py)))+(((-1.0)*pp*x67)));
j1eval[0]=x68;
j1eval[1]=IKsign(x68);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x69=((((-1.0)*sj2*(py*py)))+((sj2*(j0*j0)))+((pp*sj2))+(((-2.0)*j0*pz*sj2)));
j1eval[0]=x69;
j1eval[1]=IKsign(x69);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=0;
cj2=1.0;
j2=0;
j1eval[0]=((-1.54826086956522)+(((1.39630434782609)*sj3))+py);
j1eval[1]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
j1eval[2]=IKsign(((-14.244)+(((12.846)*sj3))+(((9.2)*py))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=0;
cj2=1.0;
j2=0;
IkReal x70=((0.15)*sj3);
IkReal x71=((1.38)*cj3);
IkReal x72=((((-1.0)*(j0*j0)))+(py*py)+(((-1.0)*pp))+(((2.0)*j0*pz)));
j1eval[0]=x72;
j1eval[1]=((((0.01)*(IKabs(((((20.0)*px))+(((138.0)*cj3*px))+(((15.0)*px*sj3)))))))+(IKabs(((((-0.2)*pz))+((j0*x71))+((j0*x70))+(((0.2)*j0))+(((-1.0)*pz*x70))+(((-1.0)*pz*x71))))));
j1eval[2]=IKsign(x72);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=0;
cj2=1.0;
j2=0;
j1eval[0]=((1.33333333333333)+sj3+(((9.2)*cj3)));
j1eval[1]=((-1.54826086956522)+(((1.39630434782609)*sj3))+py);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.60710784109209)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((149253731.343284)*j0))+(((-149253731.343284)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((149253731.343284)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((149253731.343284)*j0))+(((-149253731.343284)*pz))))+IKsqr(((149253731.343284)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((149253731.343284)*j0))+(((-149253731.343284)*pz))), ((149253731.343284)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x73=IKcos(j1);
IkReal x74=IKsin(j1);
IkReal x75=((1.0)*pz);
IkReal x76=((1.0)*x74);
IkReal x77=(px*x73);
IkReal x78=((0.4)*x74);
evalcond[0]=(px+(((-6.7e-9)*x73)));
evalcond[1]=((((-1.0)*x75))+(((-6.7e-9)*x74))+j0);
evalcond[2]=((((-1.0)*px*x76))+((j0*x73))+(((-1.0)*x73*x75)));
evalcond[3]=((-6.7e-9)+(((-1.0)*x74*x75))+((j0*x74))+x77);
evalcond[4]=((2.68e-9)+((pz*x78))+(((-1.0)*j0*x78))+(((-0.4)*x77)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.823649022813)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-9506685396.70609)*j0))+(((9506685396.70609)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-9506685396.70609)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-9506685396.70609)*j0))+(((9506685396.70609)*pz))))+IKsqr(((-9506685396.70609)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-9506685396.70609)*j0))+(((9506685396.70609)*pz))), ((-9506685396.70609)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x650=IKcos(j1);
IkReal x651=IKsin(j1);
IkReal x652=((1.0)*pz);
IkReal x653=((1.0)*x651);
IkReal x654=(px*x650);
IkReal x655=((0.4)*x651);
evalcond[0]=((((1.05189133569781e-10)*x650))+px);
evalcond[1]=((((1.05189133569781e-10)*x651))+(((-1.0)*x652))+j0);
evalcond[2]=((((-1.0)*px*x653))+((j0*x650))+(((-1.0)*x650*x652)));
evalcond[3]=((1.05189133569781e-10)+(((-1.0)*x651*x652))+((j0*x651))+x654);
evalcond[4]=((-4.20756534279123e-11)+(((-0.4)*x654))+((pz*x655))+(((-1.0)*j0*x655)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst0=((1.10882765063055)+(((-0.716176241631636)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.10882765063055)+(((0.716176241631636)*py))+sj3)))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
IkReal x656=((0.71617624)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=((1.10882765)+(((-1.0)*x656)));
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
cj3=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))));
if( (((1.10882765)+(((-1.0)*x656)))) < -1-IKFAST_SINCOS_THRESH || (((1.10882765)+(((-1.0)*x656)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((1.0)*(IKasin(((1.10882765)+(((-1.0)*x656))))));
IkReal gconst0=((1.10882765063055)+(((-0.716176241631636)*py)));
j1eval[0]=((-1.0)+(((2.58765432098765)*py)));
j1eval[1]=IKsign(((-8.1e-9)+(((2.096e-8)*py))));
j1eval[2]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x657=((0.71617624)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=((1.10882765)+(((-1.0)*x657)));
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
cj3=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))));
if( (((1.10882765)+(((-1.0)*x657)))) < -1-IKFAST_SINCOS_THRESH || (((1.10882765)+(((-1.0)*x657)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((1.0)*(IKasin(((1.10882765)+(((-1.0)*x657))))));
IkReal gconst0=((1.10882765063055)+(((-0.716176241631636)*py)));
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
j1eval[0]=((3.41000000688843)+(((-1.0)*py))+(((12.8460000292665)*(IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))))))));
j1eval[1]=((-1.0)+(((2.58765432098765)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x658=((0.71617624)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=((1.10882765)+(((-1.0)*x658)));
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
cj3=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))));
if( (((1.10882765)+(((-1.0)*x658)))) < -1-IKFAST_SINCOS_THRESH || (((1.10882765)+(((-1.0)*x658)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((1.0)*(IKasin(((1.10882765)+(((-1.0)*x658))))));
IkReal gconst0=((1.10882765063055)+(((-0.716176241631636)*py)));
IkReal x659=((2.58765432098765)*py);
j1eval[0]=(((j0*x659))+pz+(((-1.0)*pz*x659))+(((-1.0)*j0)));
j1eval[1]=((-1.0)+x659);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j0))+(IKabs(pz)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x660=((0.71617624)*py);
IkReal x661=py*py;
IkReal x662=((-1.0)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=((1.10882765)+(((-1.0)*x660)));
if((((-0.229498758802857)+(((1.58823203889164)*py))+(((-0.512908409077616)*x661)))) < -0.00001)
continue;
cj3=IKsqrt(((-0.229498758802857)+(((1.58823203889164)*py))+(((-0.512908409077616)*x661))));
if( (((1.10882765)+(((-1.0)*x660)))) < -1-IKFAST_SINCOS_THRESH || (((1.10882765)+(((-1.0)*x660)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((1.0)*(IKasin(((1.10882765)+(((-1.0)*x660))))));
pz=0;
j0=0;
pp=((px*px)+x661);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x662);
rxp0_1=(px*r20);
rxp1_0=(r21*x662);
rxp1_1=(px*r21);
rxp2_0=(r22*x662);
rxp2_1=(px*r22);
IkReal gconst0=((1.10882765063055)+(((-0.716176241631636)*py)));
j1eval[0]=((-1.0)+(((2.58765432098765)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x663=((0.71617624)*py);
IkReal x664=py*py;
IkReal x665=((-1.0)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=((1.10882765)+(((-1.0)*x663)));
if((((-0.229498758802857)+(((1.58823203889164)*py))+(((-0.512908409077616)*x664)))) < -0.00001)
continue;
cj3=IKsqrt(((-0.229498758802857)+(((1.58823203889164)*py))+(((-0.512908409077616)*x664))));
if( (((-1.10882765)+x663)) < -1-IKFAST_SINCOS_THRESH || (((-1.10882765)+x663)) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((-1.0)*(IKasin(((-1.10882765)+x663))));
pz=0;
j0=0;
pp=((px*px)+x664);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x665);
rxp0_1=(px*r20);
rxp1_0=(r21*x665);
rxp1_1=(px*r21);
rxp2_0=(r22*x665);
rxp2_1=(px*r22);
IkReal gconst0=((1.10882765063055)+(((-0.716176241631636)*py)));
j1eval[0]=px;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x667=IKPowWithIntegerCheck(px,-1);
if(!x667.valid){
continue;
}
IkReal x666=x667.value;
cj1array[0]=((((-2.5)*x666*(py*py)))+(((-2.5)*px))+(((-1.445)*x666))+(((7.85)*py*x666)));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x668=IKcos(j1);
IkReal x669=IKsin(j1);
IkReal x670=((0.107426436)*py);
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
IkReal x671=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))));
IkReal x672=((1.38)*x671);
evalcond[0]=((-1.0)*px*x669);
evalcond[1]=(px+(((2.096e-8)*py*x668))+(((-8.1e-9)*x668)));
evalcond[2]=((0.3663241475)+((px*x668))+x672+(((-1.0)*x670)));
evalcond[3]=(((x669*x672))+(((-1.0)*x669*x670))+(((0.3663241475)*x669)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x673=IKPowWithIntegerCheck(((-8.1e-9)+(((2.096e-8)*py))),-1);
if(!x673.valid){
continue;
}
cj1array[0]=((-1.0)*px*(x673.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x674=py*py;
IkReal x675=IKcos(j1);
IkReal x676=IKsin(j1);
IkReal x677=((0.107426436)*py);
IkReal x678=(px*x675);
if((((-0.229498758802857)+(((-0.512908409077616)*x674))+(((1.58823203889164)*py)))) < -0.00001)
continue;
IkReal x679=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*x674))+(((1.58823203889164)*py))));
IkReal x680=((1.38)*x679);
evalcond[0]=((-1.0)*px*x676);
evalcond[1]=((-0.578)+(((-1.0)*(px*px)))+(((3.14)*py))+(((-1.0)*x674))+(((-0.4)*x678)));
evalcond[2]=((0.3663241475)+x678+x680+(((-1.0)*x677)));
evalcond[3]=((((0.3663241475)*x676))+((x676*x680))+(((-1.0)*x676*x677)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x681=py*py;
IkReal x682=((2.096e-8)*py);
if((((-0.229498758802857)+(((-0.512908409077616)*x681))+(((1.58823203889164)*py)))) < -0.00001)
continue;
IkReal x683=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*x681))+(((1.58823203889164)*py))));
CheckValue<IkReal> x684=IKPowWithIntegerCheck((((j0*x682))+(((-8.1e-9)*j0))+(((8.1e-9)*pz))+(((-1.0)*pz*x682))),-1);
if(!x684.valid){
continue;
}
CheckValue<IkReal> x685=IKPowWithIntegerCheck(((-8.1e-9)+x682),-1);
if(!x685.valid){
continue;
}
if( IKabs(((x684.value)*(((2.96722559475e-9)+(((1.1178e-8)*x683))+(px*px)+(((-8.5483082632e-9)*py))+(((-2.89248e-8)*py*x683))+(((2.25165809856e-9)*x681)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x685.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x684.value)*(((2.96722559475e-9)+(((1.1178e-8)*x683))+(px*px)+(((-8.5483082632e-9)*py))+(((-2.89248e-8)*py*x683))+(((2.25165809856e-9)*x681))))))+IKsqr(((-1.0)*px*(x685.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x684.value)*(((2.96722559475e-9)+(((1.1178e-8)*x683))+(px*px)+(((-8.5483082632e-9)*py))+(((-2.89248e-8)*py*x683))+(((2.25165809856e-9)*x681))))), ((-1.0)*px*(x685.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x686=IKcos(j1);
IkReal x687=IKsin(j1);
IkReal x688=((1.0)*pz);
IkReal x689=((0.107426436)*py);
IkReal x690=(pz*x687);
IkReal x691=(px*x686);
IkReal x692=(j0*x687);
IkReal x693=x683;
IkReal x694=((1.38)*x693);
evalcond[0]=((((-8.1e-9)*x686))+px+(((2.096e-8)*py*x686)));
evalcond[1]=(((j0*x686))+(((-1.0)*px*x687))+(((-1.0)*x686*x688)));
evalcond[2]=((((-1.0)*x687*x689))+(((0.3663241475)*x687))+(((-1.0)*x688))+((x687*x694))+j0);
evalcond[3]=((0.3663241475)+(((-1.0)*x687*x688))+(((-1.0)*x689))+x694+x691+x692);
evalcond[4]=((-0.578)+(((3.14)*py))+(((-1.0)*(j0*j0)))+(((-0.4)*x691))+(((-0.4)*x692))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((0.4)*x690)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
CheckValue<IkReal> x695=IKPowWithIntegerCheck(((0.3663241475)+(((1.38)*(IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))))))+(((-0.107426436)*py))),-1);
if(!x695.valid){
continue;
}
CheckValue<IkReal> x696=IKPowWithIntegerCheck(((-8.1e-9)+(((2.096e-8)*py))),-1);
if(!x696.valid){
continue;
}
if( IKabs(((x695.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x696.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x695.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x696.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x695.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x696.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x697=IKcos(j1);
IkReal x698=IKsin(j1);
IkReal x699=((1.0)*pz);
IkReal x700=((0.107426436)*py);
IkReal x701=(pz*x698);
IkReal x702=(px*x697);
IkReal x703=(j0*x698);
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
IkReal x704=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))));
IkReal x705=((1.38)*x704);
evalcond[0]=((((2.096e-8)*py*x697))+px+(((-8.1e-9)*x697)));
evalcond[1]=((((-1.0)*px*x698))+((j0*x697))+(((-1.0)*x697*x699)));
evalcond[2]=((((0.3663241475)*x698))+(((-1.0)*x699))+((x698*x705))+(((-1.0)*x698*x700))+j0);
evalcond[3]=((0.3663241475)+(((-1.0)*x700))+(((-1.0)*x698*x699))+x702+x703+x705);
evalcond[4]=((-0.578)+(((0.4)*x701))+(((3.14)*py))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.4)*x702))+(((-0.4)*x703)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x706=IKPowWithIntegerCheck(IKsign(((-8.1e-9)+(((2.096e-8)*py)))),-1);
if(!x706.valid){
continue;
}
CheckValue<IkReal> x707 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x707.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x706.value)))+(x707.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x708=IKcos(j1);
IkReal x709=IKsin(j1);
IkReal x710=((1.0)*pz);
IkReal x711=((0.107426436)*py);
IkReal x712=(pz*x709);
IkReal x713=(px*x708);
IkReal x714=(j0*x709);
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
IkReal x715=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))));
IkReal x716=((1.38)*x715);
evalcond[0]=((((2.096e-8)*py*x708))+(((-8.1e-9)*x708))+px);
evalcond[1]=((((-1.0)*px*x709))+((j0*x708))+(((-1.0)*x708*x710)));
evalcond[2]=((((0.3663241475)*x709))+(((-1.0)*x709*x711))+((x709*x716))+(((-1.0)*x710))+j0);
evalcond[3]=((0.3663241475)+(((-1.0)*x709*x710))+(((-1.0)*x711))+x713+x714+x716);
evalcond[4]=((-0.578)+(((0.4)*x712))+(((3.14)*py))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.4)*x713))+(((-0.4)*x714)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst0=((1.10882765063055)+(((-0.716176241631636)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.10882765063055)+(((0.716176241631636)*py))+sj3)))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
IkReal x717=((0.71617624)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=((1.10882765)+(((-1.0)*x717)));
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))))));
if( (((-1.10882765)+x717)) < -1-IKFAST_SINCOS_THRESH || (((-1.10882765)+x717)) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(IKasin(((-1.10882765)+x717))));
IkReal gconst0=((1.10882765063055)+(((-0.716176241631636)*py)));
j1eval[0]=((-1.0)+(((2.58765432098765)*py)));
j1eval[1]=IKsign(((-8.1e-9)+(((2.096e-8)*py))));
j1eval[2]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x718=((0.71617624)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=((1.10882765)+(((-1.0)*x718)));
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))))));
if( (((1.10882765)+(((-1.0)*x718)))) < -1-IKFAST_SINCOS_THRESH || (((1.10882765)+(((-1.0)*x718)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(((1.10882765)+(((-1.0)*x718))))))));
IkReal gconst0=((1.10882765063055)+(((-0.716176241631636)*py)));
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
j1eval[0]=((3.41000000688843)+(((-12.8460000292665)*(IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))))))+(((-1.0)*py)));
j1eval[1]=((-1.0)+(((2.58765432098765)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x719=((0.71617624)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=((1.10882765)+(((-1.0)*x719)));
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))))));
if( (((1.10882765)+(((-1.0)*x719)))) < -1-IKFAST_SINCOS_THRESH || (((1.10882765)+(((-1.0)*x719)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(((1.10882765)+(((-1.0)*x719))))))));
IkReal gconst0=((1.10882765063055)+(((-0.716176241631636)*py)));
IkReal x720=((2.58765432098765)*py);
j1eval[0]=(pz+((j0*x720))+(((-1.0)*j0))+(((-1.0)*pz*x720)));
j1eval[1]=((-1.0)+x720);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j0))+(IKabs(pz)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x721=((0.71617624)*py);
IkReal x722=py*py;
IkReal x723=((-1.0)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=((1.10882765)+(((-1.0)*x721)));
if((((-0.229498758802857)+(((-0.512908409077616)*x722))+(((1.58823203889164)*py)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*x722))+(((1.58823203889164)*py))))));
if( (((1.10882765)+(((-1.0)*x721)))) < -1-IKFAST_SINCOS_THRESH || (((1.10882765)+(((-1.0)*x721)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(((1.10882765)+(((-1.0)*x721))))))));
pz=0;
j0=0;
pp=((px*px)+x722);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x723);
rxp0_1=(px*r20);
rxp1_0=(r21*x723);
rxp1_1=(px*r21);
rxp2_0=(r22*x723);
rxp2_1=(px*r22);
IkReal gconst0=((1.10882765063055)+(((-0.716176241631636)*py)));
j1eval[0]=((-1.0)+(((2.58765432098765)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x724=((0.71617624)*py);
IkReal x725=py*py;
IkReal x726=((-1.0)*py);
sj2=0;
cj2=1.0;
j2=0;
sj3=((1.10882765)+(((-1.0)*x724)));
if((((-0.229498758802857)+(((-0.512908409077616)*x725))+(((1.58823203889164)*py)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*x725))+(((1.58823203889164)*py))))));
if( (((1.10882765)+(((-1.0)*x724)))) < -1-IKFAST_SINCOS_THRESH || (((1.10882765)+(((-1.0)*x724)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(((1.10882765)+(((-1.0)*x724))))))));
pz=0;
j0=0;
pp=((px*px)+x725);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x726);
rxp0_1=(px*r20);
rxp1_0=(r21*x726);
rxp1_1=(px*r21);
rxp2_0=(r22*x726);
rxp2_1=(px*r22);
IkReal gconst0=((1.10882765063055)+(((-0.716176241631636)*py)));
j1eval[0]=px;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x728=IKPowWithIntegerCheck(px,-1);
if(!x728.valid){
continue;
}
IkReal x727=x728.value;
cj1array[0]=((((-2.5)*px))+(((7.85)*py*x727))+(((-1.445)*x727))+(((-2.5)*x727*(py*py))));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x729=IKcos(j1);
IkReal x730=IKsin(j1);
IkReal x731=((0.107426436)*py);
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
IkReal x732=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))));
IkReal x733=((1.38)*x732);
evalcond[0]=((-1.0)*px*x730);
evalcond[1]=((((2.096e-8)*py*x729))+(((-8.1e-9)*x729))+px);
evalcond[2]=((0.3663241475)+(((-1.0)*x733))+(((-1.0)*x731))+((px*x729)));
evalcond[3]=((((0.3663241475)*x730))+(((-1.0)*x730*x733))+(((-1.0)*x730*x731)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x734=IKPowWithIntegerCheck(((-8.1e-9)+(((2.096e-8)*py))),-1);
if(!x734.valid){
continue;
}
cj1array[0]=((-1.0)*px*(x734.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x735=IKcos(j1);
IkReal x736=py*py;
IkReal x737=IKsin(j1);
IkReal x738=((0.107426436)*py);
IkReal x739=(px*x735);
if((((-0.229498758802857)+(((-0.512908409077616)*x736))+(((1.58823203889164)*py)))) < -0.00001)
continue;
IkReal x740=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*x736))+(((1.58823203889164)*py))));
IkReal x741=((1.38)*x740);
evalcond[0]=((-1.0)*px*x737);
evalcond[1]=((-0.578)+(((-1.0)*(px*px)))+(((3.14)*py))+(((-0.4)*x739))+(((-1.0)*x736)));
evalcond[2]=((0.3663241475)+(((-1.0)*x738))+x739+(((-1.0)*x741)));
evalcond[3]=((((0.3663241475)*x737))+(((-1.0)*x737*x741))+(((-1.0)*x737*x738)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x742=py*py;
IkReal x743=((2.096e-8)*py);
if((((-0.229498758802857)+(((-0.512908409077616)*x742))+(((1.58823203889164)*py)))) < -0.00001)
continue;
IkReal x744=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*x742))+(((1.58823203889164)*py))));
CheckValue<IkReal> x745=IKPowWithIntegerCheck((((j0*x743))+(((-1.0)*pz*x743))+(((-8.1e-9)*j0))+(((8.1e-9)*pz))),-1);
if(!x745.valid){
continue;
}
CheckValue<IkReal> x746=IKPowWithIntegerCheck(((-8.1e-9)+x743),-1);
if(!x746.valid){
continue;
}
if( IKabs(((x745.value)*(((2.96722559475e-9)+(((2.89248e-8)*py*x744))+(px*px)+(((-8.5483082632e-9)*py))+(((-1.1178e-8)*x744))+(((2.25165809856e-9)*x742)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x746.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x745.value)*(((2.96722559475e-9)+(((2.89248e-8)*py*x744))+(px*px)+(((-8.5483082632e-9)*py))+(((-1.1178e-8)*x744))+(((2.25165809856e-9)*x742))))))+IKsqr(((-1.0)*px*(x746.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x745.value)*(((2.96722559475e-9)+(((2.89248e-8)*py*x744))+(px*px)+(((-8.5483082632e-9)*py))+(((-1.1178e-8)*x744))+(((2.25165809856e-9)*x742))))), ((-1.0)*px*(x746.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x747=IKcos(j1);
IkReal x748=IKsin(j1);
IkReal x749=((1.0)*pz);
IkReal x750=((0.107426436)*py);
IkReal x751=(pz*x748);
IkReal x752=(px*x747);
IkReal x753=(j0*x748);
IkReal x754=x744;
IkReal x755=((1.38)*x754);
evalcond[0]=((((-8.1e-9)*x747))+(((2.096e-8)*py*x747))+px);
evalcond[1]=(((j0*x747))+(((-1.0)*x747*x749))+(((-1.0)*px*x748)));
evalcond[2]=((((0.3663241475)*x748))+(((-1.0)*x749))+(((-1.0)*x748*x755))+(((-1.0)*x748*x750))+j0);
evalcond[3]=((0.3663241475)+x753+x752+(((-1.0)*x750))+(((-1.0)*x755))+(((-1.0)*x748*x749)));
evalcond[4]=((-0.578)+(((-0.4)*x753))+(((-0.4)*x752))+(((3.14)*py))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((0.4)*x751)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
CheckValue<IkReal> x756=IKPowWithIntegerCheck(((0.3663241475)+(((-1.38)*(IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))))))+(((-0.107426436)*py))),-1);
if(!x756.valid){
continue;
}
CheckValue<IkReal> x757=IKPowWithIntegerCheck(((-8.1e-9)+(((2.096e-8)*py))),-1);
if(!x757.valid){
continue;
}
if( IKabs(((x756.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x757.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x756.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x757.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x756.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x757.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x758=IKcos(j1);
IkReal x759=IKsin(j1);
IkReal x760=((1.0)*pz);
IkReal x761=((0.107426436)*py);
IkReal x762=(pz*x759);
IkReal x763=(px*x758);
IkReal x764=(j0*x759);
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
IkReal x765=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))));
IkReal x766=((1.38)*x765);
evalcond[0]=((((-8.1e-9)*x758))+px+(((2.096e-8)*py*x758)));
evalcond[1]=((((-1.0)*x758*x760))+(((-1.0)*px*x759))+((j0*x758)));
evalcond[2]=((((-1.0)*x760))+(((0.3663241475)*x759))+j0+(((-1.0)*x759*x766))+(((-1.0)*x759*x761)));
evalcond[3]=((0.3663241475)+(((-1.0)*x761))+(((-1.0)*x766))+x764+x763+(((-1.0)*x759*x760)));
evalcond[4]=((-0.578)+(((3.14)*py))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.4)*x764))+(((-0.4)*x763))+(((0.4)*x762)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x767=IKPowWithIntegerCheck(IKsign(((-8.1e-9)+(((2.096e-8)*py)))),-1);
if(!x767.valid){
continue;
}
CheckValue<IkReal> x768 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x768.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x767.value)))+(x768.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x769=IKcos(j1);
IkReal x770=IKsin(j1);
IkReal x771=((1.0)*pz);
IkReal x772=((0.107426436)*py);
IkReal x773=(pz*x770);
IkReal x774=(px*x769);
IkReal x775=(j0*x770);
if((((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py)))) < -0.00001)
continue;
IkReal x776=IKsqrt(((-0.229498758802857)+(((-0.512908409077616)*(py*py)))+(((1.58823203889164)*py))));
IkReal x777=((1.38)*x776);
evalcond[0]=((((-8.1e-9)*x769))+(((2.096e-8)*py*x769))+px);
evalcond[1]=(((j0*x769))+(((-1.0)*px*x770))+(((-1.0)*x769*x771)));
evalcond[2]=((((0.3663241475)*x770))+(((-1.0)*x771))+(((-1.0)*x770*x777))+(((-1.0)*x770*x772))+j0);
evalcond[3]=((0.3663241475)+x775+x774+(((-1.0)*x777))+(((-1.0)*x772))+(((-1.0)*x770*x771)));
evalcond[4]=((-0.578)+(((-0.4)*x774))+(((-0.4)*x775))+(((3.14)*py))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((0.4)*x773)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x778=IKcos(pz);
IkReal x779=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x780=IKsqrt(((-1.0)*(px*px)));
IkReal x781=IKcos(x780);
IkReal x782=IKsin(x780);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst1=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
IkReal gconst2=(((x779*x781))+((x778*x782)));
IkReal gconst3=(((x778*x781))+(((-1.0)*x779*x782)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))))+(((-1.0)*pz))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x783=IKcos(pz);
IkReal x784=IKsin(pz);
IkReal x785=x780;
IkReal x786=IKcos(x785);
IkReal x787=IKsin(x785);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x788=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
sj2=0;
cj2=1.0;
j2=0;
sj0=gconst2;
cj0=gconst3;
j0=x788;
IkReal gconst1=x788;
IkReal gconst2=(((x783*x787))+((x784*x786)));
IkReal gconst3=(((x783*x786))+(((-1.0)*x784*x787)));
j1eval[0]=IKabs(((14.244)+(((-12.846)*sj3))+px+(((-9.2)*py))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x789=((12.846)*sj3);
IkReal x790=((9.2)*py);
IkReal x791=(x790+x789);
op[0]=((14.244)+(((-1.0)*x791))+px);
op[1]=0;
op[2]=((-14.244)+px+x791);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x792=IKcos(pz);
IkReal x793=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x794=IKsqrt(((-1.0)*(px*px)));
IkReal x795=IKcos(x794);
IkReal x796=IKsin(x794);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst4=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
IkReal gconst5=(((x793*x795))+(((-1.0)*x792*x796)));
IkReal gconst6=(((x793*x796))+((x792*x795)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*pz))+(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x797=IKcos(pz);
IkReal x798=IKsin(pz);
IkReal x799=x794;
IkReal x800=IKcos(x799);
IkReal x801=IKsin(x799);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x802=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
sj2=0;
cj2=1.0;
j2=0;
sj0=gconst5;
cj0=gconst6;
j0=x802;
IkReal gconst4=x802;
IkReal gconst5=((((-1.0)*x797*x801))+((x798*x800)));
IkReal gconst6=(((x797*x800))+((x798*x801)));
j1eval[0]=IKabs(((14.244)+(((-12.846)*sj3))+px+(((-9.2)*py))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x803=((12.846)*sj3);
IkReal x804=((9.2)*py);
IkReal x805=(x804+x803);
op[0]=((14.244)+px+(((-1.0)*x805)));
op[1]=0;
op[2]=((-14.244)+px+x805);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x806=IKPowWithIntegerCheck(((0.2)+(((1.38)*cj3))+(((0.15)*sj3))),-1);
if(!x806.valid){
continue;
}
CheckValue<IkReal> x807=IKPowWithIntegerCheck(((-14.244)+(((12.846)*sj3))+(((9.2)*py))),-1);
if(!x807.valid){
continue;
}
if( IKabs(((x806.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x807.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x806.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x807.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x806.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x807.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x808=IKcos(j1);
IkReal x809=IKsin(j1);
IkReal x810=((1.0)*pz);
IkReal x811=((1.38)*cj3);
IkReal x812=((0.15)*sj3);
IkReal x813=(pz*x809);
IkReal x814=(px*x808);
IkReal x815=(j0*x809);
evalcond[0]=((((-1.0)*x808*x810))+((j0*x808))+(((-1.0)*px*x809)));
evalcond[1]=((((9.2)*py*x808))+px+(((12.846)*sj3*x808))+(((-14.244)*x808)));
evalcond[2]=(((x809*x811))+((x809*x812))+(((0.2)*x809))+(((-1.0)*x810))+j0);
evalcond[3]=((0.2)+(((-1.0)*x809*x810))+x814+x815+x812+x811);
evalcond[4]=((-0.578)+(((3.14)*py))+(((-0.4)*x814))+(((-0.4)*x815))+(((-1.0)*(j0*j0)))+(((0.4)*x813))+(((-1.0)*pp))+(((2.0)*j0*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x816=((0.15)*sj3);
IkReal x817=((1.38)*cj3);
CheckValue<IkReal> x818 = IKatan2WithCheck(IkReal(((((-0.2)*pz))+(((-1.0)*pz*x817))+(((-1.0)*pz*x816))+(((0.2)*j0))+((j0*x816))+((j0*x817)))),IkReal((((px*x816))+((px*x817))+(((0.2)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x818.valid){
continue;
}
CheckValue<IkReal> x819=IKPowWithIntegerCheck(IKsign(((((-1.0)*(j0*j0)))+(py*py)+(((-1.0)*pp))+(((2.0)*j0*pz)))),-1);
if(!x819.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x818.value)+(((1.5707963267949)*(x819.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x820=IKcos(j1);
IkReal x821=IKsin(j1);
IkReal x822=((1.0)*pz);
IkReal x823=((1.38)*cj3);
IkReal x824=((0.15)*sj3);
IkReal x825=(pz*x821);
IkReal x826=(px*x820);
IkReal x827=(j0*x821);
evalcond[0]=(((j0*x820))+(((-1.0)*px*x821))+(((-1.0)*x820*x822)));
evalcond[1]=((((-14.244)*x820))+(((12.846)*sj3*x820))+(((9.2)*py*x820))+px);
evalcond[2]=(((x821*x823))+((x821*x824))+(((-1.0)*x822))+(((0.2)*x821))+j0);
evalcond[3]=((0.2)+(((-1.0)*x821*x822))+x823+x827+x826+x824);
evalcond[4]=((-0.578)+(((-0.4)*x826))+(((-0.4)*x827))+(((3.14)*py))+(((0.4)*x825))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x828 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x828.valid){
continue;
}
CheckValue<IkReal> x829=IKPowWithIntegerCheck(IKsign(((-14.244)+(((12.846)*sj3))+(((9.2)*py)))),-1);
if(!x829.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x828.value)+(((1.5707963267949)*(x829.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x830=IKcos(j1);
IkReal x831=IKsin(j1);
IkReal x832=((1.0)*pz);
IkReal x833=((1.38)*cj3);
IkReal x834=((0.15)*sj3);
IkReal x835=(pz*x831);
IkReal x836=(px*x830);
IkReal x837=(j0*x831);
evalcond[0]=(((j0*x830))+(((-1.0)*px*x831))+(((-1.0)*x830*x832)));
evalcond[1]=((((9.2)*py*x830))+(((12.846)*sj3*x830))+(((-14.244)*x830))+px);
evalcond[2]=(((x831*x834))+((x831*x833))+(((-1.0)*x832))+(((0.2)*x831))+j0);
evalcond[3]=((0.2)+x834+x836+x837+x833+(((-1.0)*x831*x832)));
evalcond[4]=((-0.578)+(((-0.4)*x836))+(((-0.4)*x837))+(((0.4)*x835))+(((3.14)*py))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j1eval[0]=((1.0)+(((-6.02532833020638)*sj3))+(((4.31519699812383)*py)));
j1eval[1]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
j1eval[2]=IKsign(((2.132)+(((-12.846)*sj3))+(((9.2)*py))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x838=((1.38)*cj3);
IkReal x839=((0.15)*sj3);
IkReal x840=((j0*j0)+pp+(((-1.0)*(py*py)))+(((-2.0)*j0*pz)));
j1eval[0]=x840;
j1eval[1]=IKsign(x840);
j1eval[2]=((((0.01)*(IKabs(((((-20.0)*px))+(((138.0)*cj3*px))+(((15.0)*px*sj3)))))))+(IKabs((((j0*x838))+((j0*x839))+(((-1.0)*pz*x838))+(((-1.0)*pz*x839))+(((0.2)*pz))+(((-0.2)*j0))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j1eval[0]=((1.33333333333333)+(((-9.2)*cj3))+(((-1.0)*sj3)));
j1eval[1]=((1.0)+(((-6.02532833020638)*sj3))+(((4.31519699812383)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5344848124977)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((149253731.343284)*j0))+(((-149253731.343284)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((149253731.343284)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((149253731.343284)*j0))+(((-149253731.343284)*pz))))+IKsqr(((149253731.343284)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((149253731.343284)*j0))+(((-149253731.343284)*pz))), ((149253731.343284)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x841=IKcos(j1);
IkReal x842=IKsin(j1);
IkReal x843=((1.0)*px);
IkReal x844=((1.0)*pz);
IkReal x845=(pz*x842);
IkReal x846=(j0*x842);
evalcond[0]=((((-6.7e-9)*x841))+px);
evalcond[1]=((((-6.7e-9)*x842))+(((-1.0)*x844))+j0);
evalcond[2]=((((-1.0)*x841*x844))+(((-1.0)*x842*x843))+((j0*x841)));
evalcond[3]=((6.7e-9)+(((-1.0)*x841*x843))+(((-1.0)*x846))+x845);
evalcond[4]=((2.68e-9)+(((-0.4)*px*x841))+(((-0.4)*x846))+(((0.4)*x845)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.9652416764028)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-9506685396.70609)*j0))+(((9506685396.70609)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-9506685396.70609)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-9506685396.70609)*j0))+(((9506685396.70609)*pz))))+IKsqr(((-9506685396.70609)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-9506685396.70609)*j0))+(((9506685396.70609)*pz))), ((-9506685396.70609)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x847=IKcos(j1);
IkReal x848=IKsin(j1);
IkReal x849=((1.0)*px);
IkReal x850=((1.0)*pz);
IkReal x851=(pz*x848);
IkReal x852=(j0*x848);
evalcond[0]=((((1.05189133569781e-10)*x847))+px);
evalcond[1]=((((-1.0)*x850))+(((1.05189133569781e-10)*x848))+j0);
evalcond[2]=((((-1.0)*x847*x850))+(((-1.0)*x848*x849))+((j0*x847)));
evalcond[3]=((-1.05189133569781e-10)+(((-1.0)*x847*x849))+(((-1.0)*x852))+x851);
evalcond[4]=((-4.20756534279123e-11)+(((-0.4)*px*x847))+(((-0.4)*x852))+(((0.4)*x851)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst8=((0.165966059473766)+(((0.716176241631636)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.165966059473766)+sj3+(((-0.716176241631636)*py)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
IkReal x853=((0.16596606)+(((0.71617624)*py)));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x853;
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
cj3=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))));
if( (x853) < -1-IKFAST_SINCOS_THRESH || (x853) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x853);
IkReal gconst8=((0.165966059473766)+(((0.716176241631636)*py)));
j1eval[0]=((-1.0)+(((3.10059171597633)*py)));
j1eval[1]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
j1eval[2]=IKsign(((-6.76e-9)+(((2.096e-8)*py))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x854=((0.16596606)+(((0.71617624)*py)));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x854;
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
cj3=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))));
if( (x854) < -1-IKFAST_SINCOS_THRESH || (x854) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x854);
IkReal gconst8=((0.165966059473766)+(((0.716176241631636)*py)));
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
j1eval[0]=((1.63000000297878)+(((-12.8460000292665)*(IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))))))+(((-1.0)*py)));
j1eval[1]=((-1.0)+(((3.10059171597633)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x855=((0.16596606)+(((0.71617624)*py)));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x855;
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
cj3=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))));
if( (x855) < -1-IKFAST_SINCOS_THRESH || (x855) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x855);
IkReal gconst8=((0.165966059473766)+(((0.716176241631636)*py)));
IkReal x856=((3.10059171597633)*py);
j1eval[0]=((((-1.0)*pz))+j0+(((-1.0)*j0*x856))+((pz*x856)));
j1eval[1]=((-1.0)+x856);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j0))+(IKabs(pz)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x857=py*py;
IkReal x858=((0.16596606)+(((0.71617624)*py)));
IkReal x859=((-1.0)*py);
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x858;
if((((0.97245526710275)+(((-0.512908409077616)*x857))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
cj3=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*x857))+(((-0.237721897424669)*py))));
if( (x858) < -1-IKFAST_SINCOS_THRESH || (x858) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x858);
pz=0;
j0=0;
pp=((px*px)+x857);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x859);
rxp0_1=(px*r20);
rxp1_0=(r21*x859);
rxp1_1=(px*r21);
rxp2_0=(r22*x859);
rxp2_1=(px*r22);
IkReal gconst8=((0.165966059473766)+(((0.716176241631636)*py)));
j1eval[0]=((-1.0)+(((3.10059171597633)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x860=py*py;
IkReal x861=((0.16596606)+(((0.71617624)*py)));
IkReal x862=((-1.0)*py);
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x861;
if((((0.97245526710275)+(((-0.512908409077616)*x860))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
cj3=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*x860))+(((-0.237721897424669)*py))));
if( (x861) < -1-IKFAST_SINCOS_THRESH || (x861) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=IKasin(x861);
pz=0;
j0=0;
pp=((px*px)+x860);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x862);
rxp0_1=(px*r20);
rxp1_0=(r21*x862);
rxp1_1=(px*r21);
rxp2_0=(r22*x862);
rxp2_1=(px*r22);
IkReal gconst8=((0.165966059473766)+(((0.716176241631636)*py)));
j1eval[0]=px;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x864=IKPowWithIntegerCheck(px,-1);
if(!x864.valid){
continue;
}
IkReal x863=x864.value;
cj1array[0]=((((-2.5)*px))+(((-2.5)*x863*(py*py)))+(((-1.05)*py*x863))+(((4.607)*x863)));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x865=IKcos(j1);
IkReal x866=IKsin(j1);
IkReal x867=((0.107426436)*py);
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
IkReal x868=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))));
IkReal x869=((1.38)*x868);
evalcond[0]=((-1.0)*px*x866);
evalcond[1]=((((-6.76e-9)*x865))+px+(((2.096e-8)*py*x865)));
evalcond[2]=((-0.175105091)+(((-1.0)*px*x865))+x869+x867);
evalcond[3]=((((-1.0)*x866*x869))+(((-1.0)*x866*x867))+(((0.175105091)*x866)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x870=IKPowWithIntegerCheck(((-6.76e-9)+(((2.096e-8)*py))),-1);
if(!x870.valid){
continue;
}
cj1array[0]=((-1.0)*px*(x870.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x871=py*py;
IkReal x872=IKcos(j1);
IkReal x873=IKsin(j1);
IkReal x874=((0.107426436)*py);
IkReal x875=(px*x872);
if((((0.97245526710275)+(((-0.512908409077616)*x871))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
IkReal x876=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*x871))+(((-0.237721897424669)*py))));
IkReal x877=((1.38)*x876);
evalcond[0]=((-1.0)*px*x873);
evalcond[1]=((1.8428)+(((-1.0)*(px*px)))+(((-1.0)*x871))+(((-0.4)*x875))+(((-0.42)*py)));
evalcond[2]=((-0.175105091)+(((-1.0)*x875))+x874+x877);
evalcond[3]=((((0.175105091)*x873))+(((-1.0)*x873*x874))+(((-1.0)*x873*x877)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x878=j0*j0;
IkReal x879=(py*pz);
IkReal x880=((1.048e-7)*py);
CheckValue<IkReal> x881=IKPowWithIntegerCheck(((((-4.192e-8)*j0*py))+(((1.352e-8)*j0))+(((4.192e-8)*x879))+(((-1.352e-8)*pz))),-1);
if(!x881.valid){
continue;
}
CheckValue<IkReal> x882=IKPowWithIntegerCheck(((-6.76e-9)+(((2.096e-8)*py))),-1);
if(!x882.valid){
continue;
}
if( IKabs(((x881.value)*(((6.228664e-8)+(((-2.096e-7)*j0*x879))+(((-3.38e-8)*pp))+(((6.76e-8)*j0*pz))+((x878*x880))+(((4.4016e-8)*(py*py)))+((pp*x880))+(((-2.0732144e-7)*py))+(((-3.38e-8)*x878))+(((-2.0)*(px*px))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x882.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x881.value)*(((6.228664e-8)+(((-2.096e-7)*j0*x879))+(((-3.38e-8)*pp))+(((6.76e-8)*j0*pz))+((x878*x880))+(((4.4016e-8)*(py*py)))+((pp*x880))+(((-2.0732144e-7)*py))+(((-3.38e-8)*x878))+(((-2.0)*(px*px)))))))+IKsqr(((-1.0)*px*(x882.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x881.value)*(((6.228664e-8)+(((-2.096e-7)*j0*x879))+(((-3.38e-8)*pp))+(((6.76e-8)*j0*pz))+((x878*x880))+(((4.4016e-8)*(py*py)))+((pp*x880))+(((-2.0732144e-7)*py))+(((-3.38e-8)*x878))+(((-2.0)*(px*px)))))), ((-1.0)*px*(x882.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x883=IKcos(j1);
IkReal x884=IKsin(j1);
IkReal x885=((1.0)*pz);
IkReal x886=((0.107426436)*py);
IkReal x887=(pz*x884);
IkReal x888=((1.0)*x884);
IkReal x889=(px*x883);
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
IkReal x890=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))));
IkReal x891=((1.38)*x890);
evalcond[0]=((((2.096e-8)*py*x883))+px+(((-6.76e-9)*x883)));
evalcond[1]=((((-1.0)*x883*x885))+(((-1.0)*px*x888))+((j0*x883)));
evalcond[2]=((((-1.0)*x884*x891))+(((-1.0)*x885))+(((0.175105091)*x884))+j0+(((-1.0)*x884*x886)));
evalcond[3]=((1.8428)+(((-0.4)*j0*x884))+(((-0.4)*x889))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((0.4)*x887))+(((2.0)*j0*pz))+(((-0.42)*py)));
evalcond[4]=((-0.175105091)+(((-1.0)*x889))+(((-1.0)*j0*x888))+x887+x886+x891);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
CheckValue<IkReal> x892=IKPowWithIntegerCheck(((0.175105091)+(((-1.38)*(IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))))))+(((-0.107426436)*py))),-1);
if(!x892.valid){
continue;
}
CheckValue<IkReal> x893=IKPowWithIntegerCheck(((-6.76e-9)+(((2.096e-8)*py))),-1);
if(!x893.valid){
continue;
}
if( IKabs(((x892.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x893.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x892.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x893.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x892.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x893.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x894=IKcos(j1);
IkReal x895=IKsin(j1);
IkReal x896=((1.0)*pz);
IkReal x897=((0.107426436)*py);
IkReal x898=(pz*x895);
IkReal x899=((1.0)*x895);
IkReal x900=(px*x894);
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
IkReal x901=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))));
IkReal x902=((1.38)*x901);
evalcond[0]=((((2.096e-8)*py*x894))+px+(((-6.76e-9)*x894)));
evalcond[1]=((((-1.0)*x894*x896))+(((-1.0)*px*x899))+((j0*x894)));
evalcond[2]=((((-1.0)*x895*x902))+(((-1.0)*x895*x897))+(((-1.0)*x896))+(((0.175105091)*x895))+j0);
evalcond[3]=((1.8428)+(((-0.4)*j0*x895))+(((-1.0)*(j0*j0)))+(((0.4)*x898))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.4)*x900))+(((-0.42)*py)));
evalcond[4]=((-0.175105091)+(((-1.0)*j0*x899))+(((-1.0)*x900))+x897+x898+x902);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x903 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x903.valid){
continue;
}
CheckValue<IkReal> x904=IKPowWithIntegerCheck(IKsign(((-6.76e-9)+(((2.096e-8)*py)))),-1);
if(!x904.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x903.value)+(((1.5707963267949)*(x904.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x905=IKcos(j1);
IkReal x906=IKsin(j1);
IkReal x907=((1.0)*pz);
IkReal x908=((0.107426436)*py);
IkReal x909=(pz*x906);
IkReal x910=((1.0)*x906);
IkReal x911=(px*x905);
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
IkReal x912=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))));
IkReal x913=((1.38)*x912);
evalcond[0]=((((2.096e-8)*py*x905))+px+(((-6.76e-9)*x905)));
evalcond[1]=((((-1.0)*px*x910))+((j0*x905))+(((-1.0)*x905*x907)));
evalcond[2]=((((-1.0)*x906*x913))+(((-1.0)*x907))+(((0.175105091)*x906))+j0+(((-1.0)*x906*x908)));
evalcond[3]=((1.8428)+(((-0.4)*x911))+(((-1.0)*(j0*j0)))+(((-0.4)*j0*x906))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((0.4)*x909))+(((-0.42)*py)));
evalcond[4]=((-0.175105091)+(((-1.0)*j0*x910))+(((-1.0)*x911))+x913+x908+x909);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst8=((0.165966059473766)+(((0.716176241631636)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.165966059473766)+sj3+(((-0.716176241631636)*py)))))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
IkReal x914=((0.16596606)+(((0.71617624)*py)));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x914;
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))))));
if( (x914) < -1-IKFAST_SINCOS_THRESH || (x914) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x914)))));
IkReal gconst8=((0.165966059473766)+(((0.716176241631636)*py)));
j1eval[0]=((-1.0)+(((3.10059171597633)*py)));
j1eval[1]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
j1eval[2]=IKsign(((-6.76e-9)+(((2.096e-8)*py))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x915=((0.16596606)+(((0.71617624)*py)));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x915;
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))))));
if( (x915) < -1-IKFAST_SINCOS_THRESH || (x915) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x915)))));
IkReal gconst8=((0.165966059473766)+(((0.716176241631636)*py)));
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
j1eval[0]=((1.63000000297878)+(((12.8460000292665)*(IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))))))+(((-1.0)*py)));
j1eval[1]=((-1.0)+(((3.10059171597633)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x916=((0.16596606)+(((0.71617624)*py)));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x916;
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))))));
if( (x916) < -1-IKFAST_SINCOS_THRESH || (x916) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x916)))));
IkReal gconst8=((0.165966059473766)+(((0.716176241631636)*py)));
IkReal x917=((3.10059171597633)*py);
j1eval[0]=(((pz*x917))+(((-1.0)*j0*x917))+(((-1.0)*pz))+j0);
j1eval[1]=((-1.0)+x917);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j0))+(IKabs(pz)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x918=py*py;
IkReal x919=((0.16596606)+(((0.71617624)*py)));
IkReal x920=((-1.0)*py);
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x919;
if((((0.97245526710275)+(((-0.512908409077616)*x918))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.97245526710275)+(((-0.512908409077616)*x918))+(((-0.237721897424669)*py))))));
if( (x919) < -1-IKFAST_SINCOS_THRESH || (x919) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x919)))));
pz=0;
j0=0;
pp=((px*px)+x918);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x920);
rxp0_1=(px*r20);
rxp1_0=(r21*x920);
rxp1_1=(px*r21);
rxp2_0=(r22*x920);
rxp2_1=(px*r22);
IkReal gconst8=((0.165966059473766)+(((0.716176241631636)*py)));
j1eval[0]=((-1.0)+(((3.10059171597633)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x921=py*py;
IkReal x922=((0.16596606)+(((0.71617624)*py)));
IkReal x923=((-1.0)*py);
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=x922;
if((((0.97245526710275)+(((-0.512908409077616)*x921))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
cj3=((-1.0)*(IKsqrt(((0.97245526710275)+(((-0.512908409077616)*x921))+(((-0.237721897424669)*py))))));
if( (x922) < -1-IKFAST_SINCOS_THRESH || (x922) > 1+IKFAST_SINCOS_THRESH )
    continue;
j3=((3.14159265)+(((-1.0)*(IKasin(x922)))));
pz=0;
j0=0;
pp=((px*px)+x921);
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x923);
rxp0_1=(px*r20);
rxp1_0=(r21*x923);
rxp1_1=(px*r21);
rxp2_0=(r22*x923);
rxp2_1=(px*r22);
IkReal gconst8=((0.165966059473766)+(((0.716176241631636)*py)));
j1eval[0]=px;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x925=IKPowWithIntegerCheck(px,-1);
if(!x925.valid){
continue;
}
IkReal x924=x925.value;
cj1array[0]=((((4.607)*x924))+(((-2.5)*px))+(((-1.05)*py*x924))+(((-2.5)*x924*(py*py))));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x926=IKcos(j1);
IkReal x927=IKsin(j1);
IkReal x928=((0.107426436)*py);
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
IkReal x929=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))));
IkReal x930=((1.38)*x929);
evalcond[0]=((-1.0)*px*x927);
evalcond[1]=((((-6.76e-9)*x926))+px+(((2.096e-8)*py*x926)));
evalcond[2]=((-0.175105091)+x928+(((-1.0)*px*x926))+(((-1.0)*x930)));
evalcond[3]=(((x927*x930))+(((0.175105091)*x927))+(((-1.0)*x927*x928)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x931=IKPowWithIntegerCheck(((-6.76e-9)+(((2.096e-8)*py))),-1);
if(!x931.valid){
continue;
}
cj1array[0]=((-1.0)*px*(x931.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x932=IKcos(j1);
IkReal x933=py*py;
IkReal x934=IKsin(j1);
IkReal x935=((0.107426436)*py);
IkReal x936=(px*x932);
if((((0.97245526710275)+(((-0.512908409077616)*x933))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
IkReal x937=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*x933))+(((-0.237721897424669)*py))));
IkReal x938=((1.38)*x937);
evalcond[0]=((-1.0)*px*x934);
evalcond[1]=((1.8428)+(((-1.0)*(px*px)))+(((-0.4)*x936))+(((-1.0)*x933))+(((-0.42)*py)));
evalcond[2]=((-0.175105091)+(((-1.0)*x936))+x935+(((-1.0)*x938)));
evalcond[3]=((((0.175105091)*x934))+(((-1.0)*x934*x935))+((x934*x938)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x939=j0*j0;
IkReal x940=(py*pz);
IkReal x941=((1.048e-7)*py);
CheckValue<IkReal> x942=IKPowWithIntegerCheck(((((4.192e-8)*x940))+(((-4.192e-8)*j0*py))+(((1.352e-8)*j0))+(((-1.352e-8)*pz))),-1);
if(!x942.valid){
continue;
}
CheckValue<IkReal> x943=IKPowWithIntegerCheck(((-6.76e-9)+(((2.096e-8)*py))),-1);
if(!x943.valid){
continue;
}
if( IKabs(((x942.value)*(((6.228664e-8)+(((-3.38e-8)*pp))+(((-3.38e-8)*x939))+((pp*x941))+(((6.76e-8)*j0*pz))+((x939*x941))+(((-2.096e-7)*j0*x940))+(((4.4016e-8)*(py*py)))+(((-2.0732144e-7)*py))+(((-2.0)*(px*px))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x943.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x942.value)*(((6.228664e-8)+(((-3.38e-8)*pp))+(((-3.38e-8)*x939))+((pp*x941))+(((6.76e-8)*j0*pz))+((x939*x941))+(((-2.096e-7)*j0*x940))+(((4.4016e-8)*(py*py)))+(((-2.0732144e-7)*py))+(((-2.0)*(px*px)))))))+IKsqr(((-1.0)*px*(x943.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x942.value)*(((6.228664e-8)+(((-3.38e-8)*pp))+(((-3.38e-8)*x939))+((pp*x941))+(((6.76e-8)*j0*pz))+((x939*x941))+(((-2.096e-7)*j0*x940))+(((4.4016e-8)*(py*py)))+(((-2.0732144e-7)*py))+(((-2.0)*(px*px)))))), ((-1.0)*px*(x943.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x944=IKcos(j1);
IkReal x945=IKsin(j1);
IkReal x946=((1.0)*pz);
IkReal x947=((0.107426436)*py);
IkReal x948=(pz*x945);
IkReal x949=((1.0)*x945);
IkReal x950=(px*x944);
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
IkReal x951=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))));
IkReal x952=((1.38)*x951);
evalcond[0]=((((-6.76e-9)*x944))+px+(((2.096e-8)*py*x944)));
evalcond[1]=((((-1.0)*x944*x946))+(((-1.0)*px*x949))+((j0*x944)));
evalcond[2]=((((-1.0)*x946))+(((-1.0)*x945*x947))+(((0.175105091)*x945))+((x945*x952))+j0);
evalcond[3]=((1.8428)+(((-1.0)*(j0*j0)))+(((-0.4)*x950))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((0.4)*x948))+(((-0.42)*py))+(((-0.4)*j0*x945)));
evalcond[4]=((-0.175105091)+(((-1.0)*j0*x949))+(((-1.0)*x950))+(((-1.0)*x952))+x948+x947);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
CheckValue<IkReal> x953=IKPowWithIntegerCheck(((0.175105091)+(((1.38)*(IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))))))+(((-0.107426436)*py))),-1);
if(!x953.valid){
continue;
}
CheckValue<IkReal> x954=IKPowWithIntegerCheck(((-6.76e-9)+(((2.096e-8)*py))),-1);
if(!x954.valid){
continue;
}
if( IKabs(((x953.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x954.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x953.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x954.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x953.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x954.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x955=IKcos(j1);
IkReal x956=IKsin(j1);
IkReal x957=((1.0)*pz);
IkReal x958=((0.107426436)*py);
IkReal x959=(pz*x956);
IkReal x960=((1.0)*x956);
IkReal x961=(px*x955);
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
IkReal x962=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))));
IkReal x963=((1.38)*x962);
evalcond[0]=((((-6.76e-9)*x955))+(((2.096e-8)*py*x955))+px);
evalcond[1]=((((-1.0)*x955*x957))+(((-1.0)*px*x960))+((j0*x955)));
evalcond[2]=((((0.175105091)*x956))+(((-1.0)*x956*x958))+((x956*x963))+(((-1.0)*x957))+j0);
evalcond[3]=((1.8428)+(((-0.4)*x961))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((0.4)*x959))+(((-0.4)*j0*x956))+(((-0.42)*py)));
evalcond[4]=((-0.175105091)+(((-1.0)*j0*x960))+(((-1.0)*x961))+x959+x958+(((-1.0)*x963)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x964 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x964.valid){
continue;
}
CheckValue<IkReal> x965=IKPowWithIntegerCheck(IKsign(((-6.76e-9)+(((2.096e-8)*py)))),-1);
if(!x965.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x964.value)+(((1.5707963267949)*(x965.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x966=IKcos(j1);
IkReal x967=IKsin(j1);
IkReal x968=((1.0)*pz);
IkReal x969=((0.107426436)*py);
IkReal x970=(pz*x967);
IkReal x971=((1.0)*x967);
IkReal x972=(px*x966);
if((((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py)))) < -0.00001)
continue;
IkReal x973=IKsqrt(((0.97245526710275)+(((-0.512908409077616)*(py*py)))+(((-0.237721897424669)*py))));
IkReal x974=((1.38)*x973);
evalcond[0]=((((-6.76e-9)*x966))+(((2.096e-8)*py*x966))+px);
evalcond[1]=((((-1.0)*px*x971))+(((-1.0)*x966*x968))+((j0*x966)));
evalcond[2]=((((0.175105091)*x967))+(((-1.0)*x967*x969))+((x967*x974))+(((-1.0)*x968))+j0);
evalcond[3]=((1.8428)+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.4)*x972))+(((-0.4)*j0*x967))+(((-0.42)*py))+(((0.4)*x970)));
evalcond[4]=((-0.175105091)+(((-1.0)*x972))+(((-1.0)*j0*x971))+x970+x969+(((-1.0)*x974)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x975=IKcos(pz);
IkReal x976=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x977=IKsqrt(((-1.0)*(px*px)));
IkReal x978=IKcos(x977);
IkReal x979=IKsin(x977);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst9=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
IkReal gconst10=(((x975*x979))+((x976*x978)));
IkReal gconst11=((((-1.0)*x976*x979))+((x975*x978)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))))+(((-1.0)*pz))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x980=IKcos(pz);
IkReal x981=IKsin(pz);
IkReal x982=x977;
IkReal x983=IKcos(x982);
IkReal x984=IKsin(x982);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x985=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj0=gconst10;
cj0=gconst11;
j0=x985;
IkReal gconst9=x985;
IkReal gconst10=(((x981*x983))+((x980*x984)));
IkReal gconst11=(((x980*x983))+(((-1.0)*x981*x984)));
j1eval[0]=IKabs(((-2.132)+(((12.846)*sj3))+px+(((-9.2)*py))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x986=((9.2)*py);
IkReal x987=((12.846)*sj3);
op[0]=((-2.132)+(((-1.0)*x986))+px+x987);
op[1]=0;
op[2]=((2.132)+(((-1.0)*x987))+px+x986);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x988=IKcos(pz);
IkReal x989=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x990=IKsqrt(((-1.0)*(px*px)));
IkReal x991=IKcos(x990);
IkReal x992=IKsin(x990);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst12=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
IkReal gconst13=(((x989*x991))+(((-1.0)*x988*x992)));
IkReal gconst14=(((x989*x992))+((x988*x991)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*pz))+(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x993=IKcos(pz);
IkReal x994=IKsin(pz);
IkReal x995=x990;
IkReal x996=IKcos(x995);
IkReal x997=IKsin(x995);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x998=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj0=gconst13;
cj0=gconst14;
j0=x998;
IkReal gconst12=x998;
IkReal gconst13=((((-1.0)*x993*x997))+((x994*x996)));
IkReal gconst14=(((x993*x996))+((x994*x997)));
j1eval[0]=IKabs(((-2.132)+(((12.846)*sj3))+px+(((-9.2)*py))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x999=((9.2)*py);
IkReal x1000=((12.846)*sj3);
op[0]=((-2.132)+x1000+(((-1.0)*x999))+px);
op[1]=0;
op[2]=((2.132)+(((-1.0)*x1000))+px+x999);
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1001=IKPowWithIntegerCheck(((0.2)+(((-1.38)*cj3))+(((-0.15)*sj3))),-1);
if(!x1001.valid){
continue;
}
CheckValue<IkReal> x1002=IKPowWithIntegerCheck(((2.132)+(((-12.846)*sj3))+(((9.2)*py))),-1);
if(!x1002.valid){
continue;
}
if( IKabs(((x1001.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x1002.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1001.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x1002.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x1001.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x1002.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1003=IKcos(j1);
IkReal x1004=IKsin(j1);
IkReal x1005=((1.0)*pz);
IkReal x1006=((1.38)*cj3);
IkReal x1007=((0.15)*sj3);
IkReal x1008=(pz*x1004);
IkReal x1009=((1.0)*x1004);
IkReal x1010=(px*x1003);
evalcond[0]=(((j0*x1003))+(((-1.0)*x1003*x1005))+(((-1.0)*px*x1009)));
evalcond[1]=((((-12.846)*sj3*x1003))+px+(((9.2)*py*x1003))+(((2.132)*x1003)));
evalcond[2]=((((0.2)*x1004))+(((-1.0)*x1005))+(((-1.0)*x1004*x1007))+(((-1.0)*x1004*x1006))+j0);
evalcond[3]=((-0.2)+x1008+x1007+x1006+(((-1.0)*j0*x1009))+(((-1.0)*x1010)));
evalcond[4]=((1.8428)+(((0.4)*x1008))+(((-1.0)*(j0*j0)))+(((-0.4)*j0*x1004))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.4)*x1010))+(((-0.42)*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1011=((1.38)*cj3);
IkReal x1012=((0.15)*sj3);
CheckValue<IkReal> x1013 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x1012))+(((-1.0)*pz*x1011))+(((0.2)*pz))+(((-0.2)*j0))+((j0*x1011))+((j0*x1012)))),IkReal(((((-0.2)*px))+((px*x1011))+((px*x1012)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1013.valid){
continue;
}
CheckValue<IkReal> x1014=IKPowWithIntegerCheck(IKsign(((j0*j0)+pp+(((-1.0)*(py*py)))+(((-2.0)*j0*pz)))),-1);
if(!x1014.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1013.value)+(((1.5707963267949)*(x1014.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1015=IKcos(j1);
IkReal x1016=IKsin(j1);
IkReal x1017=((1.0)*pz);
IkReal x1018=((1.38)*cj3);
IkReal x1019=((0.15)*sj3);
IkReal x1020=(pz*x1016);
IkReal x1021=((1.0)*x1016);
IkReal x1022=(px*x1015);
evalcond[0]=((((-1.0)*x1015*x1017))+(((-1.0)*px*x1021))+((j0*x1015)));
evalcond[1]=((((2.132)*x1015))+(((-12.846)*sj3*x1015))+px+(((9.2)*py*x1015)));
evalcond[2]=((((-1.0)*x1017))+(((-1.0)*x1016*x1018))+(((-1.0)*x1016*x1019))+(((0.2)*x1016))+j0);
evalcond[3]=((-0.2)+(((-1.0)*j0*x1021))+x1018+x1019+x1020+(((-1.0)*x1022)));
evalcond[4]=((1.8428)+(((0.4)*x1020))+(((-0.4)*x1022))+(((-0.4)*j0*x1016))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.42)*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1023=IKPowWithIntegerCheck(IKsign(((2.132)+(((-12.846)*sj3))+(((9.2)*py)))),-1);
if(!x1023.valid){
continue;
}
CheckValue<IkReal> x1024 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1024.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1023.value)))+(x1024.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1025=IKcos(j1);
IkReal x1026=IKsin(j1);
IkReal x1027=((1.0)*pz);
IkReal x1028=((1.38)*cj3);
IkReal x1029=((0.15)*sj3);
IkReal x1030=(pz*x1026);
IkReal x1031=((1.0)*x1026);
IkReal x1032=(px*x1025);
evalcond[0]=(((j0*x1025))+(((-1.0)*x1025*x1027))+(((-1.0)*px*x1031)));
evalcond[1]=((((2.132)*x1025))+(((9.2)*py*x1025))+(((-12.846)*sj3*x1025))+px);
evalcond[2]=((((-1.0)*x1026*x1028))+(((-1.0)*x1026*x1029))+(((-1.0)*x1027))+(((0.2)*x1026))+j0);
evalcond[3]=((-0.2)+x1030+x1029+x1028+(((-1.0)*x1032))+(((-1.0)*j0*x1031)));
evalcond[4]=((1.8428)+(((0.4)*x1030))+(((-1.0)*(j0*j0)))+(((-0.4)*x1032))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.4)*j0*x1026))+(((-0.42)*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j1eval[0]=((10.708)+(((-12.846)*sj3))+(((-1.0)*py)));
j1eval[1]=IKsign(((1.16391304347826)+(((-1.39630434782609)*sj3))+(((-0.108695652173913)*py))));
j1eval[2]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x1033=((0.15)*cj3);
IkReal x1034=((1.38)*sj3);
IkReal x1035=((j0*j0)+pp+(((-1.0)*(py*py)))+(((-2.0)*j0*pz)));
j1eval[0]=x1035;
j1eval[1]=((((0.01)*(IKabs(((((138.0)*px*sj3))+(((-109.0)*px))+(((-15.0)*cj3*px)))))))+(IKabs((((j0*x1034))+(((-1.0)*pz*x1034))+(((-1.0)*j0*x1033))+(((1.09)*pz))+(((-1.09)*j0))+((pz*x1033))))));
j1eval[2]=IKsign(x1035);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j1eval[0]=((7.26666666666667)+cj3+(((-9.2)*sj3)));
j1eval[1]=((10.708)+(((-12.846)*sj3))+(((-1.0)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((3.93638962261069)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-1197437705.91175)*j0))+(((1197437705.91175)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1197437705.91175)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1197437705.91175)*j0))+(((1197437705.91175)*pz))))+IKsqr(((-1197437705.91175)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1197437705.91175)*j0))+(((1197437705.91175)*pz))), ((-1197437705.91175)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1036=IKcos(j1);
IkReal x1037=IKsin(j1);
IkReal x1038=((1.0)*pz);
IkReal x1039=((1.0)*x1037);
IkReal x1040=(pz*x1037);
IkReal x1041=(px*x1036);
evalcond[0]=(px+(((8.35116511750881e-10)*x1036)));
evalcond[1]=((((-1.0)*x1038))+(((8.35116511750881e-10)*x1037))+j0);
evalcond[2]=(((j0*x1036))+(((-1.0)*x1036*x1038))+(((-1.0)*px*x1039)));
evalcond[3]=((-8.35116511750881e-10)+x1040+(((-1.0)*j0*x1039))+(((-1.0)*x1041)));
evalcond[4]=((-1.82055399561692e-9)+(((-2.18)*x1041))+(((-2.18)*j0*x1037))+(((2.18)*x1040)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.01133815074181)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((200000000.0)*j0))+(((-200000000.0)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((200000000.0)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((200000000.0)*j0))+(((-200000000.0)*pz))))+IKsqr(((200000000.0)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((200000000.0)*j0))+(((-200000000.0)*pz))), ((200000000.0)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1042=IKcos(j1);
IkReal x1043=IKsin(j1);
IkReal x1044=((1.0)*pz);
IkReal x1045=((1.0)*x1043);
IkReal x1046=(px*x1042);
IkReal x1047=(pz*x1043);
evalcond[0]=(px+(((-5.0e-9)*x1042)));
evalcond[1]=((((-5.0e-9)*x1043))+(((-1.0)*x1044))+j0);
evalcond[2]=((((-1.0)*px*x1045))+(((-1.0)*x1042*x1044))+((j0*x1042)));
evalcond[3]=((5.0e-9)+x1047+(((-1.0)*x1046))+(((-1.0)*j0*x1045)));
evalcond[4]=((1.09e-8)+(((-2.18)*x1046))+(((-2.18)*j0*x1043))+(((2.18)*x1047)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst16=((0.8335668690643)+(((-0.0778452436556126)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.8335668690643)+sj3+(((0.0778452436556126)*py)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-372868478.378378)*pz))+(((372868478.378378)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((372868478.378378)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-372868478.378378)*pz))+(((372868478.378378)*j0))))+IKsqr(((372868478.378378)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-372868478.378378)*pz))+(((372868478.378378)*j0))), ((372868478.378378)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1048=IKcos(j1);
IkReal x1049=IKsin(j1);
IkReal x1050=((1.0)*pz);
IkReal x1051=((0.107426436244745)*py);
IkReal x1052=((1.0)*px);
IkReal x1053=(j0*x1049);
IkReal x1054=(pz*x1049);
if((((0.30516627479834)+(((0.129778432051113)*py))+(((-0.0060598819598017)*(py*py))))) < -0.00001)
continue;
IkReal x1055=IKsqrt(((0.30516627479834)+(((0.129778432051113)*py))+(((-0.0060598819598017)*(py*py)))));
IkReal x1056=((0.15)*x1055);
evalcond[0]=(px+(((-2.68191080229963e-9)*x1048)));
evalcond[1]=(((j0*x1048))+(((-1.0)*x1048*x1050))+(((-1.0)*x1049*x1052)));
evalcond[2]=((((-1.0)*x1050))+(((-0.0603222819593289)*x1049))+((x1049*x1056))+((x1049*x1051))+j0);
evalcond[3]=((0.2764)+(((-2.18)*x1053))+(((-2.18)*px*x1048))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((1.36)*py))+(((2.18)*x1054)));
evalcond[4]=((0.0603222819593289)+(((-1.0)*x1056))+(((-1.0)*x1051))+x1054+(((-1.0)*x1053))+(((-1.0)*x1048*x1052)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst16=((0.8335668690643)+(((-0.0778452436556126)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.8335668690643)+sj3+(((0.0778452436556126)*py)))))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-372868478.378378)*pz))+(((372868478.378378)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((372868478.378378)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-372868478.378378)*pz))+(((372868478.378378)*j0))))+IKsqr(((372868478.378378)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-372868478.378378)*pz))+(((372868478.378378)*j0))), ((372868478.378378)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1057=IKcos(j1);
IkReal x1058=IKsin(j1);
IkReal x1059=((1.0)*pz);
IkReal x1060=((0.107426436244745)*py);
IkReal x1061=((1.0)*px);
IkReal x1062=(j0*x1058);
IkReal x1063=(pz*x1058);
if((((0.30516627479834)+(((0.129778432051113)*py))+(((-0.0060598819598017)*(py*py))))) < -0.00001)
continue;
IkReal x1064=IKsqrt(((0.30516627479834)+(((0.129778432051113)*py))+(((-0.0060598819598017)*(py*py)))));
IkReal x1065=((0.15)*x1064);
evalcond[0]=(px+(((-2.68191080229963e-9)*x1057)));
evalcond[1]=((((-1.0)*x1058*x1061))+(((-1.0)*x1057*x1059))+((j0*x1057)));
evalcond[2]=((((-1.0)*x1059))+(((-1.0)*x1058*x1065))+(((-0.0603222819593289)*x1058))+((x1058*x1060))+j0);
evalcond[3]=((0.2764)+(((2.18)*x1063))+(((-2.18)*px*x1057))+(((-2.18)*x1062))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((1.36)*py)));
evalcond[4]=((0.0603222819593289)+x1063+x1065+(((-1.0)*x1057*x1061))+(((-1.0)*x1060))+(((-1.0)*x1062)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1066=IKcos(pz);
IkReal x1067=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x1068=IKsqrt(((-1.0)*(px*px)));
IkReal x1069=IKcos(x1068);
IkReal x1070=IKsin(x1068);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst17=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
IkReal gconst18=(((x1066*x1070))+((x1067*x1069)));
IkReal gconst19=((((-1.0)*x1067*x1070))+((x1066*x1069)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))))+(((-1.0)*pz))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x1071=IKcos(pz);
IkReal x1072=IKsin(pz);
IkReal x1073=x1068;
IkReal x1074=IKcos(x1073);
IkReal x1075=IKsin(x1073);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x1076=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj0=gconst18;
cj0=gconst19;
j0=x1076;
IkReal gconst17=x1076;
IkReal gconst18=(((x1071*x1075))+((x1072*x1074)));
IkReal gconst19=(((x1071*x1074))+(((-1.0)*x1072*x1075)));
j1eval[0]=IKabs(((-10.708)+(((12.846)*sj3))+(((9.2)*px))+py));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1077=((9.2)*px);
IkReal x1078=((12.846)*sj3);
op[0]=((-10.708)+x1078+x1077+py);
op[1]=0;
op[2]=((10.708)+x1077+(((-1.0)*py))+(((-1.0)*x1078)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1079=IKcos(pz);
IkReal x1080=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x1081=IKsqrt(((-1.0)*(px*px)));
IkReal x1082=IKcos(x1081);
IkReal x1083=IKsin(x1081);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst20=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
IkReal gconst21=((((-1.0)*x1079*x1083))+((x1080*x1082)));
IkReal gconst22=(((x1079*x1082))+((x1080*x1083)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*pz))+(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x1084=IKcos(pz);
IkReal x1085=IKsin(pz);
IkReal x1086=x1081;
IkReal x1087=IKcos(x1086);
IkReal x1088=IKsin(x1086);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x1089=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj0=gconst21;
cj0=gconst22;
j0=x1089;
IkReal gconst20=x1089;
IkReal gconst21=((((-1.0)*x1084*x1088))+((x1085*x1087)));
IkReal gconst22=(((x1085*x1088))+((x1084*x1087)));
j1eval[0]=IKabs(((-10.708)+(((12.846)*sj3))+(((9.2)*px))+py));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1090=((9.2)*px);
IkReal x1091=((12.846)*sj3);
op[0]=((-10.708)+x1090+x1091+py);
op[1]=0;
op[2]=((10.708)+x1090+(((-1.0)*x1091))+(((-1.0)*py)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1092=IKPowWithIntegerCheck(((1.09)+(((-1.38)*sj3))+(((0.15)*cj3))),-1);
if(!x1092.valid){
continue;
}
CheckValue<IkReal> x1093=IKPowWithIntegerCheck(((1.16391304347826)+(((-1.39630434782609)*sj3))+(((-0.108695652173913)*py))),-1);
if(!x1093.valid){
continue;
}
if( IKabs(((x1092.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x1093.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1092.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x1093.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x1092.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x1093.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1094=IKcos(j1);
IkReal x1095=IKsin(j1);
IkReal x1096=((0.15)*cj3);
IkReal x1097=((1.0)*pz);
IkReal x1098=((1.38)*sj3);
IkReal x1099=((1.0)*px);
IkReal x1100=(j0*x1095);
IkReal x1101=(pz*x1095);
evalcond[0]=(((j0*x1094))+(((-1.0)*x1095*x1099))+(((-1.0)*x1094*x1097)));
evalcond[1]=((((1.16391304347826)*x1094))+px+(((-1.39630434782609)*sj3*x1094))+(((-0.108695652173913)*py*x1094)));
evalcond[2]=(((x1095*x1096))+(((-1.0)*x1097))+(((-1.0)*x1095*x1098))+(((1.09)*x1095))+j0);
evalcond[3]=((-1.09)+x1101+x1098+(((-1.0)*x1096))+(((-1.0)*x1100))+(((-1.0)*x1094*x1099)));
evalcond[4]=((0.2764)+(((2.18)*x1101))+(((-2.18)*x1100))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((1.36)*py))+(((-2.18)*px*x1094)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1102=((0.15)*cj3);
IkReal x1103=((1.38)*sj3);
CheckValue<IkReal> x1104 = IKatan2WithCheck(IkReal(((((1.09)*pz))+(((-1.09)*j0))+(((-1.0)*pz*x1103))+((pz*x1102))+((j0*x1103))+(((-1.0)*j0*x1102)))),IkReal(((((-1.0)*px*x1102))+(((-1.09)*px))+((px*x1103)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1104.valid){
continue;
}
CheckValue<IkReal> x1105=IKPowWithIntegerCheck(IKsign(((j0*j0)+pp+(((-1.0)*(py*py)))+(((-2.0)*j0*pz)))),-1);
if(!x1105.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1104.value)+(((1.5707963267949)*(x1105.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1106=IKcos(j1);
IkReal x1107=IKsin(j1);
IkReal x1108=((0.15)*cj3);
IkReal x1109=((1.0)*pz);
IkReal x1110=((1.38)*sj3);
IkReal x1111=((1.0)*px);
IkReal x1112=(j0*x1107);
IkReal x1113=(pz*x1107);
evalcond[0]=((((-1.0)*x1107*x1111))+(((-1.0)*x1106*x1109))+((j0*x1106)));
evalcond[1]=((((-1.39630434782609)*sj3*x1106))+(((1.16391304347826)*x1106))+(((-0.108695652173913)*py*x1106))+px);
evalcond[2]=((((1.09)*x1107))+(((-1.0)*x1107*x1110))+(((-1.0)*x1109))+((x1107*x1108))+j0);
evalcond[3]=((-1.09)+x1110+x1113+(((-1.0)*x1112))+(((-1.0)*x1106*x1111))+(((-1.0)*x1108)));
evalcond[4]=((0.2764)+(((-2.18)*px*x1106))+(((2.18)*x1113))+(((-2.18)*x1112))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((1.36)*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1114 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1114.valid){
continue;
}
CheckValue<IkReal> x1115=IKPowWithIntegerCheck(IKsign(((1.16391304347826)+(((-1.39630434782609)*sj3))+(((-0.108695652173913)*py)))),-1);
if(!x1115.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1114.value)+(((1.5707963267949)*(x1115.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1116=IKcos(j1);
IkReal x1117=IKsin(j1);
IkReal x1118=((0.15)*cj3);
IkReal x1119=((1.0)*pz);
IkReal x1120=((1.38)*sj3);
IkReal x1121=((1.0)*px);
IkReal x1122=(j0*x1117);
IkReal x1123=(pz*x1117);
evalcond[0]=((((-1.0)*x1117*x1121))+(((-1.0)*x1116*x1119))+((j0*x1116)));
evalcond[1]=((((-1.39630434782609)*sj3*x1116))+(((1.16391304347826)*x1116))+px+(((-0.108695652173913)*py*x1116)));
evalcond[2]=((((1.09)*x1117))+(((-1.0)*x1117*x1120))+((x1117*x1118))+(((-1.0)*x1119))+j0);
evalcond[3]=((-1.09)+x1120+x1123+(((-1.0)*x1116*x1121))+(((-1.0)*x1122))+(((-1.0)*x1118)));
evalcond[4]=((0.2764)+(((-2.18)*px*x1116))+(((2.18)*x1123))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((1.36)*py))+(((-2.18)*x1122)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j1eval[0]=((-5.668)+(((12.846)*sj3))+(((-1.0)*py)));
j1eval[1]=IKsign(((-0.616086956521739)+(((1.39630434782609)*sj3))+(((-0.108695652173913)*py))));
j1eval[2]=((IKabs(px))+(IKabs((pz+(((-1.0)*j0))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
IkReal x1124=((0.15)*cj3);
IkReal x1125=((1.38)*sj3);
IkReal x1126=((((-1.0)*(j0*j0)))+(py*py)+(((-1.0)*pp))+(((2.0)*j0*pz)));
j1eval[0]=x1126;
j1eval[1]=((IKabs(((((-5.0)*cj3*px))+(((-23.0)*px))+(((46.0)*px*sj3)))))+(((33.3333333333333)*(IKabs(((((-0.69)*j0))+(((-1.0)*j0*x1124))+(((0.69)*pz))+((pz*x1124))+(((-1.0)*pz*x1125))+((j0*x1125))))))));
j1eval[2]=IKsign(x1126);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j1eval[0]=((-4.6)+(((9.2)*sj3))+(((-1.0)*cj3)));
j1eval[1]=((-5.668)+(((12.846)*sj3))+(((-1.0)*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.628491957098228)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-1308417655.67879)*pz))+(((1308417655.67879)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((1308417655.67879)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1308417655.67879)*pz))+(((1308417655.67879)*j0))))+IKsqr(((1308417655.67879)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1308417655.67879)*pz))+(((1308417655.67879)*j0))), ((1308417655.67879)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1127=IKcos(j1);
IkReal x1128=IKsin(j1);
IkReal x1129=((1.0)*pz);
IkReal x1130=((1.0)*x1128);
IkReal x1131=((1.38)*x1128);
IkReal x1132=(px*x1127);
evalcond[0]=(px+(((-7.64281952066148e-10)*x1127)));
evalcond[1]=((((-1.0)*x1129))+(((-7.64281952066148e-10)*x1128))+j0);
evalcond[2]=((((-1.0)*x1127*x1129))+((j0*x1127))+(((-1.0)*px*x1130)));
evalcond[3]=((-7.64281952066148e-10)+x1132+(((-1.0)*x1128*x1129))+((j0*x1128)));
evalcond[4]=((-1.05470909385128e-9)+(((1.38)*x1132))+(((-1.0)*pz*x1131))+((j0*x1131)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-2.72964187821248)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-5395984706.14457)*j0))+(((5395984706.14457)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-5395984706.14457)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-5395984706.14457)*j0))+(((5395984706.14457)*pz))))+IKsqr(((-5395984706.14457)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-5395984706.14457)*j0))+(((5395984706.14457)*pz))), ((-5395984706.14457)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1133=IKcos(j1);
IkReal x1134=IKsin(j1);
IkReal x1135=((1.0)*pz);
IkReal x1136=((1.0)*x1134);
IkReal x1137=(j0*x1134);
IkReal x1138=(px*x1133);
evalcond[0]=((((1.85322986342283e-10)*x1133))+px);
evalcond[1]=((((1.85322986342283e-10)*x1134))+(((-1.0)*x1135))+j0);
evalcond[2]=(((j0*x1133))+(((-1.0)*px*x1136))+(((-1.0)*x1133*x1135)));
evalcond[3]=((1.85322986342283e-10)+x1138+x1137+(((-1.0)*x1134*x1135)));
evalcond[4]=((2.55745721152351e-10)+(((1.38)*x1137))+(((1.38)*x1138))+(((-1.38)*pz*x1134)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst24=((0.441226841040012)+(((0.0778452436556126)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.441226841040012)+sj3+(((-0.0778452436556126)*py)))))+(IKabs(((-1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((914515468.421053)*pz))+(((-914515468.421053)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-914515468.421053)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((914515468.421053)*pz))+(((-914515468.421053)*j0))))+IKsqr(((-914515468.421053)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((914515468.421053)*pz))+(((-914515468.421053)*j0))), ((-914515468.421053)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1139=IKcos(j1);
IkReal x1140=IKsin(j1);
IkReal x1141=((1.0)*pz);
IkReal x1142=((0.107426436244745)*py);
IkReal x1143=(px*x1139);
IkReal x1144=((1.38)*x1140);
if((((0.805318874745852)+(((-0.0686948218963121)*py))+(((-0.0060598819598017)*(py*py))))) < -0.00001)
continue;
IkReal x1145=IKsqrt(((0.805318874745852)+(((-0.0686948218963121)*py))+(((-0.0060598819598017)*(py*py)))));
IkReal x1146=((0.15)*x1145);
evalcond[0]=(px+(((1.09347521669211e-9)*x1139)));
evalcond[1]=(((j0*x1139))+(((-1.0)*px*x1140))+(((-1.0)*x1139*x1141)));
evalcond[2]=((((-1.0)*x1140*x1146))+((x1140*x1142))+(((-0.0811069582840759)*x1140))+(((-1.0)*x1141))+j0);
evalcond[3]=((-0.0811069582840759)+(((-1.0)*x1140*x1141))+x1142+x1143+((j0*x1140))+(((-1.0)*x1146)));
evalcond[4]=((0.9884)+((j0*x1144))+(((1.38)*x1143))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((1.36)*py))+(((-1.0)*pz*x1144)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst24=((0.441226841040012)+(((0.0778452436556126)*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.441226841040012)+sj3+(((-0.0778452436556126)*py)))))+(IKabs(((1.0)+(IKsign(cj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((914515468.421053)*pz))+(((-914515468.421053)*j0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-914515468.421053)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((914515468.421053)*pz))+(((-914515468.421053)*j0))))+IKsqr(((-914515468.421053)*px))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((914515468.421053)*pz))+(((-914515468.421053)*j0))), ((-914515468.421053)*px));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1147=IKcos(j1);
IkReal x1148=IKsin(j1);
IkReal x1149=((1.0)*pz);
IkReal x1150=((0.107426436244745)*py);
IkReal x1151=(px*x1147);
IkReal x1152=((1.38)*x1148);
if((((0.805318874745852)+(((-0.0686948218963121)*py))+(((-0.0060598819598017)*(py*py))))) < -0.00001)
continue;
IkReal x1153=IKsqrt(((0.805318874745852)+(((-0.0686948218963121)*py))+(((-0.0060598819598017)*(py*py)))));
IkReal x1154=((0.15)*x1153);
evalcond[0]=((((1.09347521669211e-9)*x1147))+px);
evalcond[1]=(((j0*x1147))+(((-1.0)*x1147*x1149))+(((-1.0)*px*x1148)));
evalcond[2]=((((-0.0811069582840759)*x1148))+(((-1.0)*x1149))+((x1148*x1154))+((x1148*x1150))+j0);
evalcond[3]=((-0.0811069582840759)+x1154+x1151+x1150+((j0*x1148))+(((-1.0)*x1148*x1149)));
evalcond[4]=((0.9884)+(((1.38)*x1151))+(((-1.0)*(j0*j0)))+((j0*x1152))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((1.36)*py))+(((-1.0)*pz*x1152)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1155=IKcos(pz);
IkReal x1156=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x1157=IKsqrt(((-1.0)*(px*px)));
IkReal x1158=IKcos(x1157);
IkReal x1159=IKsin(x1157);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst25=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
IkReal gconst26=(((x1156*x1158))+((x1155*x1159)));
IkReal gconst27=((((-1.0)*x1156*x1159))+((x1155*x1158)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))))+(((-1.0)*pz))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x1160=IKcos(pz);
IkReal x1161=IKsin(pz);
IkReal x1162=x1157;
IkReal x1163=IKcos(x1162);
IkReal x1164=IKsin(x1162);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x1165=((IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+pz);
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
sj0=gconst26;
cj0=gconst27;
j0=x1165;
IkReal gconst25=x1165;
IkReal gconst26=(((x1160*x1164))+((x1161*x1163)));
IkReal gconst27=((((-1.0)*x1161*x1164))+((x1160*x1163)));
j1eval[0]=IKabs(((5.668)+(((-12.846)*sj3))+(((9.2)*px))+py));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1166=((12.846)*sj3);
IkReal x1167=((9.2)*px);
op[0]=((5.668)+x1167+py+(((-1.0)*x1166)));
op[1]=0;
op[2]=((-5.668)+x1166+x1167+(((-1.0)*py)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1168=IKcos(pz);
IkReal x1169=IKsin(pz);
if((((-1.0)*(px*px))) < -0.00001)
continue;
IkReal x1170=IKsqrt(((-1.0)*(px*px)));
IkReal x1171=IKcos(x1170);
IkReal x1172=IKsin(x1170);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal gconst28=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
IkReal gconst29=((((-1.0)*x1168*x1172))+((x1169*x1171)));
IkReal gconst30=(((x1168*x1171))+((x1169*x1172)));
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
evalcond[0]=IKabs(((((-1.0)*pz))+(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz))))+j0));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x1173=IKcos(pz);
IkReal x1174=IKsin(pz);
IkReal x1175=x1170;
IkReal x1176=IKcos(x1175);
IkReal x1177=IKsin(x1175);
if((((py*py)+(((-1.0)*pp))+(pz*pz))) < -0.00001)
continue;
IkReal x1178=(pz+(((-1.0)*(IKsqrt(((py*py)+(((-1.0)*pp))+(pz*pz)))))));
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
sj0=gconst29;
cj0=gconst30;
j0=x1178;
IkReal gconst28=x1178;
IkReal gconst29=(((x1174*x1176))+(((-1.0)*x1173*x1177)));
IkReal gconst30=(((x1173*x1176))+((x1174*x1177)));
j1eval[0]=IKabs(((5.668)+(((-12.846)*sj3))+(((9.2)*px))+py));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1179=((12.846)*sj3);
IkReal x1180=((9.2)*px);
op[0]=((5.668)+x1180+py+(((-1.0)*x1179)));
op[1]=0;
op[2]=((-5.668)+x1180+x1179+(((-1.0)*py)));
polyroots2(op,zeror,numroots);
IkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[2]={true,true};
_nj1 = 2;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1181=IKPowWithIntegerCheck(((-0.69)+(((-0.15)*cj3))+(((1.38)*sj3))),-1);
if(!x1181.valid){
continue;
}
CheckValue<IkReal> x1182=IKPowWithIntegerCheck(((-0.616086956521739)+(((1.39630434782609)*sj3))+(((-0.108695652173913)*py))),-1);
if(!x1182.valid){
continue;
}
if( IKabs(((x1181.value)*((pz+(((-1.0)*j0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*px*(x1182.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1181.value)*((pz+(((-1.0)*j0))))))+IKsqr(((-1.0)*px*(x1182.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x1181.value)*((pz+(((-1.0)*j0))))), ((-1.0)*px*(x1182.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1183=IKcos(j1);
IkReal x1184=IKsin(j1);
IkReal x1185=((0.15)*cj3);
IkReal x1186=((1.0)*pz);
IkReal x1187=((1.38)*sj3);
IkReal x1188=(px*x1183);
IkReal x1189=((1.38)*x1184);
evalcond[0]=((((-1.0)*px*x1184))+(((-1.0)*x1183*x1186))+((j0*x1183)));
evalcond[1]=((((-0.616086956521739)*x1183))+px+(((1.39630434782609)*sj3*x1183))+(((-0.108695652173913)*py*x1183)));
evalcond[2]=((((-0.69)*x1184))+((x1184*x1187))+(((-1.0)*x1184*x1185))+(((-1.0)*x1186))+j0);
evalcond[3]=((-0.69)+x1188+x1187+(((-1.0)*x1184*x1186))+(((-1.0)*x1185))+((j0*x1184)));
evalcond[4]=((0.9884)+(((-1.0)*pz*x1189))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((1.36)*py))+(((1.38)*x1188))+((j0*x1189)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1190=((0.15)*cj3);
IkReal x1191=((1.38)*sj3);
CheckValue<IkReal> x1192 = IKatan2WithCheck(IkReal(((((-0.69)*j0))+(((-1.0)*j0*x1190))+((pz*x1190))+(((0.69)*pz))+(((-1.0)*pz*x1191))+((j0*x1191)))),IkReal(((((-0.69)*px))+((px*x1191))+(((-1.0)*px*x1190)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1192.valid){
continue;
}
CheckValue<IkReal> x1193=IKPowWithIntegerCheck(IKsign(((((-1.0)*(j0*j0)))+(py*py)+(((-1.0)*pp))+(((2.0)*j0*pz)))),-1);
if(!x1193.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1192.value)+(((1.5707963267949)*(x1193.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1194=IKcos(j1);
IkReal x1195=IKsin(j1);
IkReal x1196=((0.15)*cj3);
IkReal x1197=((1.0)*pz);
IkReal x1198=((1.38)*sj3);
IkReal x1199=(px*x1194);
IkReal x1200=((1.38)*x1195);
evalcond[0]=((((-1.0)*px*x1195))+(((-1.0)*x1194*x1197))+((j0*x1194)));
evalcond[1]=((((-0.616086956521739)*x1194))+(((1.39630434782609)*sj3*x1194))+px+(((-0.108695652173913)*py*x1194)));
evalcond[2]=(((x1195*x1198))+(((-1.0)*x1195*x1196))+(((-1.0)*x1197))+j0+(((-0.69)*x1195)));
evalcond[3]=((-0.69)+x1199+x1198+(((-1.0)*x1195*x1197))+(((-1.0)*x1196))+((j0*x1195)));
evalcond[4]=((0.9884)+(((-1.0)*pz*x1200))+(((-1.0)*(j0*j0)))+((j0*x1200))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((1.36)*py))+(((1.38)*x1199)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1201=IKPowWithIntegerCheck(IKsign(((-0.616086956521739)+(((1.39630434782609)*sj3))+(((-0.108695652173913)*py)))),-1);
if(!x1201.valid){
continue;
}
CheckValue<IkReal> x1202 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1202.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1201.value)))+(x1202.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1203=IKcos(j1);
IkReal x1204=IKsin(j1);
IkReal x1205=((0.15)*cj3);
IkReal x1206=((1.0)*pz);
IkReal x1207=((1.38)*sj3);
IkReal x1208=(px*x1203);
IkReal x1209=((1.38)*x1204);
evalcond[0]=(((j0*x1203))+(((-1.0)*x1203*x1206))+(((-1.0)*px*x1204)));
evalcond[1]=((((-0.108695652173913)*py*x1203))+(((1.39630434782609)*sj3*x1203))+(((-0.616086956521739)*x1203))+px);
evalcond[2]=(((x1204*x1207))+(((-1.0)*x1204*x1205))+(((-0.69)*x1204))+(((-1.0)*x1206))+j0);
evalcond[3]=((-0.69)+(((-1.0)*x1204*x1206))+x1208+x1207+((j0*x1204))+(((-1.0)*x1205)));
evalcond[4]=((0.9884)+(((-1.0)*pz*x1209))+(((-1.0)*(j0*j0)))+(((1.38)*x1208))+((j0*x1209))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((1.36)*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1210=((0.15)*cj3);
IkReal x1211=(cj2*py);
IkReal x1212=((0.2)*sj2);
IkReal x1213=((1.38)*sj3);
IkReal x1214=((0.68)*cj2);
CheckValue<IkReal> x1215 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x1211))+((j0*x1213))+((j0*x1211))+(((-0.89)*j0))+(((0.89)*pz))+(((-1.0)*j0*x1214))+(((-1.0)*j0*x1210))+(((-1.0)*j0*x1212))+((pz*x1214))+((pz*x1210))+((pz*x1212))+(((-1.0)*pz*x1213)))),IkReal((((px*x1211))+((px*x1213))+(((-1.0)*px*x1214))+(((-1.0)*px*x1212))+(((-1.0)*px*x1210))+(((-0.89)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1215.valid){
continue;
}
CheckValue<IkReal> x1216=IKPowWithIntegerCheck(IKsign(((((-1.0)*sj2*(py*py)))+((sj2*(j0*j0)))+((pp*sj2))+(((-2.0)*j0*pz*sj2)))),-1);
if(!x1216.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1215.value)+(((1.5707963267949)*(x1216.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1217=IKcos(j1);
IkReal x1218=IKsin(j1);
IkReal x1219=(cj2*sj3);
IkReal x1220=((0.15)*cj3);
IkReal x1221=((1.0)*pz);
IkReal x1222=((1.38)*sj3);
IkReal x1223=(cj2*py);
IkReal x1224=((1.38)*cj3);
IkReal x1225=((1.0)*px);
IkReal x1226=(pz*x1218);
IkReal x1227=((0.15)*x1217);
IkReal x1228=(sj2*x1218);
IkReal x1229=(sj2*x1217);
IkReal x1230=(cj2*x1217);
IkReal x1231=(cj2*x1218);
evalcond[0]=(((j0*x1217))+(((-1.0)*x1218*x1225))+(((-1.0)*x1217*x1221)));
evalcond[1]=(x1224+(((0.2)*cj2))+(((-1.0)*x1221*x1231))+((px*x1230))+(((-0.68)*sj2))+((py*sj2))+(((0.15)*sj3))+((j0*x1231)));
evalcond[2]=((-0.89)+x1223+x1222+((sj2*x1226))+(((-1.0)*x1225*x1229))+(((-1.0)*x1220))+(((-1.0)*j0*x1228))+(((-0.2)*sj2))+(((-0.68)*cj2)));
evalcond[3]=((((0.2)*x1217))+((x1219*x1227))+((x1224*x1230))+(((-1.0)*x1222*x1229))+((x1220*x1229))+px+(((0.89)*x1229)));
evalcond[4]=((((-1.0)*x1221))+(((0.2)*x1218))+((x1224*x1231))+(((-1.0)*x1222*x1228))+((x1220*x1228))+(((0.15)*x1218*x1219))+(((0.89)*x1228))+j0);
evalcond[5]=((0.6324)+(((-1.2104)*cj2))+(((-0.4)*px*x1217))+(((-1.0)*(j0*j0)))+(((1.78)*sj2*x1226))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((0.4)*x1226))+(((-1.78)*px*x1229))+(((1.36)*py))+(((-0.356)*sj2))+(((-1.78)*j0*x1228))+(((-0.4)*j0*x1218))+(((1.78)*x1223)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1232=(j0*sj2);
IkReal x1233=((0.2)*cj2);
IkReal x1234=((0.68)*sj2);
IkReal x1235=((1.38)*cj3);
IkReal x1236=((0.15)*sj3);
IkReal x1237=((1.0)*cj2);
IkReal x1238=(py*sj2);
CheckValue<IkReal> x1239=IKPowWithIntegerCheck(IKsign(((((2.0)*cj2*j0*pz))+(((-1.0)*pp*x1237))+((cj2*(py*py)))+(((-1.0)*x1237*(j0*j0))))),-1);
if(!x1239.valid){
continue;
}
CheckValue<IkReal> x1240 = IKatan2WithCheck(IkReal((((pz*x1234))+((py*x1232))+(((-1.0)*pz*x1233))+(((-1.0)*pz*x1236))+(((-1.0)*pz*x1235))+(((-1.0)*pz*x1238))+(((-0.68)*x1232))+((j0*x1235))+((j0*x1233))+((j0*x1236)))),IkReal(((((-1.0)*px*x1234))+((px*x1235))+((px*x1236))+((px*x1233))+((px*x1238)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1240.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1239.value)))+(x1240.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1241=IKcos(j1);
IkReal x1242=IKsin(j1);
IkReal x1243=(cj2*sj3);
IkReal x1244=((0.15)*cj3);
IkReal x1245=((1.0)*pz);
IkReal x1246=((1.38)*sj3);
IkReal x1247=(cj2*py);
IkReal x1248=((1.38)*cj3);
IkReal x1249=((1.0)*px);
IkReal x1250=(pz*x1242);
IkReal x1251=((0.15)*x1241);
IkReal x1252=(sj2*x1242);
IkReal x1253=(sj2*x1241);
IkReal x1254=(cj2*x1241);
IkReal x1255=(cj2*x1242);
evalcond[0]=(((j0*x1241))+(((-1.0)*x1242*x1249))+(((-1.0)*x1241*x1245)));
evalcond[1]=(x1248+(((0.2)*cj2))+(((-1.0)*x1245*x1255))+(((-0.68)*sj2))+((j0*x1255))+((py*sj2))+((px*x1254))+(((0.15)*sj3)));
evalcond[2]=((-0.89)+(((-1.0)*x1249*x1253))+x1247+x1246+(((-1.0)*x1244))+(((-0.2)*sj2))+(((-0.68)*cj2))+(((-1.0)*j0*x1252))+((sj2*x1250)));
evalcond[3]=((((0.89)*x1253))+(((0.2)*x1241))+((x1243*x1251))+(((-1.0)*x1246*x1253))+px+((x1248*x1254))+((x1244*x1253)));
evalcond[4]=((((0.89)*x1252))+(((0.2)*x1242))+(((-1.0)*x1246*x1252))+(((-1.0)*x1245))+((x1248*x1255))+j0+(((0.15)*x1242*x1243))+((x1244*x1252)));
evalcond[5]=((0.6324)+(((-0.4)*px*x1241))+(((-1.78)*j0*x1252))+(((-1.78)*px*x1253))+(((-1.2104)*cj2))+(((-1.0)*(j0*j0)))+(((-0.4)*j0*x1242))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((1.36)*py))+(((1.78)*x1247))+(((-0.356)*sj2))+(((1.78)*sj2*x1250))+(((0.4)*x1250)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1256 = IKatan2WithCheck(IkReal((pz+(((-1.0)*j0)))),IkReal(((-1.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1256.valid){
continue;
}
CheckValue<IkReal> x1257=IKPowWithIntegerCheck(IKsign(((0.2)+(((0.15)*cj3*sj2))+(((-1.38)*sj2*sj3))+(((0.89)*sj2))+(((1.38)*cj2*cj3))+(((0.15)*cj2*sj3)))),-1);
if(!x1257.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1256.value)+(((1.5707963267949)*(x1257.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1258=IKcos(j1);
IkReal x1259=IKsin(j1);
IkReal x1260=(cj2*sj3);
IkReal x1261=((0.15)*cj3);
IkReal x1262=((1.0)*pz);
IkReal x1263=((1.38)*sj3);
IkReal x1264=(cj2*py);
IkReal x1265=((1.38)*cj3);
IkReal x1266=((1.0)*px);
IkReal x1267=(pz*x1259);
IkReal x1268=((0.15)*x1258);
IkReal x1269=(sj2*x1259);
IkReal x1270=(sj2*x1258);
IkReal x1271=(cj2*x1258);
IkReal x1272=(cj2*x1259);
evalcond[0]=((((-1.0)*x1258*x1262))+((j0*x1258))+(((-1.0)*x1259*x1266)));
evalcond[1]=(x1265+(((0.2)*cj2))+((j0*x1272))+(((-0.68)*sj2))+(((-1.0)*x1262*x1272))+((px*x1271))+((py*sj2))+(((0.15)*sj3)));
evalcond[2]=((-0.89)+x1263+x1264+(((-1.0)*x1266*x1270))+(((-0.2)*sj2))+(((-0.68)*cj2))+((sj2*x1267))+(((-1.0)*j0*x1269))+(((-1.0)*x1261)));
evalcond[3]=((((0.89)*x1270))+((x1265*x1271))+((x1261*x1270))+(((-1.0)*x1263*x1270))+((x1260*x1268))+px+(((0.2)*x1258)));
evalcond[4]=(((x1265*x1272))+((x1261*x1269))+(((0.89)*x1269))+(((-1.0)*x1263*x1269))+(((0.15)*x1259*x1260))+(((0.2)*x1259))+j0+(((-1.0)*x1262)));
evalcond[5]=((0.6324)+(((-1.78)*j0*x1269))+(((-0.4)*j0*x1259))+(((-1.78)*px*x1270))+(((1.78)*x1264))+(((-1.2104)*cj2))+(((-1.0)*(j0*j0)))+(((-1.0)*pp))+(((2.0)*j0*pz))+(((-0.4)*px*x1258))+(((1.36)*py))+(((-0.356)*sj2))+(((1.78)*sj2*x1267))+(((0.4)*x1267)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x79=((1.0)*cj1);
IkReal x80=((1.0)*cj2);
IkReal x81=(r20*sj1);
IkReal x82=(sj2*sj3);
IkReal x83=(r22*sj1);
IkReal x84=(r21*sj1);
IkReal x85=(x82+(((-1.0)*cj3*x80)));
IkReal x86=(((cj2*cj3))+(((-1.0)*x82)));
IkReal x87=((((-1.0)*sj3*x80))+(((-1.0)*cj3*sj2)));
IkReal x88=(x79*x87);
new_r00=(((r10*x85))+((x81*x87))+(((-1.0)*r00*x88)));
new_r01=(((x84*x87))+((r11*x85))+(((-1.0)*r01*x88)));
new_r02=((((-1.0)*r02*x88))+((r12*x85))+((x83*x87)));
new_r10=(((r00*sj1))+((cj1*r20)));
new_r11=(((r01*sj1))+((cj1*r21)));
new_r12=(((r02*sj1))+((cj1*r22)));
new_r20=((((-1.0)*r00*x79*x86))+((r10*x87))+((x81*x86)));
new_r21=(((x84*x86))+((r11*x87))+(((-1.0)*r01*x79*x86)));
new_r22=(((r12*x87))+(((-1.0)*r02*x79*x86))+((x83*x86)));
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=new_r22;
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j4eval[3];
j4eval[0]=sj5;
j4eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j4eval[2]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=new_r12;
j4eval[1]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j6mul = 1;
j6=0;
j4mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].fmul = j6mul;
vinfos[6].freeind = 0;
vinfos[6].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 6;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j6mul = 1;
j6=0;
j4mul=1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].fmul = j6mul;
vinfos[6].freeind = 0;
vinfos[6].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 6;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x89=new_r22*new_r22;
IkReal x90=((16.0)*new_r10);
IkReal x91=((16.0)*new_r01);
IkReal x92=((16.0)*new_r22);
IkReal x93=((8.0)*new_r11);
IkReal x94=((8.0)*new_r00);
IkReal x95=(x89*x90);
IkReal x96=(x89*x91);
j4eval[0]=((IKabs(((((32.0)*new_r11))+(((-16.0)*new_r11*x89))+(((-1.0)*new_r00*x92)))))+(IKabs((((x89*x93))+(((-1.0)*new_r22*x94)))))+(IKabs((x96+(((-1.0)*x91)))))+(IKabs((x90+(((-1.0)*x95)))))+(IKabs(((((16.0)*new_r00))+((new_r11*x92))+(((-32.0)*new_r00*x89)))))+(IKabs((x95+(((-1.0)*x90)))))+(IKabs((((new_r22*x93))+(((-1.0)*x94)))))+(IKabs((x91+(((-1.0)*x96))))));
if( IKabs(j4eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j4, j6]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j4evalpoly[1];
IkReal x97=new_r22*new_r22;
IkReal x98=((16.0)*new_r10);
IkReal x99=(new_r11*new_r22);
IkReal x100=(x97*x98);
IkReal x101=((((8.0)*x99))+(((-8.0)*new_r00)));
op[0]=x101;
op[1]=((((-1.0)*x100))+x98);
op[2]=((((16.0)*x99))+(((16.0)*new_r00))+(((-32.0)*new_r00*x97)));
op[3]=(x100+(((-1.0)*x98)));
op[4]=x101;
polyroots4(op,zeror,numroots);
IkReal j4array[4], cj4array[4], sj4array[4], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[4]={true,true,true,true};
_nj4 = 4;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x102=new_r22*new_r22;
IkReal x103=((16.0)*new_r01);
IkReal x104=(new_r00*new_r22);
IkReal x105=((8.0)*x104);
IkReal x106=(new_r11*x102);
IkReal x107=(x102*x103);
IkReal x108=((8.0)*x106);
j4evalpoly[0]=(((htj4*(((((-1.0)*x107))+x103))))+(((htj4*htj4)*(((((32.0)*new_r11))+(((-16.0)*x106))+(((-16.0)*x104))))))+(((-1.0)*x105))+x108+(((htj4*htj4*htj4*htj4)*(((((-1.0)*x105))+x108))))+(((htj4*htj4*htj4)*(((((-1.0)*x103))+x107)))));
if( IKabs(j4evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j6eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x109=cj4*cj4;
IkReal x110=(cj4*new_r22);
IkReal x111=((-1.0)+(((-1.0)*x109*(new_r22*new_r22)))+x109);
j6eval[0]=x111;
j6eval[1]=((IKabs((((new_r01*sj4))+(((-1.0)*new_r00*x110)))))+(IKabs((((new_r00*sj4))+((new_r01*x110))))));
j6eval[2]=IKsign(x111);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j6eval[0]=new_r22;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x112=new_r22*new_r22;
j6eval[0]=(((cj4*x112))+(((-1.0)*cj4)));
j6eval[1]=((((-1.0)*sj4))+((sj4*x112)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x113=IKsin(j6);
IkReal x114=IKcos(j6);
evalcond[0]=x113;
evalcond[1]=((-1.0)*x114);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x113)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x114)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x115=IKsin(j6);
IkReal x116=IKcos(j6);
evalcond[0]=x115;
evalcond[1]=((-1.0)*x116);
evalcond[2]=(new_r00+(((-1.0)*x115)));
evalcond[3]=(new_r01+(((-1.0)*x116)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x117=IKsin(j6);
IkReal x118=IKcos(j6);
evalcond[0]=x117;
evalcond[1]=((-1.0)*x118);
evalcond[2]=(new_r10+(((-1.0)*x117)));
evalcond[3]=(new_r11+(((-1.0)*x118)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x119=IKsin(j6);
IkReal x120=IKcos(j6);
evalcond[0]=x119;
evalcond[1]=((-1.0)*x120);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x119)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x120)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x121=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x121.valid){
continue;
}
if((x121.value) < -0.00001)
continue;
IkReal gconst32=((-1.0)*(IKsqrt(x121.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj4+(((-1.0)*gconst32)))))+(IKabs(((-1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32)))));
cj4=gconst32;
if( (gconst32) < -1-IKFAST_SINCOS_THRESH || (gconst32) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst32);
CheckValue<IkReal> x122=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x122.valid){
continue;
}
if((x122.value) < -0.00001)
continue;
IkReal gconst32=((-1.0)*(IKsqrt(x122.value)));
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
CheckValue<IkReal> x123=IKPowWithIntegerCheck(gconst32,-1);
if(!x123.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32))))))))+((gconst32*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x123.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32))))))))+((gconst32*new_r10))))+IKsqr((new_r11*(x123.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32))))))))+((gconst32*new_r10))), (new_r11*(x123.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x124=IKcos(j6);
IkReal x125=IKsin(j6);
IkReal x126=((1.0)*x124);
IkReal x127=((1.0)*x125);
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
IkReal x128=IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32)))));
IkReal x129=((1.0)*x128);
evalcond[0]=x125;
evalcond[1]=((-1.0)*x124);
evalcond[2]=((((-1.0)*gconst32*x126))+new_r11);
evalcond[3]=((((-1.0)*gconst32*x127))+new_r10);
evalcond[4]=(((x124*x128))+new_r01);
evalcond[5]=(((x125*x128))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x129))+(((-1.0)*x127))+((gconst32*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x129))+(((-1.0)*x126))+((gconst32*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x130=IKPowWithIntegerCheck(IKsign(gconst32),-1);
if(!x130.valid){
continue;
}
CheckValue<IkReal> x131 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x131.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x130.value)))+(x131.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x132=IKcos(j6);
IkReal x133=IKsin(j6);
IkReal x134=((1.0)*x132);
IkReal x135=((1.0)*x133);
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
IkReal x136=IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32)))));
IkReal x137=((1.0)*x136);
evalcond[0]=x133;
evalcond[1]=((-1.0)*x132);
evalcond[2]=((((-1.0)*gconst32*x134))+new_r11);
evalcond[3]=((((-1.0)*gconst32*x135))+new_r10);
evalcond[4]=(((x132*x136))+new_r01);
evalcond[5]=(((x133*x136))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x137))+(((-1.0)*x135))+((gconst32*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x137))+(((-1.0)*x134))+((gconst32*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x138=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x138.valid){
continue;
}
if((x138.value) < -0.00001)
continue;
IkReal gconst32=((-1.0)*(IKsqrt(x138.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj4+(((-1.0)*gconst32)))))+(IKabs(((1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32)))))));
cj4=gconst32;
if( (gconst32) < -1-IKFAST_SINCOS_THRESH || (gconst32) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst32)));
CheckValue<IkReal> x139=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x139.valid){
continue;
}
if((x139.value) < -0.00001)
continue;
IkReal gconst32=((-1.0)*(IKsqrt(x139.value)));
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
CheckValue<IkReal> x140=IKPowWithIntegerCheck(gconst32,-1);
if(!x140.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32))))))))+((gconst32*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x140.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32))))))))+((gconst32*new_r10))))+IKsqr((new_r11*(x140.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32))))))))+((gconst32*new_r10))), (new_r11*(x140.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x141=IKcos(j6);
IkReal x142=IKsin(j6);
IkReal x143=((1.0)*x141);
IkReal x144=((1.0)*x142);
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
IkReal x145=IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32)))));
evalcond[0]=x142;
evalcond[1]=((-1.0)*x141);
evalcond[2]=(new_r11+(((-1.0)*gconst32*x143)));
evalcond[3]=(new_r10+(((-1.0)*gconst32*x144)));
evalcond[4]=((((-1.0)*x143*x145))+new_r01);
evalcond[5]=((((-1.0)*x144*x145))+new_r00);
evalcond[6]=((((-1.0)*x144))+((new_r00*x145))+((gconst32*new_r10)));
evalcond[7]=((((-1.0)*x143))+((new_r01*x145))+((gconst32*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x146=IKPowWithIntegerCheck(IKsign(gconst32),-1);
if(!x146.valid){
continue;
}
CheckValue<IkReal> x147 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x147.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x146.value)))+(x147.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x148=IKcos(j6);
IkReal x149=IKsin(j6);
IkReal x150=((1.0)*x148);
IkReal x151=((1.0)*x149);
if((((1.0)+(((-1.0)*(gconst32*gconst32))))) < -0.00001)
continue;
IkReal x152=IKsqrt(((1.0)+(((-1.0)*(gconst32*gconst32)))));
evalcond[0]=x149;
evalcond[1]=((-1.0)*x148);
evalcond[2]=(new_r11+(((-1.0)*gconst32*x150)));
evalcond[3]=(new_r10+(((-1.0)*gconst32*x151)));
evalcond[4]=((((-1.0)*x150*x152))+new_r01);
evalcond[5]=((((-1.0)*x151*x152))+new_r00);
evalcond[6]=((((-1.0)*x151))+((new_r00*x152))+((gconst32*new_r10)));
evalcond[7]=((((-1.0)*x150))+((new_r01*x152))+((gconst32*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x153=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x153.valid){
continue;
}
if((x153.value) < -0.00001)
continue;
IkReal gconst33=IKsqrt(x153.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj4)))))+(IKabs((cj4+(((-1.0)*gconst33)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))));
cj4=gconst33;
if( (gconst33) < -1-IKFAST_SINCOS_THRESH || (gconst33) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst33);
CheckValue<IkReal> x154=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x154.valid){
continue;
}
if((x154.value) < -0.00001)
continue;
IkReal gconst33=IKsqrt(x154.value);
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
CheckValue<IkReal> x155=IKPowWithIntegerCheck(gconst33,-1);
if(!x155.valid){
continue;
}
if( IKabs((((gconst33*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x155.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst33*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33))))))))))+IKsqr((new_r11*(x155.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((gconst33*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33))))))))), (new_r11*(x155.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x156=IKcos(j6);
IkReal x157=IKsin(j6);
IkReal x158=((1.0)*x156);
IkReal x159=((1.0)*x157);
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
IkReal x160=IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))));
IkReal x161=((1.0)*x160);
evalcond[0]=x157;
evalcond[1]=((-1.0)*x156);
evalcond[2]=(new_r11+(((-1.0)*gconst33*x158)));
evalcond[3]=(new_r10+(((-1.0)*gconst33*x159)));
evalcond[4]=(((x156*x160))+new_r01);
evalcond[5]=(((x157*x160))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x161))+(((-1.0)*x159))+((gconst33*new_r10)));
evalcond[7]=((((-1.0)*x158))+((gconst33*new_r11))+(((-1.0)*new_r01*x161)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x162 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x162.valid){
continue;
}
CheckValue<IkReal> x163=IKPowWithIntegerCheck(IKsign(gconst33),-1);
if(!x163.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x162.value)+(((1.5707963267949)*(x163.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x164=IKcos(j6);
IkReal x165=IKsin(j6);
IkReal x166=((1.0)*x164);
IkReal x167=((1.0)*x165);
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
IkReal x168=IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))));
IkReal x169=((1.0)*x168);
evalcond[0]=x165;
evalcond[1]=((-1.0)*x164);
evalcond[2]=(new_r11+(((-1.0)*gconst33*x166)));
evalcond[3]=(new_r10+(((-1.0)*gconst33*x167)));
evalcond[4]=(((x164*x168))+new_r01);
evalcond[5]=(((x165*x168))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x169))+(((-1.0)*x167))+((gconst33*new_r10)));
evalcond[7]=((((-1.0)*x166))+((gconst33*new_r11))+(((-1.0)*new_r01*x169)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x170=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x170.valid){
continue;
}
if((x170.value) < -0.00001)
continue;
IkReal gconst33=IKsqrt(x170.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj4+(((-1.0)*gconst33)))))+(IKabs(((1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))))));
cj4=gconst33;
if( (gconst33) < -1-IKFAST_SINCOS_THRESH || (gconst33) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst33)));
CheckValue<IkReal> x171=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x171.valid){
continue;
}
if((x171.value) < -0.00001)
continue;
IkReal gconst33=IKsqrt(x171.value);
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
CheckValue<IkReal> x172=IKPowWithIntegerCheck(gconst33,-1);
if(!x172.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33))))))))+((gconst33*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x172.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33))))))))+((gconst33*new_r10))))+IKsqr((new_r11*(x172.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33))))))))+((gconst33*new_r10))), (new_r11*(x172.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x173=IKcos(j6);
IkReal x174=IKsin(j6);
IkReal x175=((1.0)*x173);
IkReal x176=((1.0)*x174);
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
IkReal x177=IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))));
evalcond[0]=x174;
evalcond[1]=((-1.0)*x173);
evalcond[2]=(new_r11+(((-1.0)*gconst33*x175)));
evalcond[3]=(new_r10+(((-1.0)*gconst33*x176)));
evalcond[4]=((((-1.0)*x175*x177))+new_r01);
evalcond[5]=((((-1.0)*x176*x177))+new_r00);
evalcond[6]=(((new_r00*x177))+(((-1.0)*x176))+((gconst33*new_r10)));
evalcond[7]=(((new_r01*x177))+(((-1.0)*x175))+((gconst33*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x178 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x178.valid){
continue;
}
CheckValue<IkReal> x179=IKPowWithIntegerCheck(IKsign(gconst33),-1);
if(!x179.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x178.value)+(((1.5707963267949)*(x179.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x180=IKcos(j6);
IkReal x181=IKsin(j6);
IkReal x182=((1.0)*x180);
IkReal x183=((1.0)*x181);
if((((1.0)+(((-1.0)*(gconst33*gconst33))))) < -0.00001)
continue;
IkReal x184=IKsqrt(((1.0)+(((-1.0)*(gconst33*gconst33)))));
evalcond[0]=x181;
evalcond[1]=((-1.0)*x180);
evalcond[2]=((((-1.0)*gconst33*x182))+new_r11);
evalcond[3]=((((-1.0)*gconst33*x183))+new_r10);
evalcond[4]=(new_r01+(((-1.0)*x182*x184)));
evalcond[5]=(new_r00+(((-1.0)*x183*x184)));
evalcond[6]=(((new_r00*x184))+(((-1.0)*x183))+((gconst33*new_r10)));
evalcond[7]=(((new_r01*x184))+(((-1.0)*x182))+((gconst33*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x185=new_r22*new_r22;
CheckValue<IkReal> x186=IKPowWithIntegerCheck(((((-1.0)*cj4))+((cj4*x185))),-1);
if(!x186.valid){
continue;
}
CheckValue<IkReal> x187=IKPowWithIntegerCheck(((((-1.0)*sj4))+((sj4*x185))),-1);
if(!x187.valid){
continue;
}
if( IKabs(((x186.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x187.value)*((((new_r10*new_r22))+new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x186.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))))+IKsqr(((x187.value)*((((new_r10*new_r22))+new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((x186.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))), ((x187.value)*((((new_r10*new_r22))+new_r01))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x188=IKsin(j6);
IkReal x189=IKcos(j6);
IkReal x190=((1.0)*sj4);
IkReal x191=(cj4*new_r01);
IkReal x192=(new_r10*sj4);
IkReal x193=(new_r11*sj4);
IkReal x194=(cj4*new_r00);
IkReal x195=((1.0)*x189);
IkReal x196=(sj4*x188);
IkReal x197=(new_r22*x188);
IkReal x198=((1.0)*x188);
evalcond[0]=(x193+x191+x197);
evalcond[1]=(x188+((new_r22*x191))+((new_r22*x193)));
evalcond[2]=(((cj4*new_r10))+(((-1.0)*x198))+(((-1.0)*new_r00*x190)));
evalcond[3]=(((cj4*new_r11))+(((-1.0)*x195))+(((-1.0)*new_r01*x190)));
evalcond[4]=(((cj4*x197))+((sj4*x189))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x195))+x192+x194);
evalcond[6]=(x196+(((-1.0)*cj4*new_r22*x195))+new_r00);
evalcond[7]=((((-1.0)*cj4*x195))+((new_r22*x196))+new_r11);
evalcond[8]=((((-1.0)*x195))+((new_r22*x192))+((new_r22*x194)));
evalcond[9]=((((-1.0)*cj4*x198))+new_r10+(((-1.0)*new_r22*x189*x190)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x199=((1.0)*sj4);
CheckValue<IkReal> x200=IKPowWithIntegerCheck(new_r22,-1);
if(!x200.valid){
continue;
}
if( IKabs(((x200.value)*(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*x199)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r11))+(((-1.0)*new_r01*x199)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x200.value)*(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*x199))))))+IKsqr((((cj4*new_r11))+(((-1.0)*new_r01*x199))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((x200.value)*(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*x199))))), (((cj4*new_r11))+(((-1.0)*new_r01*x199))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x201=IKsin(j6);
IkReal x202=IKcos(j6);
IkReal x203=((1.0)*sj4);
IkReal x204=(cj4*new_r01);
IkReal x205=(new_r10*sj4);
IkReal x206=(new_r11*sj4);
IkReal x207=(cj4*new_r00);
IkReal x208=((1.0)*x202);
IkReal x209=(sj4*x201);
IkReal x210=(new_r22*x201);
IkReal x211=((1.0)*x201);
evalcond[0]=(x210+x206+x204);
evalcond[1]=(x201+((new_r22*x204))+((new_r22*x206)));
evalcond[2]=((((-1.0)*new_r00*x203))+((cj4*new_r10))+(((-1.0)*x211)));
evalcond[3]=(((cj4*new_r11))+(((-1.0)*x208))+(((-1.0)*new_r01*x203)));
evalcond[4]=(((cj4*x210))+((sj4*x202))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x208))+x207+x205);
evalcond[6]=(x209+new_r00+(((-1.0)*cj4*new_r22*x208)));
evalcond[7]=((((-1.0)*cj4*x208))+((new_r22*x209))+new_r11);
evalcond[8]=((((-1.0)*x208))+((new_r22*x205))+((new_r22*x207)));
evalcond[9]=((((-1.0)*new_r22*x202*x203))+(((-1.0)*cj4*x211))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x212=cj4*cj4;
IkReal x213=(cj4*new_r22);
CheckValue<IkReal> x214=IKPowWithIntegerCheck(IKsign(((-1.0)+(((-1.0)*x212*(new_r22*new_r22)))+x212)),-1);
if(!x214.valid){
continue;
}
CheckValue<IkReal> x215 = IKatan2WithCheck(IkReal((((new_r00*sj4))+((new_r01*x213)))),IkReal((((new_r01*sj4))+(((-1.0)*new_r00*x213)))),IKFAST_ATAN2_MAGTHRESH);
if(!x215.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x214.value)))+(x215.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x216=IKsin(j6);
IkReal x217=IKcos(j6);
IkReal x218=((1.0)*sj4);
IkReal x219=(cj4*new_r01);
IkReal x220=(new_r10*sj4);
IkReal x221=(new_r11*sj4);
IkReal x222=(cj4*new_r00);
IkReal x223=((1.0)*x217);
IkReal x224=(sj4*x216);
IkReal x225=(new_r22*x216);
IkReal x226=((1.0)*x216);
evalcond[0]=(x219+x221+x225);
evalcond[1]=(((new_r22*x219))+x216+((new_r22*x221)));
evalcond[2]=(((cj4*new_r10))+(((-1.0)*new_r00*x218))+(((-1.0)*x226)));
evalcond[3]=(((cj4*new_r11))+(((-1.0)*new_r01*x218))+(((-1.0)*x223)));
evalcond[4]=(((cj4*x225))+new_r01+((sj4*x217)));
evalcond[5]=(x220+x222+(((-1.0)*new_r22*x223)));
evalcond[6]=(x224+(((-1.0)*cj4*new_r22*x223))+new_r00);
evalcond[7]=((((-1.0)*cj4*x223))+((new_r22*x224))+new_r11);
evalcond[8]=(((new_r22*x222))+((new_r22*x220))+(((-1.0)*x223)));
evalcond[9]=((((-1.0)*cj4*x226))+new_r10+(((-1.0)*new_r22*x217*x218)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x228=IKPowWithIntegerCheck(sj5,-1);
if(!x228.valid){
continue;
}
IkReal x227=x228.value;
CheckValue<IkReal> x229=IKPowWithIntegerCheck(new_r12,-1);
if(!x229.valid){
continue;
}
if( IKabs((x227*(x229.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x227)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x227*(x229.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))))+IKsqr((new_r02*x227))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x227*(x229.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))), (new_r02*x227));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x230=IKcos(j4);
IkReal x231=IKsin(j4);
IkReal x232=((1.0)*sj5);
IkReal x233=(new_r12*x231);
IkReal x234=(new_r02*x230);
IkReal x235=(sj5*x230);
IkReal x236=(sj5*x231);
evalcond[0]=((((-1.0)*x230*x232))+new_r02);
evalcond[1]=((((-1.0)*x231*x232))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x231))+((new_r12*x230)));
evalcond[3]=((((-1.0)*x232))+x233+x234);
evalcond[4]=(((new_r10*x236))+((new_r00*x235))+((cj5*new_r20)));
evalcond[5]=(((new_r11*x236))+((new_r01*x235))+((cj5*new_r21)));
evalcond[6]=((-1.0)+((cj5*new_r22))+((sj5*x233))+((sj5*x234)));
evalcond[7]=((((-1.0)*new_r22*x232))+((cj5*x234))+((cj5*x233)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
j6eval[0]=sj4;
j6eval[1]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=cj4;
j6eval[1]=cj5;
j6eval[2]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=new_r12;
j6eval[1]=IKsign(new_r12);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=cj5;
j6eval[1]=IKsign(cj5);
j6eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=new_r12;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x237=IKcos(j6);
IkReal x238=((1.0)*(IKsin(j6)));
evalcond[0]=(x237+new_r20);
evalcond[1]=((((-1.0)*x238))+new_r21);
evalcond[2]=((((-1.0)*x238))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x237)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x239=IKsin(j6);
IkReal x240=((1.0)*(IKcos(j6)));
evalcond[0]=(x239+new_r21);
evalcond[1]=((((-1.0)*x240))+new_r20);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x239)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x240)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r12);
evalcond[1]=new_r20;
evalcond[2]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r12=0;
j6eval[0]=cj5;
j6eval[1]=IKsign(cj5);
j6eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r12=0;
j6eval[0]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r11;
evalcond[2]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x241=IKsin(j6);
IkReal x242=IKcos(j6);
evalcond[0]=x241;
evalcond[1]=((-1.0)*x242);
evalcond[2]=((((-1.0)*x241))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x242))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r11;
evalcond[2]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x243=IKsin(j6);
IkReal x244=IKcos(j6);
evalcond[0]=x243;
evalcond[1]=((-1.0)*x244);
evalcond[2]=((((-1.0)*x243))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x244))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x245=IKsin(j6);
IkReal x246=IKcos(j6);
IkReal x247=((-1.0)*x246);
evalcond[0]=x245;
evalcond[1]=(cj5*x245);
evalcond[2]=x247;
evalcond[3]=(cj5*x247);
evalcond[4]=((((-1.0)*x245))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x246))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x248=IKPowWithIntegerCheck(cj5,-1);
if(!x248.valid){
continue;
}
if( IKabs(((-1.0)*cj5*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r10*(x248.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*cj5*new_r11))+IKsqr((new_r10*(x248.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*cj5*new_r11), (new_r10*(x248.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x249=IKsin(j6);
IkReal x250=IKcos(j6);
IkReal x251=((1.0)*x250);
evalcond[0]=(((cj5*x249))+new_r11);
evalcond[1]=(((cj5*new_r11))+x249);
evalcond[2]=((((-1.0)*cj5*x251))+new_r10);
evalcond[3]=((((-1.0)*x249))+(((-1.0)*new_r00)));
evalcond[4]=((((-1.0)*new_r01))+(((-1.0)*x251)));
evalcond[5]=(((cj5*new_r10))+(((-1.0)*x251)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x252 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x252.valid){
continue;
}
CheckValue<IkReal> x253=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x253.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x252.value)+(((1.5707963267949)*(x253.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x254=IKsin(j6);
IkReal x255=IKcos(j6);
IkReal x256=((1.0)*x255);
evalcond[0]=(((cj5*x254))+new_r11);
evalcond[1]=(((cj5*new_r11))+x254);
evalcond[2]=((((-1.0)*cj5*x256))+new_r10);
evalcond[3]=((((-1.0)*new_r00))+(((-1.0)*x254)));
evalcond[4]=((((-1.0)*new_r01))+(((-1.0)*x256)));
evalcond[5]=(((cj5*new_r10))+(((-1.0)*x256)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x257=IKsin(j6);
IkReal x258=IKcos(j6);
IkReal x259=((-1.0)*x258);
evalcond[0]=x257;
evalcond[1]=(new_r22*x257);
evalcond[2]=x259;
evalcond[3]=(new_r22*x259);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x257)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x258)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x260=IKPowWithIntegerCheck(new_r12,-1);
if(!x260.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x260.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x260.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x260.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x261=IKsin(j6);
IkReal x262=IKcos(j6);
IkReal x263=((1.0)*sj5);
IkReal x264=((1.0)*x262);
IkReal x265=((1.0)*x261);
evalcond[0]=(((new_r12*x262))+new_r20);
evalcond[1]=(((cj5*x261))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x265))+new_r21);
evalcond[3]=((((-1.0)*cj5*x264))+new_r10);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x265)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x264)));
evalcond[6]=(((cj5*new_r11))+(((-1.0)*new_r21*x263))+x261);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*new_r20*x263))+(((-1.0)*x264)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x266 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x266.valid){
continue;
}
CheckValue<IkReal> x267=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x267.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x266.value)+(((1.5707963267949)*(x267.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x268=IKsin(j6);
IkReal x269=IKcos(j6);
IkReal x270=((1.0)*sj5);
IkReal x271=((1.0)*x269);
IkReal x272=((1.0)*x268);
evalcond[0]=(((new_r12*x269))+new_r20);
evalcond[1]=(((cj5*x268))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x272))+new_r21);
evalcond[3]=((((-1.0)*cj5*x271))+new_r10);
evalcond[4]=((((-1.0)*x272))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x271))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+(((-1.0)*new_r21*x270))+x268);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*new_r20*x270))+(((-1.0)*x271)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x273 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x273.valid){
continue;
}
CheckValue<IkReal> x274=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x274.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x273.value)+(((1.5707963267949)*(x274.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x275=IKsin(j6);
IkReal x276=IKcos(j6);
IkReal x277=((1.0)*sj5);
IkReal x278=((1.0)*x276);
IkReal x279=((1.0)*x275);
evalcond[0]=(new_r20+((new_r12*x276)));
evalcond[1]=(((cj5*x275))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x279))+new_r21);
evalcond[3]=((((-1.0)*cj5*x278))+new_r10);
evalcond[4]=((((-1.0)*x279))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x278))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+(((-1.0)*new_r21*x277))+x275);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*new_r20*x277))+(((-1.0)*x278)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x280=IKsin(j6);
IkReal x281=IKcos(j6);
CheckValue<IkReal> x286=IKPowWithIntegerCheck(new_r12,-1);
if(!x286.valid){
continue;
}
IkReal x282=x286.value;
IkReal x283=new_r22*new_r22;
IkReal x284=((1.0)*x281);
IkReal x285=(x282*x283);
evalcond[0]=(((new_r12*x280))+new_r21);
evalcond[1]=((((-1.0)*x280))+new_r00);
evalcond[2]=((((-1.0)*x284))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x284))+new_r20);
evalcond[4]=((((-1.0)*new_r11))+((cj5*x280)));
evalcond[5]=((((-1.0)*new_r10))+(((-1.0)*cj5*x284)));
evalcond[6]=(((new_r21*x285))+((new_r12*new_r21))+x280);
evalcond[7]=(((new_r12*new_r20))+((new_r20*x285))+(((-1.0)*x284)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x287=IKcos(j6);
IkReal x288=IKsin(j6);
IkReal x289=((1.0)*sj4);
IkReal x290=((1.0)*x288);
IkReal x291=((1.0)*x287);
evalcond[0]=(x287+new_r20);
evalcond[1]=((((-1.0)*x290))+new_r21);
evalcond[2]=(new_r01+((sj4*x287)));
evalcond[3]=(new_r00+((sj4*x288)));
evalcond[4]=((((-1.0)*cj4*x291))+new_r11);
evalcond[5]=((((-1.0)*cj4*x290))+new_r10);
evalcond[6]=(((cj4*new_r10))+(((-1.0)*x290))+(((-1.0)*new_r00*x289)));
evalcond[7]=(((cj4*new_r11))+(((-1.0)*x291))+(((-1.0)*new_r01*x289)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x292=IKcos(j6);
IkReal x293=IKsin(j6);
IkReal x294=((1.0)*sj4);
IkReal x295=((1.0)*x292);
IkReal x296=((1.0)*x293);
evalcond[0]=(x293+new_r21);
evalcond[1]=((((-1.0)*x295))+new_r20);
evalcond[2]=(((sj4*x292))+new_r01);
evalcond[3]=(((sj4*x293))+new_r00);
evalcond[4]=((((-1.0)*cj4*x295))+new_r11);
evalcond[5]=((((-1.0)*cj4*x296))+new_r10);
evalcond[6]=(((cj4*new_r10))+(((-1.0)*x296))+(((-1.0)*new_r00*x294)));
evalcond[7]=((((-1.0)*new_r01*x294))+((cj4*new_r11))+(((-1.0)*x295)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x297=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*x297))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x297)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x297))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x297))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*x297))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x297))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x298=IKsin(j6);
IkReal x299=IKcos(j6);
IkReal x300=((1.0)*sj4);
IkReal x301=((1.0)*x299);
IkReal x302=(sj4*x298);
IkReal x303=(sj4*x299);
IkReal x304=(cj4*x298);
IkReal x305=(cj4*x301);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x298);
evalcond[1]=(x304+x303+new_r01);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x301)));
evalcond[3]=((((-1.0)*x298))+((cj4*new_r10))+(((-1.0)*new_r00*x300)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x300))+(((-1.0)*x301)));
evalcond[5]=(x302+new_r00+(((-1.0)*x305)));
evalcond[6]=(x302+new_r11+(((-1.0)*x305)));
evalcond[7]=((((-1.0)*x304))+(((-1.0)*x299*x300))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x306=((1.0)*new_r00);
if( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x306)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x306)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x306))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x306))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x306))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x306))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x307=IKcos(j6);
IkReal x308=IKsin(j6);
IkReal x309=((1.0)*sj4);
IkReal x310=((1.0)*x308);
IkReal x311=(sj4*x307);
IkReal x312=((1.0)*x307);
IkReal x313=(cj4*x310);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x307);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x310)));
evalcond[2]=(((sj4*x308))+new_r00+((cj4*x307)));
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x310))+(((-1.0)*new_r00*x309)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x312))+(((-1.0)*new_r01*x309)));
evalcond[5]=(x311+(((-1.0)*x313))+new_r01);
evalcond[6]=(x311+(((-1.0)*x313))+new_r10);
evalcond[7]=((((-1.0)*x308*x309))+(((-1.0)*cj4*x312))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x314=IKcos(j6);
IkReal x315=IKsin(j6);
IkReal x316=((1.0)*sj5);
IkReal x317=((1.0)*x314);
IkReal x318=((1.0)*x315);
evalcond[0]=(((new_r02*x314))+new_r20);
evalcond[1]=((((-1.0)*x318))+new_r10);
evalcond[2]=((((-1.0)*x317))+new_r11);
evalcond[3]=(((cj5*x315))+new_r01);
evalcond[4]=((((-1.0)*new_r02*x318))+new_r21);
evalcond[5]=((((-1.0)*cj5*x317))+new_r00);
evalcond[6]=((((-1.0)*new_r21*x316))+((cj5*new_r01))+x315);
evalcond[7]=((((-1.0)*new_r20*x316))+((cj5*new_r00))+(((-1.0)*x317)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
j6eval[1]=IKsign(new_r02);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
j6eval[1]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x319=IKcos(j6);
IkReal x320=((1.0)*(IKsin(j6)));
evalcond[0]=(x319+new_r20);
evalcond[1]=((((-1.0)*x320))+new_r21);
evalcond[2]=((((-1.0)*x320))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x319)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x321=IKsin(j6);
IkReal x322=((1.0)*(IKcos(j6)));
evalcond[0]=(x321+new_r21);
evalcond[1]=((((-1.0)*x322))+new_r20);
evalcond[2]=((((-1.0)*x321))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x322))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x323=IKsin(j6);
IkReal x324=IKcos(j6);
IkReal x325=((-1.0)*x324);
evalcond[0]=x323;
evalcond[1]=(new_r22*x323);
evalcond[2]=x325;
evalcond[3]=(new_r22*x325);
evalcond[4]=((((-1.0)*x323))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x324))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x326=IKPowWithIntegerCheck(new_r02,-1);
if(!x326.valid){
continue;
}
CheckValue<IkReal> x327=IKPowWithIntegerCheck(cj5,-1);
if(!x327.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*(x326.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00*(x327.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x326.value)))+IKsqr(((-1.0)*new_r00*(x327.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*(x326.value)), ((-1.0)*new_r00*(x327.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x328=IKsin(j6);
IkReal x329=IKcos(j6);
CheckValue<IkReal> x334=IKPowWithIntegerCheck(new_r02,-1);
if(!x334.valid){
continue;
}
IkReal x330=x334.value;
IkReal x331=new_r22*new_r22;
IkReal x332=((1.0)*x329);
IkReal x333=(x330*x331);
evalcond[0]=(new_r21+((new_r02*x328)));
evalcond[1]=(new_r20+(((-1.0)*new_r02*x332)));
evalcond[2]=((((-1.0)*x328))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x332)));
evalcond[4]=(((cj5*x328))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*cj5*x332))+(((-1.0)*new_r00)));
evalcond[6]=(((new_r21*x333))+x328+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x332))+((new_r02*new_r20))+((new_r20*x333)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x335=IKPowWithIntegerCheck(new_r02,-1);
if(!x335.valid){
continue;
}
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r20*(x335.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr((new_r20*(x335.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), (new_r20*(x335.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x336=IKsin(j6);
IkReal x337=IKcos(j6);
CheckValue<IkReal> x342=IKPowWithIntegerCheck(new_r02,-1);
if(!x342.valid){
continue;
}
IkReal x338=x342.value;
IkReal x339=new_r22*new_r22;
IkReal x340=((1.0)*x337);
IkReal x341=(x338*x339);
evalcond[0]=(((new_r02*x336))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x340))+new_r20);
evalcond[2]=((((-1.0)*x336))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x340)));
evalcond[4]=((((-1.0)*new_r01))+((cj5*x336)));
evalcond[5]=((((-1.0)*cj5*x340))+(((-1.0)*new_r00)));
evalcond[6]=(((new_r21*x341))+x336+((new_r02*new_r21)));
evalcond[7]=(((new_r20*x341))+((new_r02*new_r20))+(((-1.0)*x340)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x343 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x343.valid){
continue;
}
CheckValue<IkReal> x344=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x344.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x343.value)+(((1.5707963267949)*(x344.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x345=IKsin(j6);
IkReal x346=IKcos(j6);
CheckValue<IkReal> x351=IKPowWithIntegerCheck(new_r02,-1);
if(!x351.valid){
continue;
}
IkReal x347=x351.value;
IkReal x348=new_r22*new_r22;
IkReal x349=((1.0)*x346);
IkReal x350=(x347*x348);
evalcond[0]=(((new_r02*x345))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x349))+new_r20);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x345)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x349)));
evalcond[4]=(((cj5*x345))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*cj5*x349))+(((-1.0)*new_r00)));
evalcond[6]=(((new_r21*x350))+x345+((new_r02*new_r21)));
evalcond[7]=(((new_r20*x350))+((new_r02*new_r20))+(((-1.0)*x349)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j6eval[0]=1.0;
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j6]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j6array[2], cj6array[2], sj6array[2], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[2]={true,true};
_nj6 = 2;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x353=IKPowWithIntegerCheck(sj5,-1);
if(!x353.valid){
continue;
}
IkReal x352=x353.value;
CheckValue<IkReal> x354=IKPowWithIntegerCheck(cj4,-1);
if(!x354.valid){
continue;
}
CheckValue<IkReal> x355=IKPowWithIntegerCheck(cj5,-1);
if(!x355.valid){
continue;
}
if( IKabs((x352*(x354.value)*(x355.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x352)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x352*(x354.value)*(x355.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x352))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x352*(x354.value)*(x355.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x352));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x356=IKsin(j6);
IkReal x357=IKcos(j6);
IkReal x358=((1.0)*sj5);
IkReal x359=((1.0)*sj4);
IkReal x360=(cj5*sj4);
IkReal x361=(cj4*new_r01);
IkReal x362=(cj4*new_r00);
IkReal x363=((1.0)*x357);
IkReal x364=(cj5*x356);
IkReal x365=((1.0)*x356);
evalcond[0]=(((sj5*x357))+new_r20);
evalcond[1]=((((-1.0)*x356*x358))+new_r21);
evalcond[2]=(((new_r11*sj4))+x361+x364);
evalcond[3]=((((-1.0)*x365))+((cj4*new_r10))+(((-1.0)*new_r00*x359)));
evalcond[4]=((((-1.0)*x363))+((cj4*new_r11))+(((-1.0)*new_r01*x359)));
evalcond[5]=(((sj4*x357))+((cj4*x364))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x363))+x362);
evalcond[7]=(((sj4*x356))+(((-1.0)*cj4*cj5*x363))+new_r00);
evalcond[8]=((((-1.0)*cj4*x363))+((x356*x360))+new_r11);
evalcond[9]=((((-1.0)*cj4*x365))+(((-1.0)*cj5*x357*x359))+new_r10);
evalcond[10]=(x356+((cj5*x361))+(((-1.0)*new_r21*x358))+((new_r11*x360)));
evalcond[11]=((((-1.0)*x363))+((cj5*x362))+(((-1.0)*new_r20*x358))+((new_r10*x360)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x367=IKPowWithIntegerCheck(sj5,-1);
if(!x367.valid){
continue;
}
IkReal x366=x367.value;
CheckValue<IkReal> x368=IKPowWithIntegerCheck(sj4,-1);
if(!x368.valid){
continue;
}
if( IKabs((x366*(x368.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x366)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x366*(x368.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x366))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x366*(x368.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x366));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x369=IKsin(j6);
IkReal x370=IKcos(j6);
IkReal x371=((1.0)*sj5);
IkReal x372=((1.0)*sj4);
IkReal x373=(cj5*sj4);
IkReal x374=(cj4*new_r01);
IkReal x375=(cj4*new_r00);
IkReal x376=((1.0)*x370);
IkReal x377=(cj5*x369);
IkReal x378=((1.0)*x369);
evalcond[0]=(((sj5*x370))+new_r20);
evalcond[1]=((((-1.0)*x369*x371))+new_r21);
evalcond[2]=(((new_r11*sj4))+x377+x374);
evalcond[3]=((((-1.0)*new_r00*x372))+((cj4*new_r10))+(((-1.0)*x378)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x376))+(((-1.0)*new_r01*x372)));
evalcond[5]=(((sj4*x370))+((cj4*x377))+new_r01);
evalcond[6]=((((-1.0)*cj5*x376))+((new_r10*sj4))+x375);
evalcond[7]=(((sj4*x369))+(((-1.0)*cj4*cj5*x376))+new_r00);
evalcond[8]=(((x369*x373))+(((-1.0)*cj4*x376))+new_r11);
evalcond[9]=((((-1.0)*cj4*x378))+new_r10+(((-1.0)*cj5*x370*x372)));
evalcond[10]=((((-1.0)*new_r21*x371))+((cj5*x374))+x369+((new_r11*x373)));
evalcond[11]=((((-1.0)*new_r20*x371))+(((-1.0)*x376))+((cj5*x375))+((new_r10*x373)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x379=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x379.valid){
continue;
}
CheckValue<IkReal> x380 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x380.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x379.value)))+(x380.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x381=IKsin(j6);
IkReal x382=IKcos(j6);
IkReal x383=((1.0)*sj5);
IkReal x384=((1.0)*sj4);
IkReal x385=(cj5*sj4);
IkReal x386=(cj4*new_r01);
IkReal x387=(cj4*new_r00);
IkReal x388=((1.0)*x382);
IkReal x389=(cj5*x381);
IkReal x390=((1.0)*x381);
evalcond[0]=(((sj5*x382))+new_r20);
evalcond[1]=((((-1.0)*x381*x383))+new_r21);
evalcond[2]=(((new_r11*sj4))+x386+x389);
evalcond[3]=((((-1.0)*x390))+((cj4*new_r10))+(((-1.0)*new_r00*x384)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x384))+(((-1.0)*x388)));
evalcond[5]=(((sj4*x382))+new_r01+((cj4*x389)));
evalcond[6]=(((new_r10*sj4))+x387+(((-1.0)*cj5*x388)));
evalcond[7]=((((-1.0)*cj4*cj5*x388))+((sj4*x381))+new_r00);
evalcond[8]=((((-1.0)*cj4*x388))+new_r11+((x381*x385)));
evalcond[9]=((((-1.0)*cj4*x390))+(((-1.0)*cj5*x382*x384))+new_r10);
evalcond[10]=(x381+((new_r11*x385))+(((-1.0)*new_r21*x383))+((cj5*x386)));
evalcond[11]=((((-1.0)*new_r20*x383))+((new_r10*x385))+(((-1.0)*x388))+((cj5*x387)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x391=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x391.valid){
continue;
}
CheckValue<IkReal> x392 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x392.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x391.value)))+(x392.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
evalcond[0]=(new_r20+((sj5*(IKcos(j6)))));
evalcond[1]=((((-1.0)*sj5*(IKsin(j6))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj5;
j4eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j4eval[2]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=cj6;
j4eval[1]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j6)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), new_r10);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x393=IKsin(j4);
IkReal x394=IKcos(j4);
IkReal x395=((1.0)*sj5);
IkReal x396=(new_r22*x393);
IkReal x397=(new_r11*x393);
IkReal x398=(new_r02*x394);
IkReal x399=(new_r22*x394);
IkReal x400=(new_r12*x393);
IkReal x401=(sj5*x394);
IkReal x402=((1.0)*x393);
IkReal x403=(new_r10*x393);
evalcond[0]=(x393+new_r00);
evalcond[1]=(x399+new_r01);
evalcond[2]=(x396+new_r11);
evalcond[3]=((((-1.0)*x394))+new_r10);
evalcond[4]=((((-1.0)*x394*x395))+new_r02);
evalcond[5]=(new_r12+(((-1.0)*x393*x395)));
evalcond[6]=(x403+((new_r00*x394)));
evalcond[7]=((((-1.0)*new_r02*x402))+((new_r12*x394)));
evalcond[8]=(((new_r11*x394))+(((-1.0)*new_r01*x402)));
evalcond[9]=(x397+((new_r01*x394))+new_r22);
evalcond[10]=((-1.0)+(((-1.0)*new_r00*x402))+((new_r10*x394)));
evalcond[11]=(((sj5*x403))+((new_r00*x401)));
evalcond[12]=(((new_r00*x399))+((new_r10*x396)));
evalcond[13]=((((-1.0)*x395))+x398+x400);
evalcond[14]=(((cj5*new_r21))+((sj5*x397))+((new_r01*x401)));
evalcond[15]=((-1.0)+(new_r22*new_r22)+((sj5*x400))+((sj5*x398)));
evalcond[16]=((((-1.0)*new_r22*x395))+((new_r22*x398))+((new_r12*x396)));
evalcond[17]=((1.0)+((new_r11*x396))+(((-1.0)*sj5*x395))+((new_r01*x399)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j6)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x404=IKcos(j4);
IkReal x405=IKsin(j4);
IkReal x406=((1.0)*sj5);
IkReal x407=((1.0)*x404);
IkReal x408=(new_r22*x405);
IkReal x409=(new_r11*x405);
IkReal x410=(new_r02*x404);
IkReal x411=(new_r01*x404);
IkReal x412=(new_r12*x405);
IkReal x413=(new_r00*x404);
IkReal x414=((1.0)*x405);
IkReal x415=(new_r10*x405);
evalcond[0]=(x404+new_r10);
evalcond[1]=(new_r00+(((-1.0)*x414)));
evalcond[2]=((((-1.0)*x404*x406))+new_r02);
evalcond[3]=(new_r12+(((-1.0)*x405*x406)));
evalcond[4]=(new_r01+(((-1.0)*new_r22*x407)));
evalcond[5]=(new_r11+(((-1.0)*x408)));
evalcond[6]=(x413+x415);
evalcond[7]=(((new_r12*x404))+(((-1.0)*new_r02*x414)));
evalcond[8]=(((new_r11*x404))+(((-1.0)*new_r01*x414)));
evalcond[9]=((1.0)+((new_r10*x404))+(((-1.0)*new_r00*x414)));
evalcond[10]=(((sj5*x413))+((sj5*x415)));
evalcond[11]=(((new_r22*x413))+((new_r10*x408)));
evalcond[12]=(x412+x410+(((-1.0)*x406)));
evalcond[13]=(x409+x411+(((-1.0)*new_r22)));
evalcond[14]=(((sj5*x411))+((cj5*new_r21))+((sj5*x409)));
evalcond[15]=((-1.0)+(new_r22*new_r22)+((sj5*x412))+((sj5*x410)));
evalcond[16]=(((new_r22*x410))+((new_r12*x408))+(((-1.0)*new_r22*x406)));
evalcond[17]=((-1.0)+((new_r22*x411))+((new_r11*x408))+(sj5*sj5));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x416=((1.0)*sj6);
if( IKabs(((((-1.0)*cj6*new_r01))+(((-1.0)*new_r00*x416)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj6*new_r00))+(((-1.0)*new_r01*x416)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj6*new_r01))+(((-1.0)*new_r00*x416))))+IKsqr((((cj6*new_r00))+(((-1.0)*new_r01*x416))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj6*new_r01))+(((-1.0)*new_r00*x416))), (((cj6*new_r00))+(((-1.0)*new_r01*x416))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x417=IKcos(j4);
IkReal x418=IKsin(j4);
IkReal x419=((1.0)*cj6);
IkReal x420=(sj6*x418);
IkReal x421=(cj6*x418);
IkReal x422=(sj6*x417);
IkReal x423=((1.0)*x418);
IkReal x424=(x417*x419);
evalcond[0]=(sj6+((new_r11*x418))+((new_r01*x417)));
evalcond[1]=(x422+x421+new_r01);
evalcond[2]=((((-1.0)*x424))+x420+new_r00);
evalcond[3]=((((-1.0)*x424))+x420+new_r11);
evalcond[4]=(((new_r10*x418))+(((-1.0)*x419))+((new_r00*x417)));
evalcond[5]=((((-1.0)*x422))+(((-1.0)*x418*x419))+new_r10);
evalcond[6]=((((-1.0)*sj6))+(((-1.0)*new_r00*x423))+((new_r10*x417)));
evalcond[7]=(((new_r11*x417))+(((-1.0)*x419))+(((-1.0)*new_r01*x423)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x425=((1.0)*new_r00);
if( IKabs(((((-1.0)*cj6*new_r01))+(((-1.0)*sj6*x425)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj6*x425))+((new_r01*sj6)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj6*new_r01))+(((-1.0)*sj6*x425))))+IKsqr(((((-1.0)*cj6*x425))+((new_r01*sj6))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj6*new_r01))+(((-1.0)*sj6*x425))), ((((-1.0)*cj6*x425))+((new_r01*sj6))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x426=IKsin(j4);
IkReal x427=IKcos(j4);
IkReal x428=((1.0)*sj6);
IkReal x429=(cj6*x426);
IkReal x430=(cj6*x427);
IkReal x431=((1.0)*x426);
IkReal x432=(x427*x428);
evalcond[0]=(cj6+((new_r10*x426))+((new_r00*x427)));
evalcond[1]=(((sj6*x426))+x430+new_r00);
evalcond[2]=((((-1.0)*x432))+x429+new_r01);
evalcond[3]=((((-1.0)*x432))+x429+new_r10);
evalcond[4]=((((-1.0)*x428))+((new_r11*x426))+((new_r01*x427)));
evalcond[5]=((((-1.0)*x430))+(((-1.0)*x426*x428))+new_r11);
evalcond[6]=((((-1.0)*new_r00*x431))+(((-1.0)*x428))+((new_r10*x427)));
evalcond[7]=((((-1.0)*new_r01*x431))+((new_r11*x427))+(((-1.0)*cj6)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x434 = IKatan2WithCheck(IkReal((new_r01*new_r22)),IkReal((new_r11*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x434.valid){
continue;
}
IkReal x433=x434.value;
j4array[0]=((-1.0)*x433);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x433)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x435=IKcos(j4);
IkReal x436=IKsin(j4);
IkReal x437=(new_r00*x435);
IkReal x438=(new_r10*x436);
IkReal x439=((1.0)*x436);
evalcond[0]=(((new_r01*x435))+((new_r11*x436)));
evalcond[1]=(x438+x437);
evalcond[2]=((((-1.0)*new_r00*x439))+((new_r10*x435)));
evalcond[3]=((((-1.0)*new_r01*x439))+((new_r11*x435)));
evalcond[4]=(((new_r22*x438))+((new_r22*x437)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x441 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x441.valid){
continue;
}
IkReal x440=x441.value;
j4array[0]=((-1.0)*x440);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x440)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x442=IKcos(j4);
IkReal x443=IKsin(j4);
IkReal x444=(new_r01*x442);
IkReal x445=(new_r11*x443);
IkReal x446=((1.0)*x443);
evalcond[0]=(x445+x444);
evalcond[1]=((((-1.0)*new_r00*x446))+((new_r10*x442)));
evalcond[2]=((((-1.0)*new_r01*x446))+((new_r11*x442)));
evalcond[3]=(((new_r22*x444))+((new_r22*x445)));
evalcond[4]=(((new_r10*new_r22*x443))+((new_r00*new_r22*x442)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x448 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x448.valid){
continue;
}
IkReal x447=x448.value;
j4array[0]=((-1.0)*x447);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x447)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x449=IKcos(j4);
IkReal x450=IKsin(j4);
IkReal x451=(new_r00*x449);
IkReal x452=(new_r22*x450);
IkReal x453=((1.0)*x450);
evalcond[0]=(((new_r10*x450))+x451);
evalcond[1]=((((-1.0)*new_r00*x453))+((new_r10*x449)));
evalcond[2]=((((-1.0)*new_r01*x453))+((new_r11*x449)));
evalcond[3]=(((new_r11*x452))+((new_r01*new_r22*x449)));
evalcond[4]=(((new_r10*x452))+((new_r22*x451)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x455=IKPowWithIntegerCheck(sj5,-1);
if(!x455.valid){
continue;
}
IkReal x454=x455.value;
CheckValue<IkReal> x456=IKPowWithIntegerCheck(cj6,-1);
if(!x456.valid){
continue;
}
if( IKabs((x454*(x456.value)*(((((-1.0)*new_r01*sj5))+(((-1.0)*cj5*new_r02*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x454)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x454*(x456.value)*(((((-1.0)*new_r01*sj5))+(((-1.0)*cj5*new_r02*sj6))))))+IKsqr((new_r02*x454))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x454*(x456.value)*(((((-1.0)*new_r01*sj5))+(((-1.0)*cj5*new_r02*sj6))))), (new_r02*x454));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x457=IKcos(j4);
IkReal x458=IKsin(j4);
IkReal x459=((1.0)*cj6);
IkReal x460=(cj5*sj6);
IkReal x461=((1.0)*sj5);
IkReal x462=((1.0)*sj6);
IkReal x463=(cj5*x458);
IkReal x464=(new_r11*x458);
IkReal x465=(cj5*x457);
IkReal x466=(new_r02*x457);
IkReal x467=(new_r12*x458);
IkReal x468=(sj5*x457);
IkReal x469=((1.0)*x458);
IkReal x470=(new_r10*x458);
evalcond[0]=(new_r02+(((-1.0)*x457*x461)));
evalcond[1]=((((-1.0)*x458*x461))+new_r12);
evalcond[2]=(((new_r12*x457))+(((-1.0)*new_r02*x469)));
evalcond[3]=(((cj6*x458))+new_r01+((x457*x460)));
evalcond[4]=((((-1.0)*x461))+x467+x466);
evalcond[5]=(((new_r01*x457))+x460+x464);
evalcond[6]=(((sj6*x458))+(((-1.0)*x459*x465))+new_r00);
evalcond[7]=(new_r11+(((-1.0)*x457*x459))+((x458*x460)));
evalcond[8]=(((new_r10*x457))+(((-1.0)*x462))+(((-1.0)*new_r00*x469)));
evalcond[9]=(((new_r11*x457))+(((-1.0)*new_r01*x469))+(((-1.0)*x459)));
evalcond[10]=(((new_r00*x457))+(((-1.0)*cj5*x459))+x470);
evalcond[11]=((((-1.0)*x459*x463))+new_r10+(((-1.0)*x457*x462)));
evalcond[12]=(((sj5*x470))+((new_r00*x468))+((cj5*new_r20)));
evalcond[13]=(((new_r01*x468))+((cj5*new_r21))+((sj5*x464)));
evalcond[14]=((-1.0)+((cj5*new_r22))+((sj5*x467))+((sj5*x466)));
evalcond[15]=(((new_r12*x463))+(((-1.0)*new_r22*x461))+((new_r02*x465)));
evalcond[16]=((((-1.0)*new_r21*x461))+((new_r11*x463))+sj6+((new_r01*x465)));
evalcond[17]=(((new_r10*x463))+((new_r00*x465))+(((-1.0)*new_r20*x461))+(((-1.0)*x459)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x471=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x471.valid){
continue;
}
CheckValue<IkReal> x472 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x472.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x471.value)))+(x472.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x473=IKcos(j4);
IkReal x474=IKsin(j4);
IkReal x475=((1.0)*cj6);
IkReal x476=(cj5*sj6);
IkReal x477=((1.0)*sj5);
IkReal x478=((1.0)*sj6);
IkReal x479=(cj5*x474);
IkReal x480=(new_r11*x474);
IkReal x481=(cj5*x473);
IkReal x482=(new_r02*x473);
IkReal x483=(new_r12*x474);
IkReal x484=(sj5*x473);
IkReal x485=((1.0)*x474);
IkReal x486=(new_r10*x474);
evalcond[0]=((((-1.0)*x473*x477))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x474*x477)));
evalcond[2]=(((new_r12*x473))+(((-1.0)*new_r02*x485)));
evalcond[3]=(((x473*x476))+((cj6*x474))+new_r01);
evalcond[4]=((((-1.0)*x477))+x483+x482);
evalcond[5]=(((new_r01*x473))+x480+x476);
evalcond[6]=(((sj6*x474))+(((-1.0)*x475*x481))+new_r00);
evalcond[7]=((((-1.0)*x473*x475))+((x474*x476))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x485))+((new_r10*x473))+(((-1.0)*x478)));
evalcond[9]=((((-1.0)*new_r01*x485))+((new_r11*x473))+(((-1.0)*x475)));
evalcond[10]=((((-1.0)*cj5*x475))+((new_r00*x473))+x486);
evalcond[11]=((((-1.0)*x475*x479))+(((-1.0)*x473*x478))+new_r10);
evalcond[12]=(((cj5*new_r20))+((sj5*x486))+((new_r00*x484)));
evalcond[13]=(((cj5*new_r21))+((sj5*x480))+((new_r01*x484)));
evalcond[14]=((-1.0)+((cj5*new_r22))+((sj5*x483))+((sj5*x482)));
evalcond[15]=(((new_r12*x479))+((new_r02*x481))+(((-1.0)*new_r22*x477)));
evalcond[16]=(sj6+(((-1.0)*new_r21*x477))+((new_r11*x479))+((new_r01*x481)));
evalcond[17]=(((new_r10*x479))+(((-1.0)*x475))+((new_r00*x481))+(((-1.0)*new_r20*x477)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x487=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x487.valid){
continue;
}
CheckValue<IkReal> x488 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x488.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x487.value)))+(x488.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x489=IKcos(j4);
IkReal x490=IKsin(j4);
IkReal x491=((1.0)*sj5);
IkReal x492=(new_r12*x490);
IkReal x493=(new_r02*x489);
IkReal x494=(sj5*x489);
IkReal x495=(sj5*x490);
evalcond[0]=((((-1.0)*x489*x491))+new_r02);
evalcond[1]=((((-1.0)*x490*x491))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x490))+((new_r12*x489)));
evalcond[3]=((((-1.0)*x491))+x492+x493);
evalcond[4]=(((cj5*new_r20))+((new_r10*x495))+((new_r00*x494)));
evalcond[5]=(((cj5*new_r21))+((new_r11*x495))+((new_r01*x494)));
evalcond[6]=((-1.0)+((cj5*new_r22))+((sj5*x492))+((sj5*x493)));
evalcond[7]=(((cj5*x492))+((cj5*x493))+(((-1.0)*new_r22*x491)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
j6eval[0]=sj4;
j6eval[1]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=cj4;
j6eval[1]=cj5;
j6eval[2]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=new_r12;
j6eval[1]=IKsign(new_r12);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=cj5;
j6eval[1]=IKsign(cj5);
j6eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=new_r12;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x496=IKcos(j6);
IkReal x497=((1.0)*(IKsin(j6)));
evalcond[0]=(x496+new_r20);
evalcond[1]=((((-1.0)*x497))+new_r21);
evalcond[2]=((((-1.0)*x497))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x496))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x498=IKsin(j6);
IkReal x499=((1.0)*(IKcos(j6)));
evalcond[0]=(x498+new_r21);
evalcond[1]=((((-1.0)*x499))+new_r20);
evalcond[2]=((((-1.0)*x498))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x499))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r12);
evalcond[1]=new_r20;
evalcond[2]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r12=0;
j6eval[0]=cj5;
j6eval[1]=IKsign(cj5);
j6eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r12=0;
j6eval[0]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r11;
evalcond[2]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x500=IKsin(j6);
IkReal x501=IKcos(j6);
evalcond[0]=x500;
evalcond[1]=((-1.0)*x501);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x500)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x501)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r11;
evalcond[2]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x502=IKsin(j6);
IkReal x503=IKcos(j6);
evalcond[0]=x502;
evalcond[1]=((-1.0)*x503);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x502)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x503)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x504=IKsin(j6);
IkReal x505=IKcos(j6);
IkReal x506=((-1.0)*x505);
evalcond[0]=x504;
evalcond[1]=(cj5*x504);
evalcond[2]=x506;
evalcond[3]=(cj5*x506);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x504)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x505)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x507=IKPowWithIntegerCheck(cj5,-1);
if(!x507.valid){
continue;
}
if( IKabs(((-1.0)*cj5*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r10*(x507.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*cj5*new_r11))+IKsqr((new_r10*(x507.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*cj5*new_r11), (new_r10*(x507.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x508=IKsin(j6);
IkReal x509=IKcos(j6);
IkReal x510=((1.0)*x509);
evalcond[0]=(((cj5*x508))+new_r11);
evalcond[1]=(((cj5*new_r11))+x508);
evalcond[2]=((((-1.0)*cj5*x510))+new_r10);
evalcond[3]=((((-1.0)*new_r00))+(((-1.0)*x508)));
evalcond[4]=((((-1.0)*new_r01))+(((-1.0)*x510)));
evalcond[5]=(((cj5*new_r10))+(((-1.0)*x510)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x511 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x511.valid){
continue;
}
CheckValue<IkReal> x512=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x512.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x511.value)+(((1.5707963267949)*(x512.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x513=IKsin(j6);
IkReal x514=IKcos(j6);
IkReal x515=((1.0)*x514);
evalcond[0]=(((cj5*x513))+new_r11);
evalcond[1]=(((cj5*new_r11))+x513);
evalcond[2]=((((-1.0)*cj5*x515))+new_r10);
evalcond[3]=((((-1.0)*x513))+(((-1.0)*new_r00)));
evalcond[4]=((((-1.0)*new_r01))+(((-1.0)*x515)));
evalcond[5]=(((cj5*new_r10))+(((-1.0)*x515)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x516=IKsin(j6);
IkReal x517=IKcos(j6);
IkReal x518=((-1.0)*x517);
evalcond[0]=x516;
evalcond[1]=(new_r22*x516);
evalcond[2]=x518;
evalcond[3]=(new_r22*x518);
evalcond[4]=((((-1.0)*x516))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x517))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x519=IKPowWithIntegerCheck(new_r12,-1);
if(!x519.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x519.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x519.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x519.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x520=IKsin(j6);
IkReal x521=IKcos(j6);
IkReal x522=((1.0)*sj5);
IkReal x523=((1.0)*x521);
IkReal x524=((1.0)*x520);
evalcond[0]=(((new_r12*x521))+new_r20);
evalcond[1]=(((cj5*x520))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x524))+new_r21);
evalcond[3]=(new_r10+(((-1.0)*cj5*x523)));
evalcond[4]=((((-1.0)*x524))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x523))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+(((-1.0)*new_r21*x522))+x520);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*new_r20*x522))+(((-1.0)*x523)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x525 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x525.valid){
continue;
}
CheckValue<IkReal> x526=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x526.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x525.value)+(((1.5707963267949)*(x526.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x527=IKsin(j6);
IkReal x528=IKcos(j6);
IkReal x529=((1.0)*sj5);
IkReal x530=((1.0)*x528);
IkReal x531=((1.0)*x527);
evalcond[0]=(((new_r12*x528))+new_r20);
evalcond[1]=(((cj5*x527))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x531))+new_r21);
evalcond[3]=(new_r10+(((-1.0)*cj5*x530)));
evalcond[4]=((((-1.0)*x531))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x530))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+(((-1.0)*new_r21*x529))+x527);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*new_r20*x529))+(((-1.0)*x530)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x532 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x532.valid){
continue;
}
CheckValue<IkReal> x533=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x533.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x532.value)+(((1.5707963267949)*(x533.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x534=IKsin(j6);
IkReal x535=IKcos(j6);
IkReal x536=((1.0)*sj5);
IkReal x537=((1.0)*x535);
IkReal x538=((1.0)*x534);
evalcond[0]=(((new_r12*x535))+new_r20);
evalcond[1]=(((cj5*x534))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x538))+new_r21);
evalcond[3]=(new_r10+(((-1.0)*cj5*x537)));
evalcond[4]=((((-1.0)*x538))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x537))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+(((-1.0)*new_r21*x536))+x534);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*x537))+(((-1.0)*new_r20*x536)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x539=IKsin(j6);
IkReal x540=IKcos(j6);
CheckValue<IkReal> x545=IKPowWithIntegerCheck(new_r12,-1);
if(!x545.valid){
continue;
}
IkReal x541=x545.value;
IkReal x542=new_r22*new_r22;
IkReal x543=((1.0)*x540);
IkReal x544=(x541*x542);
evalcond[0]=(((new_r12*x539))+new_r21);
evalcond[1]=((((-1.0)*x539))+new_r00);
evalcond[2]=((((-1.0)*x543))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x543))+new_r20);
evalcond[4]=(((cj5*x539))+(((-1.0)*new_r11)));
evalcond[5]=((((-1.0)*new_r10))+(((-1.0)*cj5*x543)));
evalcond[6]=(((new_r12*new_r21))+x539+((new_r21*x544)));
evalcond[7]=((((-1.0)*x543))+((new_r12*new_r20))+((new_r20*x544)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x546=IKcos(j6);
IkReal x547=IKsin(j6);
IkReal x548=((1.0)*sj4);
IkReal x549=((1.0)*x547);
IkReal x550=((1.0)*x546);
evalcond[0]=(x546+new_r20);
evalcond[1]=((((-1.0)*x549))+new_r21);
evalcond[2]=(new_r01+((sj4*x546)));
evalcond[3]=(new_r00+((sj4*x547)));
evalcond[4]=(new_r11+(((-1.0)*cj4*x550)));
evalcond[5]=(new_r10+(((-1.0)*cj4*x549)));
evalcond[6]=(((cj4*new_r10))+(((-1.0)*new_r00*x548))+(((-1.0)*x549)));
evalcond[7]=(((cj4*new_r11))+(((-1.0)*new_r01*x548))+(((-1.0)*x550)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x551=IKcos(j6);
IkReal x552=IKsin(j6);
IkReal x553=((1.0)*sj4);
IkReal x554=((1.0)*x551);
IkReal x555=((1.0)*x552);
evalcond[0]=(x552+new_r21);
evalcond[1]=((((-1.0)*x554))+new_r20);
evalcond[2]=(((sj4*x551))+new_r01);
evalcond[3]=(((sj4*x552))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*cj4*x554)));
evalcond[5]=(new_r10+(((-1.0)*cj4*x555)));
evalcond[6]=(((cj4*new_r10))+(((-1.0)*new_r00*x553))+(((-1.0)*x555)));
evalcond[7]=(((cj4*new_r11))+(((-1.0)*new_r01*x553))+(((-1.0)*x554)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x556=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x556)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x556)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x556))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x556))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x556))), (((cj4*new_r00))+(((-1.0)*sj4*x556))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x557=IKsin(j6);
IkReal x558=IKcos(j6);
IkReal x559=((1.0)*sj4);
IkReal x560=((1.0)*x558);
IkReal x561=(sj4*x557);
IkReal x562=(sj4*x558);
IkReal x563=(cj4*x557);
IkReal x564=(cj4*x560);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x557);
evalcond[1]=(x562+x563+new_r01);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x560)));
evalcond[3]=((((-1.0)*x557))+((cj4*new_r10))+(((-1.0)*new_r00*x559)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x559))+(((-1.0)*x560)));
evalcond[5]=(x561+new_r00+(((-1.0)*x564)));
evalcond[6]=(x561+new_r11+(((-1.0)*x564)));
evalcond[7]=((((-1.0)*x563))+(((-1.0)*x558*x559))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x565=((1.0)*new_r00);
if( IKabs(((((-1.0)*sj4*x565))+((cj4*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x565)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj4*x565))+((cj4*new_r01))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x565))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*sj4*x565))+((cj4*new_r01))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x565))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x566=IKcos(j6);
IkReal x567=IKsin(j6);
IkReal x568=((1.0)*sj4);
IkReal x569=((1.0)*x567);
IkReal x570=(sj4*x566);
IkReal x571=((1.0)*x566);
IkReal x572=(cj4*x569);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x566);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x569)));
evalcond[2]=(((sj4*x567))+new_r00+((cj4*x566)));
evalcond[3]=((((-1.0)*new_r00*x568))+((cj4*new_r10))+(((-1.0)*x569)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x571))+(((-1.0)*new_r01*x568)));
evalcond[5]=((((-1.0)*x572))+x570+new_r01);
evalcond[6]=((((-1.0)*x572))+x570+new_r10);
evalcond[7]=((((-1.0)*cj4*x571))+(((-1.0)*x567*x568))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x573=IKcos(j6);
IkReal x574=IKsin(j6);
IkReal x575=((1.0)*sj5);
IkReal x576=((1.0)*x573);
IkReal x577=((1.0)*x574);
evalcond[0]=(new_r20+((new_r02*x573)));
evalcond[1]=((((-1.0)*x577))+new_r10);
evalcond[2]=((((-1.0)*x576))+new_r11);
evalcond[3]=(((cj5*x574))+new_r01);
evalcond[4]=((((-1.0)*new_r02*x577))+new_r21);
evalcond[5]=((((-1.0)*cj5*x576))+new_r00);
evalcond[6]=(((cj5*new_r01))+x574+(((-1.0)*new_r21*x575)));
evalcond[7]=(((cj5*new_r00))+(((-1.0)*x576))+(((-1.0)*new_r20*x575)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
j6eval[1]=IKsign(new_r02);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
j6eval[1]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x578=IKcos(j6);
IkReal x579=((1.0)*(IKsin(j6)));
evalcond[0]=(x578+new_r20);
evalcond[1]=((((-1.0)*x579))+new_r21);
evalcond[2]=((((-1.0)*x579))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x578))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x580=IKsin(j6);
IkReal x581=((1.0)*(IKcos(j6)));
evalcond[0]=(x580+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x581)));
evalcond[2]=((((-1.0)*x580))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x581)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x582=IKsin(j6);
IkReal x583=IKcos(j6);
IkReal x584=((-1.0)*x583);
evalcond[0]=x582;
evalcond[1]=(new_r22*x582);
evalcond[2]=x584;
evalcond[3]=(new_r22*x584);
evalcond[4]=((((-1.0)*x582))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x583))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x585=IKPowWithIntegerCheck(new_r02,-1);
if(!x585.valid){
continue;
}
CheckValue<IkReal> x586=IKPowWithIntegerCheck(cj5,-1);
if(!x586.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*(x585.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00*(x586.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x585.value)))+IKsqr(((-1.0)*new_r00*(x586.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*(x585.value)), ((-1.0)*new_r00*(x586.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x587=IKsin(j6);
IkReal x588=IKcos(j6);
CheckValue<IkReal> x593=IKPowWithIntegerCheck(new_r02,-1);
if(!x593.valid){
continue;
}
IkReal x589=x593.value;
IkReal x590=new_r22*new_r22;
IkReal x591=((1.0)*x588);
IkReal x592=(x589*x590);
evalcond[0]=(((new_r02*x587))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x591))+new_r20);
evalcond[2]=((((-1.0)*x587))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x591))+(((-1.0)*new_r11)));
evalcond[4]=(((cj5*x587))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*cj5*x591))+(((-1.0)*new_r00)));
evalcond[6]=(x587+((new_r21*x592))+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x591))+((new_r20*x592))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x594=IKPowWithIntegerCheck(new_r02,-1);
if(!x594.valid){
continue;
}
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r20*(x594.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr((new_r20*(x594.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), (new_r20*(x594.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x595=IKsin(j6);
IkReal x596=IKcos(j6);
CheckValue<IkReal> x601=IKPowWithIntegerCheck(new_r02,-1);
if(!x601.valid){
continue;
}
IkReal x597=x601.value;
IkReal x598=new_r22*new_r22;
IkReal x599=((1.0)*x596);
IkReal x600=(x597*x598);
evalcond[0]=(((new_r02*x595))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x599))+new_r20);
evalcond[2]=((((-1.0)*x595))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x599))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*new_r01))+((cj5*x595)));
evalcond[5]=((((-1.0)*cj5*x599))+(((-1.0)*new_r00)));
evalcond[6]=(((new_r21*x600))+x595+((new_r02*new_r21)));
evalcond[7]=(((new_r20*x600))+(((-1.0)*x599))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x602 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x602.valid){
continue;
}
CheckValue<IkReal> x603=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x603.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x602.value)+(((1.5707963267949)*(x603.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x604=IKsin(j6);
IkReal x605=IKcos(j6);
CheckValue<IkReal> x610=IKPowWithIntegerCheck(new_r02,-1);
if(!x610.valid){
continue;
}
IkReal x606=x610.value;
IkReal x607=new_r22*new_r22;
IkReal x608=((1.0)*x605);
IkReal x609=(x606*x607);
evalcond[0]=(((new_r02*x604))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x608))+new_r20);
evalcond[2]=((((-1.0)*x604))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x608)));
evalcond[4]=(((cj5*x604))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*cj5*x608))+(((-1.0)*new_r00)));
evalcond[6]=(((new_r21*x609))+x604+((new_r02*new_r21)));
evalcond[7]=(((new_r20*x609))+(((-1.0)*x608))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j6eval[0]=1.0;
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j6]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j6array[2], cj6array[2], sj6array[2], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[2]={true,true};
_nj6 = 2;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x612=IKPowWithIntegerCheck(sj5,-1);
if(!x612.valid){
continue;
}
IkReal x611=x612.value;
CheckValue<IkReal> x613=IKPowWithIntegerCheck(cj4,-1);
if(!x613.valid){
continue;
}
CheckValue<IkReal> x614=IKPowWithIntegerCheck(cj5,-1);
if(!x614.valid){
continue;
}
if( IKabs((x611*(x613.value)*(x614.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x611)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x611*(x613.value)*(x614.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x611))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x611*(x613.value)*(x614.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x611));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x615=IKsin(j6);
IkReal x616=IKcos(j6);
IkReal x617=((1.0)*sj5);
IkReal x618=((1.0)*sj4);
IkReal x619=(cj5*sj4);
IkReal x620=(cj4*new_r01);
IkReal x621=(cj4*new_r00);
IkReal x622=((1.0)*x616);
IkReal x623=(cj5*x615);
IkReal x624=((1.0)*x615);
evalcond[0]=(new_r20+((sj5*x616)));
evalcond[1]=(new_r21+(((-1.0)*x615*x617)));
evalcond[2]=(((new_r11*sj4))+x620+x623);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x624))+(((-1.0)*new_r00*x618)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x622))+(((-1.0)*new_r01*x618)));
evalcond[5]=(((sj4*x616))+((cj4*x623))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x622))+x621);
evalcond[7]=(((sj4*x615))+(((-1.0)*cj4*cj5*x622))+new_r00);
evalcond[8]=((((-1.0)*cj4*x622))+((x615*x619))+new_r11);
evalcond[9]=((((-1.0)*cj4*x624))+(((-1.0)*cj5*x616*x618))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x617))+((cj5*x620))+((new_r11*x619))+x615);
evalcond[11]=((((-1.0)*x622))+((cj5*x621))+((new_r10*x619))+(((-1.0)*new_r20*x617)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x626=IKPowWithIntegerCheck(sj5,-1);
if(!x626.valid){
continue;
}
IkReal x625=x626.value;
CheckValue<IkReal> x627=IKPowWithIntegerCheck(sj4,-1);
if(!x627.valid){
continue;
}
if( IKabs((x625*(x627.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x625)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x625*(x627.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x625))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x625*(x627.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x625));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x628=IKsin(j6);
IkReal x629=IKcos(j6);
IkReal x630=((1.0)*sj5);
IkReal x631=((1.0)*sj4);
IkReal x632=(cj5*sj4);
IkReal x633=(cj4*new_r01);
IkReal x634=(cj4*new_r00);
IkReal x635=((1.0)*x629);
IkReal x636=(cj5*x628);
IkReal x637=((1.0)*x628);
evalcond[0]=(((sj5*x629))+new_r20);
evalcond[1]=((((-1.0)*x628*x630))+new_r21);
evalcond[2]=(((new_r11*sj4))+x636+x633);
evalcond[3]=((((-1.0)*new_r00*x631))+((cj4*new_r10))+(((-1.0)*x637)));
evalcond[4]=((((-1.0)*new_r01*x631))+((cj4*new_r11))+(((-1.0)*x635)));
evalcond[5]=(((sj4*x629))+((cj4*x636))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x635))+x634);
evalcond[7]=(((sj4*x628))+new_r00+(((-1.0)*cj4*cj5*x635)));
evalcond[8]=(((x628*x632))+(((-1.0)*cj4*x635))+new_r11);
evalcond[9]=((((-1.0)*cj5*x629*x631))+(((-1.0)*cj4*x637))+new_r10);
evalcond[10]=(((cj5*x633))+(((-1.0)*new_r21*x630))+((new_r11*x632))+x628);
evalcond[11]=((((-1.0)*x635))+((cj5*x634))+(((-1.0)*new_r20*x630))+((new_r10*x632)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x638=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x638.valid){
continue;
}
CheckValue<IkReal> x639 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x639.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x638.value)))+(x639.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x640=IKsin(j6);
IkReal x641=IKcos(j6);
IkReal x642=((1.0)*sj5);
IkReal x643=((1.0)*sj4);
IkReal x644=(cj5*sj4);
IkReal x645=(cj4*new_r01);
IkReal x646=(cj4*new_r00);
IkReal x647=((1.0)*x641);
IkReal x648=(cj5*x640);
IkReal x649=((1.0)*x640);
evalcond[0]=(((sj5*x641))+new_r20);
evalcond[1]=((((-1.0)*x640*x642))+new_r21);
evalcond[2]=(((new_r11*sj4))+x645+x648);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x649))+(((-1.0)*new_r00*x643)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x647))+(((-1.0)*new_r01*x643)));
evalcond[5]=(((cj4*x648))+((sj4*x641))+new_r01);
evalcond[6]=((((-1.0)*cj5*x647))+((new_r10*sj4))+x646);
evalcond[7]=(((sj4*x640))+(((-1.0)*cj4*cj5*x647))+new_r00);
evalcond[8]=(((x640*x644))+new_r11+(((-1.0)*cj4*x647)));
evalcond[9]=(new_r10+(((-1.0)*cj5*x641*x643))+(((-1.0)*cj4*x649)));
evalcond[10]=(((cj5*x645))+((new_r11*x644))+(((-1.0)*new_r21*x642))+x640);
evalcond[11]=(((cj5*x646))+(((-1.0)*x647))+((new_r10*x644))+(((-1.0)*new_r20*x642)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "1be8cb1bfa41cb1c5dc75eb7f102dc44"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
